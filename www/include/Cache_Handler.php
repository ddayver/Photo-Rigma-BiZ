<?php

/**
 * @file        include/Cache_Handler.php
 * @brief       Класс для работы с системами кеширования.
 *
 * @author      Dark Dayver
 * @version     0.4.2
 * @date        2025-04-27
 * @namespace   PhotoRigma\\Classes
 *
 * @details     Этот файл содержит реализацию класса `Cache_Handler`, который предоставляет методы для работы с
 *              различными типами кеширования:
 *              - Файловое кеширование (`file`).
 *              - Redis.
 *              - Memcached.
 *              Класс обеспечивает:
 *              - Проверку актуальности данных в кеше.
 *              - Запись данных в кеш.
 *              - Инициализацию системы кеширования на основе переданных параметров.
 *              - Обработку ошибок через исключения.
 *              Все операции выполняются в зависимости от выбранного типа кеширования (`$this->type`).
 *
 * @section     CacheHandler_Main_Functions Основные функции
 *              - Проверка актуальности данных в кеше с использованием ключа и контрольного числа.
 *              - Запись данных в кеш с кодированием в формат JSON и Base64.
 *              - Инициализация клиента для Redis/Memcached или пути для файлового кеширования.
 *              - Обработка ошибок через исключения (`JsonException`, `RuntimeException`).
 *
 * @see         PhotoRigma::Interfaces::Cache_Handler_Interface Интерфейс, который реализует класс.
 *
 * @note        Этот файл является частью системы PhotoRigma и обеспечивает взаимодействие приложения с системами
 *              кеширования. Реализованы меры безопасности для предотвращения повреждения данных в кеше.
 *
 * @copyright   Copyright (c) 2008-2025 Dark Dayver. Все права защищены.
 * @license     MIT License (https://opensource.org/licenses/MIT)
 *              Разрешается использовать, копировать, изменять, объединять, публиковать, распространять,
 *              сублицензировать и/или продавать копии программного обеспечения, а также разрешать лицам, которым
 *              предоставляется данное программное обеспечение, делать это при соблюдении следующих условий:
 *              - Уведомление об авторских правах и условия лицензии должны быть включены во все копии или значимые
 *                части программного обеспечения.
 */

namespace PhotoRigma\Classes;

use InvalidArgumentException;
use JsonException;
use Memcached;
use PhotoRigma\Interfaces\Cache_Handler_Interface;
use Redis;
use RuntimeException;

// Предотвращение прямого вызова файла
if (!defined('IN_GALLERY') || IN_GALLERY !== true) {
    error_log(
        date('H:i:s') . " [ERROR] | " . (filter_input(
            INPUT_SERVER,
            'REMOTE_ADDR',
            FILTER_VALIDATE_IP
        ) ?: 'UNKNOWN_IP') . " | " . __FILE__ . " | Попытка прямого вызова файла"
    );
    die("HACK!");
}

/**
 * @class   Cache_Handler
 * @brief   Класс для работы с системами кеширования.
 *
 * @details Этот класс предоставляет функционал для работы с различными типами кеширования:
 *          - Файловое кеширование (file).
 *          - Redis.
 *          - Memcached.
 *          Класс обеспечивает:
 *          - Проверку актуальности данных в кеше.
 *          - Запись данных в кеш.
 *          - Инициализацию системы кеширования на основе переданных параметров.
 *          - Обработку ошибок через исключения.
 *          Все операции выполняются в зависимости от выбранного типа кеширования (`$this->type`).
 *
 * @property Redis|Memcached|string|null $client     Клиент для Redis/Memcached или путь к директории кеша.
 *                                                   Для файлового кеширования хранит путь к директории.
 *                                                   Для Redis/Memcached хранит экземпляр клиента.
 * @property string                      $type       Тип кеширования (`file`, `redis`, `memcached`).
 *                                                   По умолчанию: `file`.
 *
 * Пример создания объекта класса Cache_Handler:
 * @code
 * // Пример для файлового кеширования
 * $config = [
 *     'type' => 'file',
 *     'cache_dir' => '/path/to/cache',
 * ];
 * $cache = new \PhotoRigma\Classes\Cache_Handler($config);
 *
 * // Пример для Redis
 * $config = [
 *     'type' => 'redis',
 *     'host' => '127.0.0.1',
 *     'port' => 6379,
 * ];
 * $cache = new \PhotoRigma\Classes\Cache_Handler($config);
 *
 * // Пример для Memcached
 * $config = [
 *     'type' => 'memcached',
 *     'host' => '127.0.0.1',
 *     'port' => 11211,
 * ];
 * $cache = new \PhotoRigma\Classes\Cache_Handler($config);
 * @endcode
 * @see     PhotoRigma::Interfaces::Cache_Handler_Interface Интерфейс, который реализует класс.
 */
class Cache_Handler implements Cache_Handler_Interface
{
    private Redis|Memcached|string|null $client; ///< Клиент для Redis/Memcached или путь к директории кеша
    private string $type; ///< Тип кеширования

    /**
     * @brief   Конструктор класса.
     *
     * @details Этот метод вызывается автоматически при создании нового объекта класса.
     *          Используется для инициализации системы кеширования на основе переданных параметров.
     *          Логика работы конструктора:
     *          1. Определяется тип кеширования из параметра `type` массива `$config`.
     *             - Если тип не указан, используется значение по умолчанию: `file`.
     *          2. В зависимости от типа кеширования выполняется инициализация:
     *             - Для файлового кеширования (`file`) вызывается метод `init_cache_file()`.
     *             - Для Redis (`redis`) вызывается метод `init_cache_redis()`.
     *             - Для Memcached (`memcached`) вызывается метод `init_cache_memcached()`.
     *          3. Если указан неизвестный тип кеширования, выбрасывается исключение `InvalidArgumentException`.
     *          Важно: Путь к директории кеша (`cache_dir`) обязателен для файлового кеширования.
     *          Хост и порт обязательны для Redis и Memcached.
     *
     * @callgraph
     *
     * @param array  $config     Массив с настройками кеширования:
     *                           - string `type`: Тип кеширования (`file`, `redis`, `memcached`).
     *                           Если тип не указан, используется значение по умолчанию: `file`.
     *                           Если указан неизвестный тип, выбрасывается исключение `InvalidArgumentException`.
     *                           - string `cache_dir` (опционально): Путь к директории кеша (для файлового кеширования).
     *                           Обязательный параметр для типа `file`. Если путь некорректен или недоступен,
     *                           это должно быть обработано в методе `init_cache_file()`.
     *                           - string `host` (опционально): Хост для Redis/Memcached.
     *                           Обязательный параметр для типов `redis` и `memcached`.
     *                           - int `port` (опционально): Порт для Redis/Memcached.
     *                           Если порт не указан, используются значения по умолчанию:
     *                           - Redis: 6379
     *                           - Memcached: 11211
     * @param string $site_dir   Полный путь к корню папок проекта (необязательный параметр).
     *                           Используется только для файлового кеширования. Если путь некорректен или недоступен,
     *                           это должно быть обработано в методе `init_cache_file()`.
     *
     * @throws InvalidArgumentException Выбрасывается, если указан неизвестный тип кеширования.
     *                                  Пример сообщения:
     *                                      Неизвестный тип кеширования | Тип: [тип]
     *
     * @warning Убедитесь, что:
     *          - Путь к директории кеша существует и доступен для записи (для файлового кеширования).
     *          - Хост и порт корректны и доступны (для Redis/Memcached).
     *          Несоблюдение этих условий может привести к ошибкам инициализации.
     *
     * Пример использования конструктора:
     * @code
     * $config = [
     *     'type' => 'file',
     *     'cache_dir' => '/path/to/cache',
     * ];
     * $cache = new \PhotoRigma\Classes\Cache_Handler($config);
     *
     * // Пример для Redis
     * $config = [
     *     'type' => 'redis',
     *     'host' => '127.0.0.1',
     *     'port' => 6379,
     * ];
     * $cache = new \PhotoRigma\Classes\Cache_Handler($config);
     * @endcode
     * @see     PhotoRigma::Classes::Cache_Handler::init_cache_file()
     *          Метод для инициализации файлового кеширования.
     * @see     PhotoRigma::Classes::Cache_Handler::init_cache_redis()
     *          Метод для инициализации кеширования через Redis.
     * @see     PhotoRigma::Classes::Cache_Handler::init_cache_memcached()
     *          Метод для инициализации кеширования через Memcached.
     */
    public function __construct(array $config, string $site_dir = '')
    {
        $this->type = $config['type'] ?? 'file';

        match ($this->type) {
            'file'      => $this->init_cache_file($config, $site_dir),
            'redis'     => $this->init_cache_redis($config),
            'memcached' => $this->init_cache_memcached($config),
            default     => throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Неизвестный тип кеширования | Тип: $this->type"
            ),
        };
    }

    /**
     * @brief   Инициализация файлового кеширования.
     *
     * @details Этот метод выполняет следующие действия:
     *          1. Нормализует путь к корню проекта, добавляя завершающий слэш (`/`).
     *          2. Формирует путь к директории кеша на основе переданных настроек.
     *             - Если параметр `cache_dir` не указан, используется значение по умолчанию: `cache`.
     *          3. Проверяет безопасность пути (запрещает использование `../` для предотвращения выхода за пределы
     *          директории).
     *             - Если путь содержит недопустимые символы, выбрасывается исключение `InvalidArgumentException`.
     *          4. Нормализует путь, используя функцию `realpath()`, чтобы получить абсолютный путь.
     *          5. Создаёт директорию кеша, если она не существует.
     *             - Если создание директории не удалось, выбрасывается исключение `RuntimeException`.
     *          6. Проверяет права записи в директорию.
     *             - Если директория недоступна для записи, выбрасывается исключение `RuntimeException`.
     *          7. Сохраняет нормализованный путь к директории кеша в свойство `$client`.
     *          Метод является приватным и предназначен только для использования внутри класса.
     *
     * @callergraph
     *
     * @param array  $config     Массив с настройками кеширования:
     *                           - string `cache_dir` (опционально): Путь к директории кеша относительно корня проекта.
     *                           Если не указан, используется значение по умолчанию: `cache`.
     *                           Если путь содержит недопустимые символы (например, `../`), выбрасывается исключение.
     * @param string $site_dir   Полный путь к корню папок проекта.
     *                           Если не указан, используется текущая директория (`__DIR__`).
     *
     * @throws InvalidArgumentException Выбрасывается, если путь к директории кеша содержит недопустимые символы.
     *                                  Пример сообщения:
     *                                      Недопустимый путь к директории кеша | Путь: [путь]
     * @throws RuntimeException Выбрасывается, если:
     *                                  - Не удалось создать директорию кеша.
     *                                    Пример сообщения:
     *                                        Не удалось создать директорию кеша | Путь: [путь]
     *                                  - Директория кеша недоступна для записи.
     *                                    Пример сообщения:
     *                                        Директория кеша недоступна для записи | Путь: [путь]
     *
     * @note    Для формирования пути к директории кеша используется параметр `cache_dir` из массива `$config`.
     *          Если параметр не указан, используется значение по умолчанию: `cache`.
     *          Путь нормализуется с помощью функции `realpath()` для получения абсолютного пути.
     *
     * @warning Убедитесь, что:
     *          - Путь к директории кеша не содержит недопустимых символов (например, `../`).
     *          - Директория кеша существует и доступна для записи.
     *          Несоблюдение этих условий может привести к ошибкам инициализации.
     *
     * Пример вызова метода:
     * @code
     * $config = [
     *     'cache_dir' => 'custom_cache',
     * ];
     * $site_dir = '/var/www/project/';
     * $this->init_cache_file($config, $site_dir);
     * @endcode
     *
     * @see     PhotoRigma::Classes::Cache_Handler::$client
     *          Свойство, содержащее путь к директории кеша после инициализации.
     */
    private function init_cache_file(array $config, string $site_dir): void
    {
        // 1. Нормализация пути к корню проекта
        $site_dir = rtrim($site_dir ?: __DIR__, '/') . '/';

        // 2. Формирование пути к директории кеша
        $cache_dir = rtrim($site_dir . ($config['cache_dir'] ?? 'cache'), '/') . '/';

        // 3. Проверка безопасности пути (запрещаем использование '../')
        if (preg_match('#\.\.[/\\\\]#', $cache_dir)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Недопустимый путь к директории кеша | Путь: $cache_dir"
            );
        }

        // 4. Нормализация пути (убираем лишние символы)
        $normalized_cache_dir = realpath($cache_dir) ?: $cache_dir;

        // 5. Создание директории, если она не существует
        if (!is_dir($normalized_cache_dir) && !mkdir($normalized_cache_dir, 0755, true) && !is_dir(
            $normalized_cache_dir
        )) {
            throw new RuntimeException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Не удалось создать директорию кеша | Путь: $normalized_cache_dir"
            );
        }

        // 6. Проверка прав записи в директорию
        if (!is_writable($normalized_cache_dir)) {
            throw new RuntimeException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Директория кеша недоступна для записи | Путь: $normalized_cache_dir"
            );
        }
        $normalized_cache_dir = rtrim($normalized_cache_dir, '/') . '/';

        // 7. Сохраняем путь к директории кеша
        $this->client = $normalized_cache_dir;
    }

    /**
     * @brief   Инициализация Redis.
     *
     * @details Этот метод выполняет следующие действия:
     *          1. Проверяет наличие Redis-расширения в PHP.
     *             - Если расширение недоступно, выбрасывается исключение `RuntimeException`.
     *          2. Создаёт экземпляр класса `Redis`.
     *          3. Формирует параметры подключения к Redis:
     *             - Хост (по умолчанию: `127.0.0.1`).
     *             - Порт (по умолчанию: `6379`).
     *             - Таймаут подключения (по умолчанию: `2.0` секунды).
     *          4. Выполняет подключение к Redis.
     *             - Если подключение не удалось, выбрасывается исключение `RuntimeException`.
     *          5. Сохраняет экземпляр клиента Redis в свойство `$client`.
     *          Метод является приватным и предназначен только для использования внутри класса.
     *
     * @callergraph
     *
     * @param array $config   Массив с настройками кеширования:
     *                        - string `host` (опционально): Хост Redis.
     *                        Если не указан, используется значение по умолчанию: `127.0.0.1`.
     *                        - int `port` (опционально): Порт Redis.
     *                        Если не указан, используется значение по умолчанию: `6379`.
     *
     * @throws RuntimeException Выбрасывается, если:
     *                                  - Redis-расширение недоступно.
     *                                    Пример сообщения:
     *                                        Redis-расширение недоступно | Рекомендация: убедитесь, что оно
     *                                        установлено и включено в PHP
     *                                  - Не удалось подключиться к Redis.
     *                                    Пример сообщения:
     *                                        Не удалось подключиться к Redis | Хост: [хост]:[порт]
     *
     * @note    Для подключения к Redis используются параметры `host` и `port` из массива `$config`.
     *          Если параметры не указаны, используются значения по умолчанию:
     *          - Хост: `127.0.0.1`
     *          - Порт: `6379`
     *          Таймаут подключения установлен на `2.0` секунды.
     *
     * @warning Убедитесь, что:
     *          - Redis-расширение установлено и включено в PHP.
     *          - Хост и порт Redis корректны и доступны.
     *          Несоблюдение этих условий может привести к ошибкам инициализации.
     *
     * Пример вызова метода:
     * @code
     * $config = [
     *     'host' => '127.0.0.1',
     *     'port' => 6379,
     * ];
     * $this->init_cache_redis($config);
     * @endcode
     * @see     PhotoRigma::Classes::Cache_Handler::$client
     *          Свойство, содержащее экземпляр клиента Redis после инициализации.
     */
    private function init_cache_redis(array $config): void
    {
        // 1. Проверка наличия Redis-расширения
        if (!extension_loaded('redis')) {
            throw new RuntimeException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Redis-расширение недоступно | Рекомендация: убедитесь, что оно установлено и включено в PHP"
            );
        }

        // 2. Создание экземпляра Redis
        $redis = new Redis();

        // 3. Формирование параметров подключения
        $host = $config['host'] ?? '127.0.0.1';
        $port = ($config['port'] !== null && $config['port'] !== '') ? $config['port'] : 6379;
        $timeout = 2.0; // Таймаут подключения в секундах

        // 4. Подключение к Redis
        if (!$redis->connect($host, (int)$port, $timeout)) {
            throw new RuntimeException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Не удалось подключиться к Redis | Хост: $host:$port"
            );
        }

        // 5. Сохраняем клиент Redis
        $this->client = $redis;
    }

    /**
     * @brief   Инициализация Memcached.
     *
     * @details Этот метод выполняет следующие действия:
     *          1. Проверяет наличие Memcached-расширения в PHP.
     *             - Если расширение недоступно, выбрасывается исключение `RuntimeException`.
     *          2. Создаёт экземпляр класса `Memcached`.
     *          3. Формирует параметры подключения к Memcached:
     *             - Хост (по умолчанию: `127.0.0.1`).
     *             - Порт (по умолчанию: `11211`).
     *          4. Добавляет сервер Memcached с указанными параметрами.
     *          5. Проверяет успешность подключения к серверу Memcached.
     *             - Если подключение не удалось, выбрасывается исключение `RuntimeException`.
     *          6. Сохраняет экземпляр клиента Memcached в свойство `$client`.
     *          Метод является приватным и предназначен только для использования внутри класса.
     *
     * @callergraph
     *
     * @param array $config   Массив с настройками кеширования:
     *                        - string `host` (опционально): Хост Memcached.
     *                        Если не указан, используется значение по умолчанию: `127.0.0.1`.
     *                        - int `port` (опционально): Порт Memcached.
     *                        Если не указан, используется значение по умолчанию: `11211`.
     *
     * @throws RuntimeException Выбрасывается, если:
     *                                  - Memcached-расширение недоступно.
     *                                    Пример сообщения:
     *                                        Memcached-расширение недоступно | Рекомендация: убедитесь, что оно
     *                                        установлено и включено в PHP
     *                                  - Не удалось подключиться к Memcached.
     *                                    Пример сообщения:
     *                                        Не удалось подключиться к Memcached | Хост: [хост]:[порт]
     *
     * @note    Для подключения к Memcached используются параметры `host` и `port` из массива `$config`.
     *          Если параметры не указаны, используются значения по умолчанию:
     *          - Хост: `127.0.0.1`
     *          - Порт: `11211`
     *          После добавления сервера выполняется проверка успешности подключения через метод `getStats()`.
     *
     * @warning Убедитесь, что:
     *          - Memcached-расширение установлено и включено в PHP.
     *          - Хост и порт Memcached корректны и доступны.
     *          Несоблюдение этих условий может привести к ошибкам инициализации.
     *
     * Пример вызова метода:
     * @code
     * $config = [
     *     'host' => '127.0.0.1',
     *     'port' => 11211,
     * ];
     * $this->init_cache_memcached($config);
     * @endcode
     * @see     PhotoRigma::Classes::Cache_Handler::$client
     *          Свойство, содержащее экземпляр клиента Memcached после инициализации.
     */
    private function init_cache_memcached(array $config): void
    {
        // 1. Проверка наличия Memcached-расширения
        if (!extension_loaded('memcached')) {
            throw new RuntimeException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Memcached-расширение недоступно | Рекомендация: убедитесь, что оно установлено и включено в PHP"
            );
        }

        // 2. Создание экземпляра Memcached
        $memcached = new Memcached();

        // 3. Формирование параметров подключения
        $host = $config['host'] ?? '127.0.0.1';
        $port = ($config['port'] !== null && $config['port'] !== '') ? $config['port'] : 11211;

        // 4. Добавление сервера
        $memcached->addServer($host, (int)$port);

        // 5. Проверка успешности подключения
        $stats = @$memcached->getStats();
        if ($stats === false || empty($stats["$host:$port"])) {
            throw new RuntimeException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Не удалось подключиться к Memcached | Хост: $host:$port"
            );
        }

        // 6. Сохраняем клиент Memcached
        $this->client = $memcached;
    }

    /**
     * @brief   Проверяет актуальность данных в кеше.
     *
     * @details Этот метод выполняет проверку актуальности данных в зависимости от типа кеширования:
     *          - Если тип кеширования — `file`, используется файловый кеш.
     *          - Если тип кеширования — `redis` или `memcached`, используется хранилище (Redis/Memcached).
     *          - Если тип кеширования не поддерживается, возвращается `false`.
     *          Метод является публичным и предназначен для использования вне класса.
     *
     * @param string     $key      Ключ кеша. Используется для проверки актуальности данных.
     *                             Пример: `'user_settings'`.
     * @param int|string $checksum Контрольное число или хеш-строка для проверки актуальности данных.
     *                             Должно соответствовать сохранённому значению в кеше.
     *
     * @return array|false Массив данных, если кеш актуален, или `false`, если:
     *                     - Тип кеширования не поддерживается.
     *                     - Данные в кеше устарели или отсутствуют.
     *
     * @throws JsonException Выбрасывается при ошибках декодирования JSON:
     *                        Пример сообщения:
     *                            Ошибка декодирования JSON: [подробное описание ошибки]
     * @throws RuntimeException Выбрасывается при следующих условиях:
     *                           - Для Redis/Memcached:
     *                             - Если клиент хранилища не инициализирован или имеет неправильный тип.
     *                           Пример сообщения:
     *                               Клиент хранилища не инициализирован или имеет неправильный тип
     *
     * @note    Метод использует защищённый метод `_is_valid_internal` для выполнения проверки актуальности данных.
     *
     * @warning Убедитесь, что:
     *          - Тип кеширования (`$this->type`) поддерживается.
     *          - Файлы кеша или хранилище правильно настроены и доступны для чтения.
     *          Несоблюдение этих условий может привести к ошибкам проверки актуальности.
     *
     * Пример вызова метода:
     * @code
     * $cacheHandler = new Cache_Handler();
     * $key = 'user_settings';
     * $checksum = 12345;
     * $data = $cacheHandler->is_valid($key, $checksum);
     * if ($data !== false) {
     *     print_r($data);
     * } else {
     *     echo "Кеш устарел или отсутствует.";
     * }
     * @endcode
     *
     * @see     PhotoRigma::Classes::Cache_Handler::_is_valid_internal()
     *          Защищённый метод, который реализует логику проверки актуальности данных в кеше.
     */
    public function is_valid(string $key, int|string $checksum): array|false
    {
        return $this->_is_valid_internal($key, $checksum);
    }

    /**
     * @brief   Проверяет актуальность данных в кеше.
     *
     * @details Этот метод выполняет проверку актуальности данных в зависимости от типа кеширования:
     *          1. Если тип кеширования — `file`, вызывается метод `is_valid_file()`.
     *          2. Если тип кеширования — `redis` или `memcached`, вызывается метод `is_valid_storage()`.
     *          3. Если тип кеширования не поддерживается, возвращается `false`.
     *          Метод является защищённым (protected) и предназначен для использования внутри класса или его
     *          наследников. Вызывается из публичного метода `is_valid` как часть логики работы с кешем.
     *
     * @callergraph
     * @callgraph
     *
     * @param string     $key      Ключ кеша. Используется для проверки актуальности данных.
     *                             Пример: `'user_settings'`.
     * @param int|string $checksum Контрольное число или хеш-строка для проверки актуальности данных.
     *                             Должно соответствовать сохранённому значению в кеше.
     *
     * @return array|false Массив данных, если кеш актуален, или `false`, если:
     *                     - Тип кеширования не поддерживается.
     *                     - Данные в кеше устарели или отсутствуют.
     *
     * @throws JsonException Выбрасывается из подметодов при ошибках декодирования JSON:
     *                        - Для файлового кеширования: `is_valid_file()`.
     *                        - Для Redis/Memcached: `is_valid_storage()`.
     *                        Пример сообщения:
     *                            Ошибка декодирования JSON: [подробное описание ошибки]
     * @throws RuntimeException Выбрасывается из метода `is_valid_storage`, если клиент хранилища:
     *                           - Не инициализирован.
     *                           - Имеет неправильный тип.
     *                           Пример сообщения:
     *                               Клиент хранилища не инициализирован или имеет неправильный тип
     *
     * @note    Метод использует внутренние методы для проверки актуальности данных:
     *          - Для файлового кеширования: `is_valid_file()`.
     *          - Для Redis/Memcached: `is_valid_storage()`.
     *          Все исключения, связанные с проверкой данных, генерируются этими подметодами.
     *
     * @warning Убедитесь, что:
     *          - Тип кеширования (`$this->type`) поддерживается.
     *          - Файлы кеша или хранилище правильно настроены и доступны для чтения.
     *          Несоблюдение этих условий может привести к ошибкам проверки актуальности.
     *
     * Пример вызова метода:
     * @code
     * $key = 'user_settings';
     * $checksum = 12345;
     * $data = $this->_is_valid_internal($key, $checksum);
     * if ($data !== false) {
     *     print_r($data);
     * } else {
     *     echo "Кеш устарел или отсутствует.";
     * }
     * @endcode
     * @see     PhotoRigma::Classes::Cache_Handler::is_valid_file()
     *          Метод для проверки актуальности данных в файловом кеше.
     * @see     PhotoRigma::Classes::Cache_Handler::is_valid_storage()
     *          Метод для проверки актуальности данных в хранилище (Redis/Memcached).
     * @see     PhotoRigma::Classes::Cache_Handler::is_valid()
     *          Публичный метод, который вызывает `_is_valid_internal` для проверки актуальности данных.
     */
    protected function _is_valid_internal(string $key, int|string $checksum): array|false
    {
        return match ($this->type) {
            'file'               => $this->is_valid_file($key, $checksum),
            'redis', 'memcached' => $this->is_valid_storage($key, $checksum),
            default              => false,
        };
    }

    /**
     * @brief   Проверяет актуальность данных в файловом кеше.
     *
     * @details Этот метод выполняет следующие действия:
     *          1. Формирует путь к файлу кеша на основе ключа `$key`.
     *             - Путь формируется как: `$this->client . $key . '.php'`.
     *          2. Проверяет существование и читаемость файла кеша.
     *             - Если файл не существует или недоступен для чтения, возвращается `false`.
     *          3. Читает содержимое файла кеша.
     *             - Если чтение не удалось, возвращается `false`.
     *          4. Извлекает значения переменных `$checksum` и данные из содержимого файла с помощью регулярных
     *          выражений.
     *             - Переменная `$checksum` должна быть в формате: `$checksum = 'значение';`.
     *             - Данные должны быть в формате: `$cached_data = 'base64_encoded_json_data';`.
     *             - Если извлечение значений не удалось, возвращается `false`.
     *          5. Проверяет контрольную сумму (`$stored_checksum`) на соответствие переданной (`$checksum`).
     *             - Если контрольная сумма не совпадает или данные отсутствуют, возвращается `false`.
     *          6. Декодирует данные из формата Base64 и JSON.
     *             - Если декодирование не удалось, выбрасывается исключение `JsonException`.
     *          7. Возвращает массив данных, если они корректны, или `false`, если проверка не удалась.
     *          Метод является приватным и предназначен только для использования внутри класса.
     *
     * @callergraph
     *
     * @param string     $key      Ключ кеша. Используется для формирования имени файла кеша.
     *                             Пример: `'user_settings'`.
     * @param int|string $checksum Контрольное число или хеш-строка для проверки актуальности данных.
     *                             Должно соответствовать сохранённому значению в файле кеша.
     *
     * @return array|false Массив данных, если кеш актуален, или `false`, если:
     *                     - Файл кеша не существует или недоступен для чтения.
     *                     - Контрольная сумма не совпадает.
     *                     - Данные в файле кеша некорректны.
     *
     * @throws JsonException Выбрасывается, если произошла ошибка при декодировании данных из JSON.
     *                        Пример сообщения:
     *                            Ошибка декодирования JSON: [подробное описание ошибки]
     *
     * @note    Файл кеша должен содержать переменные `$checksum` и данные в следующем формате:
     * @code
     * <?php
     * $checksum = '12345';
     * $cached_data = 'base64_encoded_json_data';
     * @endcode
     *
     * @warning Убедитесь, что:
     *          - Файлы кеша доступны для чтения.
     *          - Содержимое файлов кеша соответствует ожидаемому формату.
     *          Несоблюдение этих условий может привести к ошибкам проверки актуальности.
     *
     * Пример вызова метода:
     * @code
     * $key = 'user_settings';
     * $checksum = 12345;
     * $data = $this->is_valid_file($key, $checksum);
     * if ($data !== false) {
     *     print_r($data);
     * } else {
     *     echo "Кеш устарел или отсутствует.";
     * }
     * @endcode
     */
    private function is_valid_file(string $key, int|string $checksum): array|false
    {
        // 1. Формирование пути к файлу кеша
        $cache_file = $this->client . $key . '.php';

        // 2. Проверка существования и читаемости файла
        if (!is_file($cache_file) || !is_readable($cache_file)) {
            return false;
        }

        // 3. Чтение содержимого файла
        $content = file_get_contents($cache_file);
        if ($content === false) {
            return false;
        }

        // 4. Извлечение переменных из содержимого файла
        if (!preg_match('/\$checksum\s*=\s*\'([^\']+)\'\s*;/', $content, $checksum_match) || !preg_match(
            '/\$config_data\s*=\s*\'([^\']+)\'\s*;/',
            $content,
            $data_match
        )) {
            return false;
        }

        $stored_checksum = $checksum_match[1];
        $cached_data = $data_match[1];

        // 5. Проверка контрольной суммы
        if ((string)$stored_checksum !== (string)$checksum || empty($cached_data)) {
            return false;
        }

        // 6. Декодирование данных
        $decoded_data = json_decode(base64_decode($cached_data), true, 512, JSON_THROW_ON_ERROR);

        // 7. Возвращаем данные, если они корректны
        return is_array($decoded_data) ? $decoded_data : false;
    }

    /**
     * @brief   Проверяет актуальность данных в хранилище (Redis/Memcached).
     *
     * @details Этот метод выполняет следующие действия:
     *          1. Проверяет, что клиент хранилища инициализирован и является экземпляром класса `Redis` или
     *          `Memcached`.
     *             - Если клиент не инициализирован или имеет неправильный тип, выбрасывается исключение
     *             `RuntimeException`.
     *          2. Получает сохранённую контрольную сумму из хранилища по ключу `$key . '_checksum'`.
     *             - Если контрольная сумма отсутствует или не совпадает с переданной (`$checksum`), возвращается
     *             `false`.
     *          3. Получает закодированные данные из хранилища по ключу `$key . '_data'`.
     *             - Если данные отсутствуют, возвращается `false`.
     *          4. Декодирует данные из формата Base64 и JSON.
     *             - Если декодирование не удалось, выбрасывается исключение `JsonException`.
     *          5. Возвращает массив данных, если они корректны, или `false`, если проверка не удалась.
     *          Метод является приватным и предназначен только для использования внутри класса.
     *
     * @callergraph
     *
     * @param string     $key      Ключ кеша. Используется для получения контрольной суммы и данных из хранилища.
     *                             Пример: `'user_settings'`.
     * @param int|string $checksum Контрольное число или хеш-строка для проверки актуальности данных.
     *                             Должно соответствовать сохранённому значению в хранилище.
     *
     * @return array|false Массив данных, если кеш актуален, или `false`, если:
     *                     - Клиент хранилища не инициализирован или имеет неправильный тип.
     *                     - Контрольная сумма отсутствует или не совпадает.
     *                     - Данные в хранилище отсутствуют или некорректны.
     *
     * @throws JsonException Выбрасывается, если произошла ошибка при декодировании данных из JSON.
     *                        Пример сообщения:
     *                            Ошибка декодирования JSON: [подробное описание ошибки]
     * @throws RuntimeException Выбрасывается, если клиент хранилища не инициализирован или имеет неправильный тип.
     *                           Пример сообщения:
     *                               Клиент хранилища не инициализирован или имеет неправильный тип
     *
     * @note    Хранилище должно содержать два ключа для каждого элемента:
     *          - `$key . '_checksum'`: Контрольная сумма для проверки актуальности данных.
     *          - `$key . '_data'`: Закодированные данные в формате Base64.
     *          Пример структуры данных в Redis:
     * @code
     *          user_settings_checksum => '12345'
     *          user_settings_data     => 'base64_encoded_json_data'
     * @endcode
     *
     * @warning Убедитесь, что:
     *          - Клиент хранилища правильно инициализирован и поддерживает метод `get()`.
     *          - Ключи `$key . '_checksum'` и `$key . '_data'` существуют в хранилище.
     *          Несоблюдение этих условий может привести к ошибкам проверки актуальности.
     *
     * Пример вызова метода:
     * @code
     * $key = 'user_settings';
     * $checksum = 12345;
     * $data = $this->is_valid_storage($key, $checksum);
     * if ($data !== false) {
     *     print_r($data);
     * } else {
     *     echo "Кеш устарел или отсутствует.";
     * }
     * @endcode
     */
    private function is_valid_storage(string $key, int|string $checksum): array|false
    {
        // 1. Проверка, что клиент инициализирован и поддерживает метод get()
        if (!($this->client instanceof Redis || $this->client instanceof Memcached)) {
            throw new RuntimeException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Клиент хранилища не инициализирован или имеет неправильный тип"
            );
        }

        // 2. Получение сохранённой контрольной суммы
        $stored_checksum = $this->client->get($key . '_checksum');
        if ($stored_checksum === false || (string)$stored_checksum !== (string)$checksum) {
            return false;
        }

        // 3. Получение закодированных данных
        $encoded_data = $this->client->get($key . '_data');
        if ($encoded_data === false) {
            return false;
        }

        // 4. Декодирование данных
        $decoded_data = json_decode(base64_decode($encoded_data), true, 512, JSON_THROW_ON_ERROR);

        // 5. Возвращаем данные, если они корректны
        return is_array($decoded_data) ? $decoded_data : false;
    }

    /**
     * @brief   Записывает данные в кеш.
     *
     * @details Этот метод выполняет запись данных в зависимости от типа кеширования:
     *          - Если тип кеширования — `file`, используется файловый кеш.
     *          - Если тип кеширования — `redis` или `memcached`, используется хранилище (Redis/Memcached).
     *          - Если тип кеширования не поддерживается, возвращается `false`.
     *          Метод является публичным и предназначен для использования вне класса.
     *
     * @param string     $key      Ключ кеша. Используется для записи данных.
     *                             Пример: `'user_settings'`.
     * @param int|string $checksum Контрольное число или хеш-строка для проверки актуальности данных.
     *                             Будет сохранено в кеше.
     * @param array      $data     Данные для записи. Будут закодированы в формат JSON и Base64.
     *                             Пример: `['theme' => 'dark', 'language' => 'en']`.
     *
     * @return bool True, если запись успешна, или `false`, если:
     *              - Тип кеширования не поддерживается.
     *              - Произошла ошибка при записи данных.
     *
     * @throws JsonException Выбрасывается при ошибках кодирования JSON:
     *                        Пример сообщения:
     *                            Ошибка кодирования JSON: [подробное описание ошибки]
     * @throws RuntimeException Выбрасывается при следующих условиях:
     *                           - Для файлового кеширования:
     *                             - Если директория для кеша не существует или недоступна для записи.
     *                             - Если файл кеша недоступен для записи.
     *                           - Для Redis/Memcached:
     *                             - Если клиент хранилища не инициализирован или имеет неправильный тип.
     *                           Пример сообщения:
     *                               Директория для кеша недоступна для записи | Путь: [путь]
     *
     * @note    Метод использует защищённый метод `_update_cache_internal` для выполнения записи данных.
     *
     * @warning Убедитесь, что:
     *          - Тип кеширования (`$this->type`) поддерживается.
     *          - Файлы кеша или хранилище правильно настроены и доступны для записи.
     *          Несоблюдение этих условий может привести к ошибкам записи данных.
     *
     * Пример вызова метода:
     * @code
     * $cacheHandler = new Cache_Handler();
     * $key = 'user_settings';
     * $checksum = 12345;
     * $data = ['theme' => 'dark', 'language' => 'en'];
     * if ($cacheHandler->update_cache($key, $checksum, $data)) {
     *     echo "Данные успешно записаны в кеш.";
     * } else {
     *     echo "Ошибка записи данных в кеш.";
     * }
     * @endcode
     * @see     PhotoRigma::Classes::Cache_Handler::_update_cache_internal()
     *          Защищённый метод, который реализует логику записи данных в кеш.
     */
    public function update_cache(string $key, int|string $checksum, array $data): bool
    {
        return $this->_update_cache_internal($key, $checksum, $data);
    }

    /**
     * @brief   Записывает данные в кеш.
     *
     * @details Этот метод выполняет запись данных в зависимости от типа кеширования:
     *          1. Если тип кеширования — `file`, вызывается метод `update_cache_file()`.
     *          2. Если тип кеширования — `redis` или `memcached`, вызывается метод `update_cache_storage()`.
     *          3. Если тип кеширования не поддерживается, возвращается `false`.
     *          Метод является защищённым (protected) и предназначен для использования внутри класса или его
     *          наследников. Вызывается из публичного метода `update_cache` как часть логики работы с кешем.
     *
     * @callergraph
     * @callgraph
     *
     * @param string     $key      Ключ кеша. Используется для записи данных.
     *                             Пример: `'user_settings'`.
     * @param int|string $checksum Контрольное число или хеш-строка для проверки актуальности данных.
     *                             Будет сохранено в кеше.
     * @param array      $data     Данные для записи. Будут закодированы в формат JSON и Base64.
     *                             Пример: `['theme' => 'dark', 'language' => 'en']`.
     *
     * @return bool True, если запись успешна, или `false`, если:
     *              - Тип кеширования не поддерживается.
     *              - Произошла ошибка при записи данных.
     *
     * @throws JsonException Выбрасывается из подметодов при ошибках кодирования JSON:
     *                        - Для файлового кеширования: `update_cache_file()`.
     *                        - Для Redis/Memcached: `update_cache_storage()`.
     *                        Пример сообщения:
     *                            Ошибка кодирования JSON: [подробное описание ошибки]
     * @throws RuntimeException Выбрасывается из подметодов при следующих условиях:
     *                           - Для файлового кеширования:
     *                             - Если директория для кеша не существует.
     *                               Пример сообщения:
     *                                   Директория для кеша не существует | Путь: [путь]
     *                             - Если директория для кеша недоступна для записи.
     *                               Пример сообщения:
     *                                   Директория для кеша недоступна для записи | Путь: [путь]
     *                             - Если файл кеша недоступен для записи.
     *                               Пример сообщения:
     *                                   Файл кеша недоступен для записи | Путь: [путь]
     *                           - Для Redis/Memcached:
     *                             - Если клиент хранилища не инициализирован или имеет неправильный тип.
     *                               Пример сообщения:
     *                                   Клиент хранилища не инициализирован или имеет неправильный тип
     *
     * @note    Метод использует внутренние методы для записи данных:
     *          - Для файлового кеширования: `update_cache_file()`.
     *          - Для Redis/Memcached: `update_cache_storage()`.
     *          Все исключения, связанные с записью данных, генерируются этими подметодами.
     *
     * @warning Убедитесь, что:
     *          - Тип кеширования (`$this->type`) поддерживается.
     *          - Файлы кеша или хранилище правильно настроены и доступны для записи.
     *          Несоблюдение этих условий может привести к ошибкам записи данных.
     *
     * Пример вызова метода:
     * @code
     * $key = 'user_settings';
     * $checksum = 12345;
     * $data = ['theme' => 'dark', 'language' => 'en'];
     * if ($this->_update_cache_internal($key, $checksum, $data)) {
     *     echo "Данные успешно записаны в кеш.";
     * } else {
     *     echo "Ошибка записи данных в кеш.";
     * }
     * @endcode
     * @see     PhotoRigma::Classes::Cache_Handler::update_cache_file()
     *          Метод для записи данных в файловый кеш.
     * @see     PhotoRigma::Classes::Cache_Handler::update_cache_storage()
     *          Метод для записи данных в хранилище (Redis/Memcached).
     * @see     PhotoRigma::Classes::Cache_Handler::update_cache()
     *          Публичный метод, который вызывает `_update_cache_internal` для записи данных в кеш.
     */
    protected function _update_cache_internal(string $key, int|string $checksum, array $data): bool
    {
        return match ($this->type) {
            'file'               => $this->update_cache_file($key, $checksum, $data),
            'redis', 'memcached' => $this->update_cache_storage($key, $checksum, $data),
            default              => false,
        };
    }

    /**
     * @brief   Записывает данные в файловый кеш.
     *
     * @details Этот метод выполняет следующие действия:
     *          1. Формирует путь к файлу кеша на основе ключа `$key`.
     *             - Путь формируется как: `$this->client . $key . '.php'`.
     *          2. Проверяет существование директории и права записи.
     *             - Если директория не существует, выбрасывается исключение `RuntimeException`.
     *             - Если директория недоступна для записи, выбрасывается исключение `RuntimeException`.
     *          3. Проверяет существование файла кеша и возможность его перезаписи.
     *             - Если файл существует, но недоступен для записи, выбрасывается исключение `RuntimeException`.
     *          4. Кодирует данные в формат JSON и Base64.
     *             - Если кодирование JSON не удалось, выбрасывается исключение `JsonException`.
     *          5. Формирует содержимое файла в формате PHP:
     * @code
     *          <?php
     *          $checksum = 'значение';
     *          $cached_data = 'base64_encoded_json_data';
     * @endcode
     *          6. Записывает данные в файл с использованием блокировки (`LOCK_EX`).
     *             - Возвращает `true`, если запись успешна, или `false` в противном случае.
     *          Метод является приватным и предназначен только для использования внутри класса.
     *
     * @callergraph
     *
     * @param string     $key      Ключ кеша. Используется для формирования имени файла кеша.
     *                             Пример: `'user_settings'`.
     * @param int|string $checksum Контрольное число или хеш-строка для проверки актуальности данных.
     *                             Должно соответствовать сохранённому значению в файле кеша.
     * @param array      $data     Данные для записи. Будут закодированы в формат JSON и Base64.
     *                             Пример: `['theme' => 'dark', 'language' => 'en']`.
     *
     * @return bool True, если запись успешна, или `false`, если произошла ошибка при записи.
     *
     * @throws RuntimeException Выбрасывается, если:
     *                           - Директория для кеша не существует.
     *                             Пример сообщения:
     *                                 Директория для кеша не существует | Путь: [путь]
     *                           - Директория для кеша недоступна для записи.
     *                             Пример сообщения:
     *                                 Директория для кеша недоступна для записи | Путь: [путь]
     *                           - Файл кеша недоступен для записи.
     *                             Пример сообщения:
     *                                 Файл кеша недоступен для записи | Путь: [путь]
     * @throws JsonException Выбрасывается, если произошла ошибка при кодировании данных в JSON.
     *                        Пример сообщения:
     *                            Ошибка кодирования JSON: [подробное описание ошибки]
     *
     * @note    Файл кеша создаётся в формате PHP с переменными `$checksum` и `$cached_data`:
     * @code
     *          <?php
     *          $checksum = '12345';
     *          $cached_data = 'base64_encoded_json_data';
     * @endcode
     *          Данные хранятся в формате Base64 для безопасности.
     *
     * @warning Убедитесь, что:
     *          - Директория для кеша существует и доступна для записи.
     *          - Файлы кеша доступны для записи (если они уже существуют).
     *          Несоблюдение этих условий может привести к ошибкам записи данных.
     *
     * Пример вызова метода:
     * @code
     * $key = 'user_settings';
     * $checksum = 12345;
     * $data = ['theme' => 'dark', 'language' => 'en'];
     * if ($this->update_cache_file($key, $checksum, $data)) {
     *     echo "Данные успешно записаны в кеш.";
     * } else {
     *     echo "Ошибка записи данных в кеш.";
     * }
     * @endcode
     */
    private function update_cache_file(string $key, int|string $checksum, array $data): bool
    {
        // 1. Формирование пути к файлу кеша
        $cache_file = $this->client . $key . '.php';

        // 2. Проверка существования директории и прав записи
        $cache_dir = dirname($cache_file);
        if (!is_dir($cache_dir)) {
            throw new RuntimeException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Директория для кеша не существует | Путь: $cache_dir"
            );
        }
        if (!is_writable($cache_dir)) {
            throw new RuntimeException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Директория для кеша недоступна для записи | Путь: $cache_dir"
            );
        }

        // 3. Проверка существования файла и возможности его перезаписи
        if (is_file($cache_file) && !is_writable($cache_file)) {
            throw new RuntimeException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Файл кеша недоступен для записи | Путь: $cache_file"
            );
        }

        // 4. Кодирование данных
        $encoded_data = base64_encode(
            json_encode(
                $data,
                JSON_THROW_ON_ERROR | JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES
            )
        );

        // 5. Формирование содержимого файла
        $cache_content = sprintf(
            "<?php" . PHP_EOL . "\$checksum = '%s';" . PHP_EOL . "\$cached_data = '%s';" . PHP_EOL,
            $checksum,
            $encoded_data
        );

        // 6. Запись данных в файл
        return file_put_contents($cache_file, $cache_content, LOCK_EX) !== false;
    }

    /**
     * @brief   Записывает данные в хранилище (Redis/Memcached).
     *
     * @details Этот метод выполняет следующие действия:
     *          1. Проверяет, что клиент хранилища инициализирован и является экземпляром класса `Redis` или
     *          `Memcached`.
     *             - Если клиент не инициализирован или имеет неправильный тип, выбрасывается исключение
     *             `RuntimeException`.
     *          2. Кодирует данные в формат JSON и Base64.
     *             - Если кодирование JSON не удалось, выбрасывается исключение `JsonException`.
     *          3. Записывает контрольную сумму и закодированные данные в хранилище по двум ключам:
     *             - `$key . '_checksum'`: Контрольная сумма.
     *             - `$key . '_data'`: Закодированные данные.
     *          4. Возвращает результат записи: `true`, если оба ключа успешно записаны, или `false`, если хотя бы одна
     *          запись не удалась. Метод является приватным и предназначен только для использования внутри класса.
     *
     * @callergraph
     *
     * @param string     $key      Ключ кеша. Используется для формирования ключей `_checksum` и `_data`.
     *                             Пример: `'user_settings'`.
     * @param int|string $checksum Контрольное число или хеш-строка для проверки актуальности данных.
     *                             Будет сохранено в хранилище под ключом `$key . '_checksum'`.
     * @param array      $data     Данные для записи. Будут закодированы в формат JSON и Base64.
     *                             Пример: `['theme' => 'dark', 'language' => 'en']`.
     *
     * @return bool True, если запись успешна, или `false`, если произошла ошибка при записи хотя бы одного ключа.
     *
     * @throws JsonException Выбрасывается, если произошла ошибка при кодировании данных в JSON.
     *                        Пример сообщения:
     *                            Ошибка кодирования JSON: [подробное описание ошибки]
     * @throws RuntimeException Выбрасывается, если клиент хранилища не инициализирован или имеет неправильный тип.
     *                           Пример сообщения:
     *                               Клиент хранилища не инициализирован или имеет неправильный тип
     *
     * @note    Хранилище содержит два ключа для каждого элемента:
     *          - `$key . '_checksum'`: Контрольная сумма для проверки актуальности данных.
     *          - `$key . '_data'`: Закодированные данные в формате Base64.
     *          Пример структуры данных в Redis:
     * @code
     *          user_settings_checksum => '12345'
     *          user_settings_data     => 'base64_encoded_json_data'
     * @endcode
     *
     * @warning Убедитесь, что:
     *          - Клиент хранилища правильно инициализирован и поддерживает метод `set()`.
     *          - Хранилище доступно для записи.
     *          Несоблюдение этих условий может привести к ошибкам записи данных.
     *
     * Пример вызова метода:
     * @code
     * $key = 'user_settings';
     * $checksum = 12345;
     * $data = ['theme' => 'dark', 'language' => 'en'];
     * if ($this->update_cache_storage($key, $checksum, $data)) {
     *     echo "Данные успешно записаны в хранилище.";
     * } else {
     *     echo "Ошибка записи данных в хранилище.";
     * }
     * @endcode
     */
    private function update_cache_storage(string $key, int|string $checksum, array $data): bool
    {
        // 1. Проверка, что клиент инициализирован и поддерживает метод set()
        if (!($this->client instanceof Redis || $this->client instanceof Memcached)) {
            throw new RuntimeException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Клиент хранилища не инициализирован или имеет неправильный тип"
            );
        }

        // 2. Кодирование данных
        $encoded_data = base64_encode(
            json_encode($data, JSON_THROW_ON_ERROR | JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES)
        );

        // 3. Запись контрольной суммы и данных в хранилище
        $checksum_key = $key . '_checksum';
        $data_key = $key . '_data';

        $checksum_set = $this->client->set($checksum_key, $checksum);
        $data_set = $this->client->set($data_key, $encoded_data);

        // 4. Возвращаем результат
        return $checksum_set && $data_set;
    }
}
