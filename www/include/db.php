<?php

/**
 * @file        include/db.php
 * @brief       Работа с базами данных через класс `Database` и интерфейс `Database_Interface`.
 *
 * @author      Dark Dayver
 * @version     0.4.0
 * @date        2025-04-02
 * @namespace   PhotoRigma\\Classes
 *
 * @details     Этот файл содержит реализацию класса `Database`, который предоставляет методы для работы с различными
 *              базами данных:
 *              - Выполнение SQL-запросов (SELECT, JOIN, INSERT, UPDATE, DELETE, TRUNCATE).
 *              - Обработка результатов запросов, включая вывод данных.
 *              - Управление соединением с базой данных.
 *              - Обработка ошибок через централизованную систему логирования и обработки ошибок.
 *
 * @see         PhotoRigma::Classes::Database_Interface Интерфейс для работы с базами данных.
 * @see         PhotoRigma::Classes::Database Класс для работы с базами данных.
 * @see         PhotoRigma::Include::log_in_file() Функция для логирования ошибок.
 * @see         index.php Файл, который подключает db.php.
 *
 * @note        Этот файл является частью системы PhotoRigma и обеспечивает взаимодействие приложения с базами данных.
 *
 * @todo        Добавить поддержку SQLite.
 *
 * @copyright   Copyright (c) 2008-2025 Dark Dayver. Все права защищены.
 * @license     MIT License (https://opensource.org/licenses/MIT)
 *              Разрешается использовать, копировать, изменять, объединять, публиковать, распространять,
 *              сублицензировать и/или продавать копии программного обеспечения, а также разрешать лицам, которым
 *              предоставляется данное программное обеспечение, делать это при соблюдении следующих условий:
 *              - Уведомление об авторских правах и условия лицензии должны быть включены во все копии или значимые
 *              части программного обеспечения.
 */

namespace PhotoRigma\Classes;

// Предотвращение прямого вызова файла
use Exception;
use InvalidArgumentException;
use PDO;
use PDOException;
use PDOStatement;

use function PhotoRigma\Include\log_in_file;

if (!defined('IN_GALLERY') || IN_GALLERY !== true) {
    error_log(
        date('H:i:s') . " [ERROR] | " . (filter_input(
            INPUT_SERVER,
            'REMOTE_ADDR',
            FILTER_VALIDATE_IP
        ) ?: 'UNKNOWN_IP') . " | " . __FILE__ . " | Попытка прямого вызова файла"
    );
    die("HACK!");
}

/**
 * @interface Database_Interface
 * @brief     Интерфейс Database_Interface определяет методы для работы с базой данных.
 *
 * @details   Интерфейс определяет контракт для работы с базами данных через PDO. Поддерживаемые СУБД: MySQL (MariaDB)
 *            и PostgreSQL. Реализованы операции SELECT, JOIN, UPDATE, INSERT, DELETE и TRUNCATE. Особенности
 *            реализации:
 *          - Выполнение запроса возвращает `true` при успешном выполнении или выбрасывает исключение в случае ошибки.
 *          - Результаты запросов извлекаются с помощью следующих методов:
 *            - `res_row`: Извлекает одну строку результата.
 *            - `res_arr`: Извлекает все строки результата как массив.
 *            - `get_affected_rows`: Возвращает количество строк, затронутых последним запросом.
 *            - `get_last_insert_id`: Возвращает ID последней вставленной строки.
 *
 * @callgraph
 *
 * @see       PhotoRigma::Classes::Database Класс, который реализует интерфейс.
 * @see       PhotoRigma::Include::log_in_file() Логирует ошибки.
 *
 * @note      Интерфейс поддерживает только MySQL (MariaDB) и PostgreSQL.
 *
 * @warning   Методы интерфейса изменили свою реализацию в отличие от предыдущей версии. Убедитесь, что вы изучили
 *            новую документацию по методам перед использованием.
 */
interface Database_Interface
{
    /**
     * @brief   Формирует SQL-запрос на выборку данных из таблицы, основываясь на полученных аргументах, и выполняет
     *          его.
     *
     * @details Метод выполняет следующие шаги:
     *          - Проверяет типы входных данных: `$select` (строка или массив), `$from_tbl` (строка), `$options`
     *          (массив).
     *          - Обрабатывает список полей для выборки (`$select`), преобразуя его в строку с именами полей.
     *          - Формирует базовый SQL-запрос.
     *          - Добавляет условия WHERE, GROUP BY, ORDER BY и LIMIT, если они указаны в параметре `$options`.
     *          - Выполняет сформированный запрос через метод `execute_query`.
     *
     * @callgraph
     *
     * @param string|array $select   Список полей для выборки. Может быть строкой (имя одного поля) или массивом
     *                               (список полей). Если передан массив, он преобразуется в строку с разделителем `,
     *                               `. Пример: "id", ["id", "name"].
     * @param string       $from_tbl Имя таблицы, из которой выбираются данные.
     *                               Должно быть строкой, содержащей только допустимые имена таблиц без специальных
     *                               символов.
     * @param array        $options  Массив опций для формирования запроса. Поддерживаемые ключи:
     *                               - where (string|array): Условие WHERE. Может быть строкой (например, "status = 1")
     *                               или ассоциативным массивом (например, ["id" => 1, "status" => "active"]).
     *                               - group (string): Группировка GROUP BY. Должна быть строкой с именами полей
     *                               (например, "category_id").
     *                               - order (string): Сортировка ORDER BY. Должна быть строкой с именами полей и
     *                               направлением (например, "created_at DESC").
     *                               - limit (int|string): Ограничение LIMIT. Может быть числом (например, 10) или
     *                               строкой с диапазоном (например, "0, 10").
     *                               - params (array): Параметры для подготовленного выражения. Ассоциативный массив
     *                               значений, используемых в запросе (например, [":id" => 1, ":status" => "active"]).
     *
     * @return bool Возвращает true, если запрос успешно выполнен (даже если результат пустой).
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                    - `$from_tbl` не является строкой.
     *                                    - `$options` не является массивом.
     *                                    - `$select` не является строкой или массивом.
     *
     * @warning Метод чувствителен к корректности входных данных. Неверные типы данных или некорректные значения могут
     *          привести к выбросу исключения. Ранее метод имел другую сигнатуру, где вместо выбрасывания исключений
     *          использовалась запись ошибок в свойство `$error`. Теперь метод выбрасывает исключение при ошибках.
     *          Старый способ вызова: select($select, $from_tbl, $where = FALSE, $order = FALSE, $group = FALSE, $limit
     *          = FALSE).
     *
     * Пример использования метода select():
     * @code
     * $db->select(['id', 'name'], 'users', [
     *     'where' => ['status' => 'active'],
     *     'group' => 'category_id',
     *     'order' => 'created_at DESC',
     *     'limit' => 10,
     * ]);
     * @endcode
     * @see     PhotoRigma::Classes::Database::select() Метод, который реализует в классе заявленную логику.
     *
     */
    public function select(string|array $select, string $from_tbl, array $options = []): bool;

    /**
     * @brief   Формирует SQL-запрос с использованием JOIN для выборки данных из нескольких таблиц, основываясь на
     *          полученных аргументах, и выполняет его.
     *
     * @details Метод выполняет следующие шаги:
     *          - Проверяет типы входных данных: `$select` (строка или массив), `$from_tbl` (строка), `$join` (массив),
     *          `$options` (массив).
     *          - Обрабатывает список полей для выборки (`$select`), преобразуя его в строку с именами полей.
     *          - Обрабатывает массив JOIN-операций (`$join`):
     *            - Для каждой операции проверяется наличие имени таблицы (`table`) и условия (`on`).
     *            - Если тип JOIN не указан, используется `INNER` по умолчанию.
     *          - Формирует базовый SQL-запрос с использованием JOIN-операций.
     *          - Добавляет условия WHERE, GROUP BY, ORDER BY и LIMIT, если они указаны в параметре `$options`.
     *          - Выполняет сформированный запрос через метод `execute_query`.
     *
     * @callgraph
     *
     * @param string|array $select       Список полей для выборки. Может быть строкой (имя одного поля) или массивом
     *                                   (список полей). Если передан массив, он преобразуется в строку с разделителем
     *                                   `, `. Пример: "id", ["id", "name"].
     * @param string       $from_tbl     Имя основной таблицы, из которой начинается выборка.
     *                                   Должно быть строкой, содержащей только допустимые имена таблиц без специальных
     *                                   символов.
     * @param array        $join         Массив описаний JOIN-операций. Каждый элемент массива должен содержать
     *                                   следующие ключи:
     *                                   - table (string): Имя таблицы для JOIN. Должно быть строкой, содержащей только
     *                                   допустимые имена таблиц.
     *                                   - type (string, optional): Тип JOIN (например, INNER, LEFT, RIGHT). Если тип
     *                                   не указан, используется INNER по умолчанию.
     *                                   - on (string): Условие для JOIN. Должно быть строкой с допустимым условием
     *                                   сравнения полей. Если условие отсутствует, выбрасывается исключение. Пример:
     *                                   [['type' => 'INNER', 'table' => 'orders', 'on' => 'users.id =
     *                                   orders.user_id']].
     * @param array        $options      Массив опций для формирования запроса. Поддерживаемые ключи:
     *                                   - where (string|array): Условие WHERE. Может быть строкой (например, "status =
     *                                   1") или ассоциативным массивом (например, ["id" => 1, "status" => "active"]).
     *                                   - group (string): Группировка GROUP BY. Должна быть строкой с именами полей
     *                                   (например, "category_id").
     *                                   - order (string): Сортировка ORDER BY. Должна быть строкой с именами полей и
     *                                   направлением (например, "created_at DESC").
     *                                   - limit (int|string): Ограничение LIMIT. Может быть числом (например, 10) или
     *                                   строкой с диапазоном (например, "0, 10").
     *                                   - params (array): Параметры для подготовленного выражения. Ассоциативный
     *                                   массив значений, используемых в запросе (например, [":id" => 1, ":status" =>
     *                                   "active"]).
     *
     * @return bool Возвращает true, если запрос успешно выполнен (даже если результат пустой).
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                    - `$from_tbl` не является строкой.
     *                                    - `$join` не является массивом.
     *                                    - `$select` не является строкой или массивом.
     *                                    - Отсутствует имя таблицы (`table`) или условие (`on`) в описании JOIN.
     *
     * @warning Метод чувствителен к корректности входных данных. Неверные типы данных или некорректные значения могут
     *          привести к выбросу исключения. Это новый метод, ранее недоступный.
     *
     * Пример использования метода join():
     * @code
     * $db->join(
     *     ['users.id', 'users.name', 'orders.order_date'],
     *     'users',
     *     [
     *         ['type' => 'INNER', 'table' => 'orders', 'on' => 'users.id = orders.user_id'],
     *     ],
     *     [
     *         'where' => ['users.status' => 1],
     *     ]
     * );
     * @endcode
     * @see     PhotoRigma::Classes::Database::join() Метод, который реализует в классе заявленную логику.
     *
     */
    public function join(string|array $select, string $from_tbl, array $join, array $options = []): bool;

    /**
     * @brief   Формирует SQL-запрос на удаление данных из таблицы, основываясь на полученных аргументах, и выполняет
     *          его.
     *
     * @details Метод выполняет следующие шаги:
     *          - Проверяет типы входных данных: `$from_tbl` (строка), `$options` (массив).
     *          - Проверяет наличие обязательного условия `where` в массиве `$options`. Если условие отсутствует,
     *          выбрасывается исключение для предотвращения случайного удаления всех данных.
     *          - Проверяет и удаляет недопустимые ключи из массива `$options`:
     *            - Ключ `group` не поддерживается в запросах DELETE и удаляется с записью в лог.
     *            - Ключи `order` и `limit` должны использоваться совместно. Если указан только один из них, оба
     *            удаляются с записью в лог.
     *          - Формирует базовый SQL-запрос на удаление данных.
     *          - Добавляет условия WHERE, ORDER BY и LIMIT (если они корректны) через метод `build_conditions`.
     *          - Выполняет сформированный запрос через метод `execute_query`.
     *
     * @callgraph
     *
     * @param string $from_tbl      Имя таблицы, из которой необходимо удалить данные.
     *                              Должно быть строкой, содержащей только допустимые имена таблиц без специальных
     *                              символов.
     * @param array  $options       Массив опций для формирования запроса. Поддерживаемые ключи:
     *                              - where (string|array): Условие WHERE. Может быть строкой (например, "status = 1")
     *                              или ассоциативным массивом (например, ["id" => 1, "status" => "active"]).
     *                              Обязательный параметр для безопасности. Без условия WHERE запрос не будет выполнен.
     *                              - order (string): Сортировка ORDER BY. Должна быть строкой с именами полей и
     *                              направлением (например, "created_at DESC"). Может использоваться только вместе с
     *                              `limit`. Если указан только один из этих ключей, оба игнорируются.
     *                              - limit (int|string): Ограничение LIMIT. Может быть числом (например, 10) или
     *                              строкой с диапазоном (например, "0, 10"). Может использоваться только вместе с
     *                              `order`. Если указан только один из этих ключей, оба игнорируются.
     *                              - params (array): Параметры для подготовленного выражения. Ассоциативный массив
     *                              значений, используемых в запросе (например, [":id" => 1, ":status" => "active"]).
     *                              - group (string): Группировка GROUP BY. Не поддерживается в запросах DELETE и
     *                              удаляется с записью в лог.
     *
     * @return bool Возвращает true, если запрос успешно выполнен (даже если результат пустой).
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                    - `$from_tbl` не является строкой.
     *                                    - `$options` не является массивом.
     *                                    - Отсутствует обязательное условие `where` в массиве `$options`.
     *
     * @warning Метод чувствителен к корректности входных данных. Неверные типы данных или некорректные значения могут
     *          привести к выбросу исключения. Безопасность обеспечивается обязательным указанием условия `where`.
     *          Запрос без условия `where` не будет выполнен. Ключи `group`, `order` и `limit` проверяются на
     *          корректность. Недопустимые ключи удаляются с записью в лог. Ранее метод имел другую сигнатуру, где
     *          вместо выбрасывания исключений использовалась запись ошибок в свойство `$error`. Теперь метод
     *          выбрасывает исключение при ошибках. Старый способ вызова: delete($from_tbl, $where = FALSE, $order =
     *          FALSE, $limit = FALSE).
     *
     * Пример использования метода delete():
     * @code
     * $db->delete('users', [
     *     'where' => ['id' => 1],
     * ]);
     * @endcode
     * @see     PhotoRigma::Classes::Database::delete() Метод, который реализует в классе заявленную логику.
     * @see     PhotoRigma::Include::log_in_file() Функция для логирования ошибок.
     *
     */
    public function delete(string $from_tbl, array $options = []): bool;

    /**
     * @brief   Формирует SQL-запрос на очистку таблицы (TRUNCATE), размещает его в свойстве `$txt_query` и выполняет.
     *
     * @details Метод выполняет следующие шаги:
     *          - Проверяет тип входных данных: `$from_tbl` должен быть строкой. Если передан неверный тип,
     *          выбрасывается исключение.
     *          - Формирует базовый SQL-запрос TRUNCATE TABLE.
     *          - Выполняет сформированный запрос через метод `execute_query`.
     *
     * @callgraph
     *
     * @param string $from_tbl Имя таблицы, которую необходимо очистить.
     *                         Должно быть строкой, содержащей только допустимые имена таблиц без специальных символов.
     *
     * @return bool Возвращает true, если запрос успешно выполнен (даже если результат пустой).
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                    - `$from_tbl` не является строкой.
     *
     * @warning Метод чувствителен к корректности входных данных. Неверные типы данных или некорректные значения могут
     *          привести к выбросу исключения. Запрос TRUNCATE полностью очищает таблицу, удаляя все строки без
     *          возможности восстановления. Используйте этот метод с осторожностью. Ранее метод возвращал `false` и
     *          записывал ошибку в свойство `$error`, теперь выбрасывает исключение через `throw`.
     *
     * Пример использования метода truncate():
     * @code
     * $db->truncate('users');
     * @endcode
     * @see     PhotoRigma::Classes::Database::truncate() Метод, который реализует в классе заявленную логику.
     *
     */
    public function truncate(string $from_tbl): bool;

    /**
     * @brief   Формирует SQL-запрос на обновление данных в таблице, основываясь на полученных аргументах, и выполняет
     *          его.
     *
     * @details Метод выполняет следующие шаги:
     *          - Проверяет типы входных данных: `$update` (ассоциативный массив), `$from_tbl` (строка), `$options`
     *          (массив).
     *          - Проверяет наличие обязательного условия `where` в массиве `$options`. Если условие отсутствует,
     *          выбрасывается исключение для предотвращения случайного обновления всех данных.
     *          - Удаляет недопустимый ключ `group` из массива `$options` с записью в лог, так как GROUP BY не
     *          поддерживается в запросах UPDATE.
     *          - Формирует базовый SQL-запрос UPDATE с использованием преобразованных данных.
     *          - Добавляет условия WHERE, ORDER BY и LIMIT, если они указаны в параметре `$options`.
     *          - Выполняет сформированный запрос через метод `execute_query`.
     *
     * @callgraph
     *
     * @param array  $update        Ассоциативный массив данных для обновления в формате: 'имя_поля' => 'значение'.
     * @param string $from_tbl      Имя таблицы, в которой необходимо обновить данные.
     *                              Должно быть строкой, содержащей только допустимые имена таблиц без специальных
     *                              символов.
     * @param array  $options       Массив опций для формирования запроса. Поддерживаемые ключи:
     *                              - where (string|array): Условие WHERE. Может быть строкой (например, "status = 1")
     *                              или ассоциативным массивом (например, ["id" => 1, "status" => "active"]).
     *                              Обязательный параметр для безопасности. Без условия WHERE запрос не будет выполнен.
     *                              - order (string): Сортировка ORDER BY. Должна быть строкой с именами полей и
     *                              направлением (например, "created_at DESC").
     *                              - limit (int|string): Ограничение LIMIT. Может быть числом (например, 10) или
     *                              строкой с диапазоном (например, "0, 10").
     *                              - params (array): Параметры для подготовленного выражения. Ассоциативный массив
     *                              значений, используемых в запросе (например, [":id" => 1, ":status" => "active"]).
     *                              - group (string): Группировка GROUP BY. Не поддерживается в запросах UPDATE и
     *                              удаляется с записью в лог.
     *
     * @return bool Возвращает true, если запрос успешно выполнен (даже если результат пустой).
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                    - `$update` не является массивом.
     *                                    - `$from_tbl` не является строкой.
     *                                    - `$options` не является массивом.
     *                                    - Отсутствует обязательное условие `where` в массиве `$options`.
     *
     * @warning Метод чувствителен к корректности входных данных. Неверные типы данных или некорректные значения могут
     *          привести к выбросу исключения. Безопасность обеспечивается обязательным указанием условия `where`.
     *          Запрос без условия `where` не будет выполнен. Ключ `group` не поддерживается в запросах UPDATE и
     *          удаляется с записью в лог. Ранее метод имел другую сигнатуру, где вместо выбрасывания исключений
     *          использовалась запись ошибок в свойство `$error`. Теперь метод выбрасывает исключение при ошибках.
     *          Старый способ вызова: update($update, $to_tbl, $where = FALSE, $order = FALSE, $limit = FALSE).
     *
     * Пример использования метода update():
     * @code
     * $db->update(['name' => 'John Doe'], 'users', [
     *     'where' => ['id' => 1],
     * ]);
     * @endcode
     * @see     PhotoRigma::Include::log_in_file() Функция для логирования ошибок.
     *
     * @see     PhotoRigma::Classes::Database::update() Метод, который реализует в классе заявленную логику.
     */
    public function update(array $update, string $from_tbl, array $options = []): bool;

    /**
     * @brief   Формирует SQL-запрос на вставку данных в таблицу, основываясь на полученных аргументах, и выполняет
     *          его.
     *
     * @details Метод выполняет следующие шаги:
     *          - Проверяет типы входных данных: `$insert` (ассоциативный массив), `$to_tbl` (строка), `$type`
     *          (строка), `$options` (массив).
     *          - Проверяет, что массив `$insert` не пустой. Если массив пустой, выбрасывается исключение.
     *          - Нормализует параметр `$type`, приводя его к нижнему регистру, и проверяет на допустимые значения:
     *          `'ignore'`, `'replace'`, `'into'`, `''`. Если указан недопустимый тип, выбрасывается исключение.
     *          - Определяет тип запроса на основе параметра `$type`:
     *            - `'ignore'`: Формирует запрос типа "INSERT IGNORE INTO".
     *            - `'replace'`: Формирует запрос типа "REPLACE INTO".
     *            - `'into'` или пустая строка (`''`): Формирует запрос типа "INSERT INTO" (по умолчанию).
     *          - Формирует базовый SQL-запрос INSERT с использованием преобразованных данных.
     *          - Выполняет сформированный запрос через метод `execute_query`.
     *
     * @callgraph
     *
     * @param array  $insert  Ассоциативный массив данных для вставки в формате: 'имя_поля' => 'значение'.
     *                        Если передан пустой массив, выбрасывается исключение.
     * @param string $to_tbl  Имя таблицы, в которую необходимо вставить данные.
     *                        Должно быть строкой, содержащей только допустимые имена таблиц без специальных символов.
     * @param string $type    Тип запроса (необязательно). Определяет тип SQL-запроса на вставку. Допустимые значения:
     *                        - 'ignore': Формирует запрос типа "INSERT IGNORE INTO".
     *                        - 'replace': Формирует запрос типа "REPLACE INTO".
     *                        - 'into': Формирует запрос типа "INSERT INTO" (явное указание).
     *                        - '' (пустая строка): Формирует запрос типа "INSERT INTO" (по умолчанию).
     *                        Если указан недопустимый тип, выбрасывается исключение.
     * @param array  $options Массив опций для формирования запроса. Поддерживаемые ключи:
     *                        - params (array): Параметры для подготовленного выражения. Ассоциативный массив значений,
     *                        используемых в запросе (например, [":name" => "John Doe", ":email" =>
     *                        "john@example.com"]).
     *
     * @return bool Возвращает true, если запрос успешно выполнен (даже если результат пустой).
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                    - `$insert` не является массивом или является пустым массивом.
     *                                    - `$to_tbl` не является строкой.
     *                                    - `$type` содержит недопустимое значение (не '', 'ignore', 'replace',
     *                                    'into').
     *                                    - `$options` не является массивом.
     *
     * @warning Метод чувствителен к корректности входных данных. Неверные типы данных или некорректные значения могут
     *          привести к выбросу исключения. Убедитесь, что массив `$insert` не пустой и содержит корректные данные.
     *          Параметр `$type` должен быть одним из допустимых значений: '', 'ignore', 'replace', 'into'. Ранее метод
     *          имел другую сигнатуру, где вместо выбрасывания исключений использовалась запись ошибок в свойство
     *          `$error`. Теперь метод выбрасывает исключение при ошибках. Старый способ вызова: insert($insert,
     *          $to_tbl, $type = FALSE).
     *
     * Пример использования метода insert():
     * @code
     * $db->insert(['name' => 'John Doe', 'email' => 'john@example.com'], 'users');
     * @endcode
     * @see     PhotoRigma::Classes::Database::insert() Метод, который реализует в классе заявленную логику.
     *
     */
    public function insert(array $insert, string $to_tbl, string $type = '', array $options = []): bool;

    /**
     * @brief   Извлекает одну строку результата из подготовленного выражения, хранящегося в свойстве `$res_query`.
     *
     * @details Метод выполняет следующие шаги:
     *          - Проверяет, что свойство `$res_query` установлено и является объектом типа `\PDOStatement`. Если это
     *          не так, выбрасывается исключение.
     *          - Использует метод `fetch(\PDO::FETCH_ASSOC)` для извлечения одной строки результата в виде
     *          ассоциативного массива.
     *          - Если результатов нет (метод `fetch` возвращает `false`), явно возвращает `false`.
     *          - В противном случае возвращает ассоциативный массив, содержащий данные строки.
     *
     * @callgraph
     *
     * @return array|false Возвращает ассоциативный массив, содержащий данные одной строки результата, если они
     *                     доступны. Если результатов нет, возвращает `false`.
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                    - Свойство `$res_query` не установлено.
     *                                    - Свойство `$res_query` не является объектом типа `\PDOStatement`.
     *
     * @warning Метод чувствителен к состоянию свойства `$res_query`. Убедитесь, что перед вызовом метода был выполнен
     *          запрос, который установил значение `$res_query` как объект `\PDOStatement`. Ранее метод мог работать с
     *          устаревшим способом обработки результатов. Теперь он требует корректной инициализации `$res_query`
     *          через выполнение запроса.
     *
     * Пример использования метода res_row():
     * @code
     * $db->select(['id', 'name'], 'users', ['where' => 'status = 1']);
     * while ($row = $db->res_row()) {
     *     echo "ID: " . $row['id'] . ", Name: " . $row['name'] . "\n";
     * }
     * @endcode
     * @see     PhotoRigma::Classes::Database::res_row() Метод, который реализует в классе заявленную логику.
     *
     */
    public function res_row(): array|false;

    /**
     * @brief   Извлекает все строки результата из подготовленного выражения, хранящегося в свойстве `$res_query`, и
     *          возвращает их как массив.
     *
     * @details Метод выполняет следующие шаги:
     *          - Проверяет, что свойство `$res_query` установлено и является объектом типа `\PDOStatement`. Если это
     *          не так, выбрасывается исключение.
     *          - Использует метод `fetchAll(\PDO::FETCH_ASSOC)` для извлечения всех строк результата в виде массива
     *          ассоциативных массивов.
     *          - Если результатов нет (метод `fetchAll` возвращает пустой массив), явно возвращает `false`.
     *          - В противном случае возвращает массив, содержащий все строки результата.
     *
     * @callgraph
     *
     * @return array|false Возвращает массив ассоциативных массивов, содержащих данные всех строк результата, если они
     *                     доступны. Если результатов нет, возвращает `false`.
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                    - Свойство `$res_query` не установлено.
     *                                    - Свойство `$res_query` не является объектом типа `\PDOStatement`.
     *
     * @warning Метод чувствителен к состоянию свойства `$res_query`. Убедитесь, что перед вызовом метода был выполнен
     *          запрос, который установил значение `$res_query` как объект `\PDOStatement`. Ранее метод мог работать с
     *          устаревшим способом обработки результатов. Теперь он требует корректной инициализации `$res_query`
     *          через выполнение запроса.
     *
     * Пример использования метода res_arr():
     * @code
     * $db->select(['id', 'name'], 'users', ['where' => 'status = 1']);
     * $results = $db->res_arr();
     * if ($results) {
     *     foreach ($results as $row) {
     *         echo "ID: " . $row['id'] . ", Name: " . $row['name'] . "\n";
     *     }
     * } else {
     *     echo "No results found.";
     * }
     * @endcode
     * @see     PhotoRigma::Classes::Database::res_arr() Метод, который реализует в классе заявленную логику.
     *
     */
    public function res_arr(): array|false;

    /**
     * @brief   Возвращает количество строк, затронутых последним запросом.
     *
     * @details Метод выполняет следующие шаги:
     *          - Проверяет, что свойство `$aff_rows` установлено. Если это не так, выбрасывается исключение.
     *          - Проверяет, что значение свойства `$aff_rows` является целым числом. Если это не так, выбрасывается
     *          исключение.
     *          - Возвращает значение свойства `$aff_rows`, которое представляет собой количество строк, затронутых
     *          последним SQL-запросом.
     *
     * @callgraph
     *
     * @return int Количество строк, затронутых последним SQL-запросом.
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                    - Свойство `$aff_rows` не установлено.
     *                                    - Значение свойства `$aff_rows` не является целым числом.
     *
     * @warning Метод чувствителен к состоянию свойства `$aff_rows`. Убедитесь, что перед вызовом метода был выполнен
     *          запрос, который установил значение `$aff_rows` как целое число. Ранее был прямой доступ к свойству
     *          `$aff_rows`. Теперь используется метод для получения значения, чтобы обеспечить безопасность и контроль
     *          данных.
     *
     * Пример использования метода get_affected_rows():
     * @code
     * $db->delete('users', ['where' => 'status = 0']);
     * echo "Affected rows: " . $db->get_affected_rows();
     * @endcode
     * @see     PhotoRigma::Classes::Database::get_affected_rows() Метод, который реализует в классе заявленную логику.
     *
     */
    public function get_affected_rows(): int;

    /**
     * @brief   Возвращает ID последней вставленной строки.
     *
     * @details Метод выполняет следующие шаги:
     *          - Проверяет, что свойство `$insert_id` установлено. Если это не так, выбрасывается исключение.
     *          - Проверяет, что значение свойства `$insert_id` является целым числом. Если это не так, выбрасывается
     *          исключение.
     *          - Возвращает значение свойства `$insert_id`, которое представляет собой ID последней вставленной
     *          строки.
     *
     * @callgraph
     *
     * @return int ID последней вставленной строки.
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                    - Свойство `$insert_id` не установлено.
     *                                    - Значение свойства `$insert_id` не является целым числом.
     *
     * @warning Метод чувствителен к состоянию свойства `$insert_id`. Убедитесь, что перед вызовом метода был выполнен
     *          запрос, который установил значение `$insert_id` как целое число. Ранее был прямой доступ к свойству
     *          `$insert_id`. Теперь используется метод для получения значения, чтобы обеспечить безопасность и
     *          контроль данных.
     *
     * Пример использования метода get_last_insert_id():
     * @code
     * $db->insert(['name' => 'John Doe', 'email' => 'john@example.com'], 'users');
     * echo "Last insert ID: " . $db->get_last_insert_id();
     * @endcode
     * @see     PhotoRigma::Classes::Database::get_last_insert_id() Метод, который реализует в классе заявленную
     *          логику.
     *
     */
    public function get_last_insert_id(): int;

    /**
     * @brief   Форматирует дату в зависимости от типа СУБД.
     *
     * @details Этот метод является частью контракта, который должны реализовать классы, использующие интерфейс.
     *          Метод должен формировать SQL-выражение для форматирования даты в зависимости от типа используемой СУБД.
     *          Основные требования к реализации:
     *          - Проверка типа СУБД.
     *          - Поддержка форматирования для MariaDB (MySQL), PostgreSQL и SQLite.
     *          - Генерация исключения, если тип СУБД не поддерживается.
     *          Метод предназначен для использования вне класса (например, через публичный метод-редирект).
     *
     * @callgraph
     *
     * @param string $column Название столбца с датой.
     *                       Должен быть непустой строкой в формате имени столбца таблицы в БД.
     * @param string $format Формат даты (в стиле MariaDB).
     *                       Должен соответствовать формату MariaDB.
     *
     * @return string SQL-выражение для форматирования даты.
     *
     * @throws InvalidArgumentException Выбрасывается, если тип СУБД не поддерживается.
     *
     * @note    Метод использует функции форматирования даты, специфичные для каждой СУБД.
     * @warning Убедитесь, что `$column` и `$format` содержат корректные значения перед вызовом метода.
     *
     * Пример вызова метода:
     * @code
     * $object = new \PhotoRigma\Classes\Database();
     * $result = $object->format_date('created_at', '%Y-%m-%d');
     * echo $result;
     * // Результат для MySQL: DATE_FORMAT(created_at, '%Y-%m-%d')
     * @endcode
     * @see     PhotoRigma::Classes::Database::format_date() Пример реализации метода в классе.
     *
     */
    public function format_date(string $column, string $format): string;
}

/**
 * @class   Database
 * @brief   Класс Database реализует интерфейс Database_Interface и отвечает за работу с различными базами данных.
 *
 * @details Класс реализует все методы интерфейса `Database_Interface` и предоставляет функционал для работы с базами
 *          данных через PDO. Поддерживаемые СУБД: MySQL (MariaDB) и PostgreSQL. Реализованы операции SELECT, JOIN,
 *          UPDATE, INSERT, DELETE и TRUNCATE. Особенности класса:
 *          - Выполнение запроса возвращает `true` при успешном выполнении или выбрасывает исключение в случае ошибки.
 *          - Результаты запросов извлекаются с помощью следующих методов:
 *            - `res_row`: Извлекает одну строку результата.
 *            - `res_arr`: Извлекает все строки результата как массив.
 *            - `get_affected_rows`: Возвращает количество строк, затронутых последним запросом.
 *            - `get_last_insert_id`: Возвращает ID последней вставленной строки.
 *
 * @implements Database_Interface
 *
 * @see     PhotoRigma::Classes::Database_Interface Интерфейс, который реализует класс.
 * @see     PhotoRigma::Include::log_in_file() Логирует ошибки.
 *
 * Пример создания объекта класса Database:
 * @code
 * $config = [
 *     'driver' => 'mysql',
 *     'host' => 'localhost',
 *     'dbname' => 'test_db',
 *     'user' => 'root',
 *     'password' => 'password',
 * ];
 * $db = new \\PhotoRigma\\Classes\\Database($config);
 * @endcode
 */
class Database implements Database_Interface
{
    // Свойства класса
    private ?PDO $pdo = null;          ///< Объект PDO для подключения к базе данных
    private string|null $txt_query = null;    ///< Текст последнего SQL-запроса, сформированного методами класса
    private object|null $res_query = null;    ///< Результат выполнения подготовленного выражения (PDOStatement)
    private int $aff_rows = 0;        ///< Количество строк, затронутых последним запросом (INSERT, UPDATE, DELETE)
    private int $insert_id = 0;       ///< ID последней вставленной строки после выполнения INSERT-запроса
    private string $db_type;     ///< Тип базы данных (mysql, pgsql)
    private array $format_cache = []; ///< Кэш для преобразования форматов даты (MariaDB -> PostgreSQL/SQLite)
    private array $query_cache = []; ///< Кэш для хранения результатов проверки существования запросов

    /**
     * @brief   Конструктор класса.
     *
     * @details Этот метод вызывается автоматически при создании нового объекта класса.
     *          Используется для установки соединения с базой данных на основе переданных параметров.
     *          Подключение выполняется в следующем порядке:
     *          1. Через сокет (если указан параметр 'dbsock').
     *          2. Через хост и порт (если подключение через сокет не удалось или не используется).
     *          При возникновении ошибок валидации или подключения выбрасывается исключение.
     *
     *          Важно: Если параметр 'dbsock' указан, но файл сокета не существует, записывается предупреждение в лог,
     *          и выполняется попытка подключения через хост и порт.
     *
     * @callgraph
     *
     * @param array $db_config Массив с конфигурацией подключения:
     *                         - dbtype (string): Тип базы данных (mysql, pgsql). Обязательный параметр.
     *                         Если передан недопустимый тип, выбрасывается исключение InvalidArgumentException.
     *                         - dbsock (string): Путь к сокету (опционально).
     *                         Если путь некорректен или файл не существует, записывается предупреждение в лог.
     *                         Если подключение через сокет не удалось, выполняется попытка подключения через хост и
     *                         порт.
     *                         - dbname (string): Имя базы данных. Обязательный параметр.
     *                         Если имя не указано, выбрасывается исключение InvalidArgumentException.
     *                         - dbuser (string): Имя пользователя. Обязательный параметр.
     *                         Если имя не указано, выбрасывается исключение InvalidArgumentException.
     *                         - dbpass (string): Пароль пользователя. Обязательный параметр.
     *                         - dbhost (string): Хост базы данных. Обязательный параметр, если не используется сокет.
     *                         Если хост некорректен, выбрасывается исключение InvalidArgumentException.
     *                         - dbport (int): Порт базы данных (опционально).
     *                         Если порт некорректен, выбрасывается исключение InvalidArgumentException.
     *
     * @throws InvalidArgumentException Если параметры конфигурации неверны.
     * @throws PDOException|Exception Если произошла ошибка при подключении к базе данных.
     *
     * @warning Если параметр 'dbsock' указан, но файл сокета не существует, выполняется попытка подключения через хост
     *          и порт.
     *
     * @see     PhotoRigma::Classes::Database::$pdo Свойство, хранящее объект PDO для подключения к базе данных.
     *
     * @see     PhotoRigma::Include::log_in_file() Логирует ошибки.
     *
     * Пример использования конструктора:
     * @code
     * $db_config = [
     *     'dbtype' => 'mysql',
     *     'dbname' => 'test_db',
     *     'dbuser' => 'root',
     *     'dbpass' => 'password',
     *     'dbhost' => 'localhost',
     *     'dbport' => 3306,
     * ];
     * $db = new \PhotoRigma\Classes\Database($db_config);
     * @endcode
     */
    public function __construct(array $db_config)
    {
        // Проверка допустимых значений dbtype
        $allowed_dbtypes = ['mysql', 'pgsql'];
        if (!in_array($db_config['dbtype'], $allowed_dbtypes, true)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Недопустимый тип базы данных | Значение: {$db_config['dbtype']}"
            );
        }
        // Сохраняем тип используемой базы данных
        $this->db_type = $db_config['dbtype'];
        // Проверка корректности dbname и dbuser
        if (empty($db_config['dbname']) || empty($db_config['dbuser'])) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Не указано имя базы данных или пользователь | Конфигурация: " . json_encode(
                    $db_config,
                    JSON_THROW_ON_ERROR | JSON_UNESCAPED_UNICODE | JSON_PRETTY_PRINT
                )
            );
        }
        // Проверка dbsock (первая попытка подключения через сокет)
        if (!empty($db_config['dbsock'])) {
            if (!is_string($db_config['dbsock']) || !file_exists($db_config['dbsock'])) {
                log_in_file(
                    __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректный или несуществующий путь к сокету | Путь: {$db_config['dbsock']}"
                );
            } else {
                try {
                    $dsn = "{$db_config['dbtype']}:unix_socket={$db_config['dbsock']};dbname={$db_config['dbname']};charset=utf8mb4";
                    $this->pdo = new PDO($dsn, $db_config['dbuser'], $db_config['dbpass'], [
                        PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,
                        PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
                        PDO::ATTR_EMULATE_PREPARES   => false,
                        PDO::ATTR_STRINGIFY_FETCHES  => false,
                    ]);
                    return; // Подключение успешно, завершаем выполнение метода
                } catch (PDOException $e) {
                    log_in_file(
                        __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Ошибка подключения через сокет | Сокет: {$db_config['dbsock']} | Сообщение: " . $e->getMessage(
                        )
                    );
                    // Переходим к следующему варианту подключения
                }
            }
        }
        // Проверка dbhost и dbport (вторая попытка подключения через хост и порт)
        if (empty($db_config['dbhost'])) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Не указан хост базы данных | Конфигурация: " . json_encode(
                    $db_config,
                    JSON_THROW_ON_ERROR | JSON_UNESCAPED_UNICODE | JSON_PRETTY_PRINT
                )
            );
        }
        if (!filter_var($db_config['dbhost'], FILTER_VALIDATE_IP) && !preg_match(
            '/^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/',
            $db_config['dbhost']
        ) && strtolower($db_config['dbhost']) !== 'localhost') {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректный хост базы данных | Значение: {$db_config['dbhost']}"
            );
        }
        $dsn = "{$db_config['dbtype']}:host={$db_config['dbhost']};dbname={$db_config['dbname']};charset=utf8mb4";
        if (!empty($db_config['dbport'])) {
            if (!is_numeric($db_config['dbport']) || $db_config['dbport'] < 1 || $db_config['dbport'] > 65535) {
                throw new InvalidArgumentException(
                    __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректный порт базы данных | Значение: {$db_config['dbport']}"
                );
            }
            $dsn .= ";port={$db_config['dbport']}";
        }
        try {
            $this->pdo = new PDO($dsn, $db_config['dbuser'], $db_config['dbpass'], [
                PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,
                PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
                PDO::ATTR_EMULATE_PREPARES   => false,
                PDO::ATTR_STRINGIFY_FETCHES  => false,
            ]);
        } catch (PDOException $e) {
            throw new PDOException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Ошибка подключения через хост и порт | Хост: {$db_config['dbhost']}, Порт: {$db_config['dbport']} | Сообщение: " . $e->getMessage(
                )
            );
        }
    }

    /**
     * @brief   Формирует SQL-запрос на удаление данных из таблицы, основываясь на полученных аргументах, размещает его
     *          в свойстве `$txt_query` и выполняет.
     *
     * @details Метод является публичным редиректом для защищённого метода `_delete_internal()`, который реализует
     *          основную логику формирования и выполнения SQL-запроса на удаление данных. Все параметры передаются
     *          напрямую в защищённый метод без дополнительных проверок или преобразований. Безопасность обеспечивается
     *          обязательным указанием условия `where`. Запрос без условия `where` не будет выполнен. Редиректов из
     *          внешних классов нет.
     *
     * @callgraph
     *
     * @param string $from_tbl      Имя таблицы, из которой необходимо удалить данные.
     *                              Должно быть строкой, содержащей только допустимые имена таблиц без специальных
     *                              символов.
     * @param array  $options       Массив опций для формирования запроса. Поддерживаемые ключи:
     *                              - where (string|array): Условие WHERE. Может быть строкой (например, "status = 1")
     *                              или ассоциативным массивом (например, ["id" => 1, "status" => "active"]).
     *                              Обязательный параметр для безопасности. Без условия WHERE запрос не будет выполнен.
     *                              - order (string): Сортировка ORDER BY. Должна быть строкой с именами полей и
     *                              направлением (например, "created_at DESC"). Может использоваться только вместе с
     *                              `limit`. Если указан только один из этих ключей, оба игнорируются.
     *                              - limit (int|string): Ограничение LIMIT. Может быть числом (например, 10) или
     *                              строкой с диапазоном (например, "0, 10"). Может использоваться только вместе с
     *                              `order`. Если указан только один из этих ключей, оба игнорируются.
     *                              - params (array): Параметры для подготовленного выражения. Ассоциативный массив
     *                              значений, используемых в запросе (например, [":id" => 1, ":status" => "active"]).
     *                              - group (string): Группировка GROUP BY. Не поддерживается в запросах DELETE и
     *                              удаляется с записью в лог.
     *
     * @return bool Возвращает true, если запрос успешно выполнен (даже если результат пустой).
     *
     * @throws InvalidArgumentException|Exception Выбрасывается, если:
     *                                    - `$from_tbl` не является строкой.
     *                                    - `$options` не является массивом.
     *                                    - Отсутствует обязательное условие `where` в массиве `$options`.
     *
     * @warning Метод чувствителен к корректности входных данных. Неверные типы данных или некорректные значения могут
     *          привести к выбросу исключения. Безопасность обеспечивается обязательным указанием условия `where`.
     *          Запрос без условия `where` не будет выполнен. Ключи `group`, `order` и `limit` проверяются на
     *          корректность. Недопустимые ключи удаляются с записью в лог.
     *
     * Пример использования метода delete():
     * @code
     * $db = new \\PhotoRigma\\Classes\\Database();
     * $db->delete('users', [
     *     'where' => ['id' => 1],
     * ]);
     * @endcode
     * @see     PhotoRigma::Classes::Database::_delete_internal() Защищённый метод, реализующий основную логику.
     * @see     PhotoRigma::Classes::Database::execute_query() Выполняет SQL-запрос.
     * @see     PhotoRigma::Classes::Database::build_conditions() Формирует условия WHERE, ORDER BY и LIMIT для
     *          запроса.
     * @see     PhotoRigma::Classes::Database::$txt_query Свойство, в которое помещается текст SQL-запроса.
     * @see     PhotoRigma::Include::log_in_file() Функция для логирования ошибок.
     *
     */
    public function delete(string $from_tbl, array $options = []): bool
    {
        return $this->_delete_internal($from_tbl, $options);
    }

    /**
     * @brief   Формирует SQL-запрос на удаление данных из таблицы, основываясь на полученных аргументах, размещает его
     *          в свойстве `$txt_query` и выполняет.
     *
     * @details Метод выполняет следующие шаги:
     * - Проверяет типы входных данных: `$from_tbl` (строка), `$options` (массив).
     * - Проверяет наличие обязательного условия `where` в массиве `$options`. Если условие отсутствует, выбрасывается
     * исключение для предотвращения случайного удаления всех данных.
     * - Проверяет и удаляет недопустимые ключи из массива `$options`:
     *   - Ключ `group` не поддерживается в запросах DELETE и удаляется с записью в лог.
     *   - Ключи `order` и `limit` должны использоваться совместно. Если указан только один из них, оба удаляются с
     *   записью в лог.
     * - Формирует базовый SQL-запрос на удаление данных.
     * - Добавляет условия WHERE, ORDER BY и LIMIT (если они корректны) через метод `build_conditions`.
     * - Выполняет сформированный запрос через метод `execute_query`.
     *
     * Метод является защищенным и предназначен для использования внутри класса или его наследников. Основная логика
     * вызывается через публичный метод-редирект `delete()`.
     *
     * @callergraph
     * @callgraph
     *
     * @param string $from_tbl      Имя таблицы, из которой необходимо удалить данные.
     *                              Должно быть строкой, содержащей только допустимые имена таблиц без специальных
     *                              символов.
     * @param array  $options       Массив опций для формирования запроса. Поддерживаемые ключи:
     *                              - where (string|array): Условие WHERE. Может быть строкой (например, "status = 1")
     *                              или ассоциативным массивом (например, ["id" => 1, "status" => "active"]).
     *                              Обязательный параметр для безопасности. Без условия WHERE запрос не будет выполнен.
     *                              - order (string): Сортировка ORDER BY. Должна быть строкой с именами полей и
     *                              направлением (например, "created_at DESC"). Может использоваться только вместе с
     *                              `limit`. Если указан только один из этих ключей, оба игнорируются.
     *                              - limit (int|string): Ограничение LIMIT. Может быть числом (например, 10) или
     *                              строкой с диапазоном (например, "0, 10"). Может использоваться только вместе с
     *                              `order`. Если указан только один из этих ключей, оба игнорируются.
     *                              - params (array): Параметры для подготовленного выражения. Ассоциативный массив
     *                              значений, используемых в запросе (например, [":id" => 1, ":status" => "active"]).
     *                              - group (string): Группировка GROUP BY. Не поддерживается в запросах DELETE и
     *                              удаляется с записью в лог.
     *
     * @return bool Возвращает true, если запрос успешно выполнен (даже если результат пустой).
     *               В случае ошибки выбрасывается исключение.
     *
     * @throws InvalidArgumentException|Exception Выбрасывается, если:
     *                                    - `$from_tbl` не является строкой.
     *                                    - `$options` не является массивом.
     *                                    - Отсутствует обязательное условие `where` в массиве `$options`.
     *
     * @warning Метод чувствителен к корректности входных данных. Неверные типы данных или некорректные значения могут
     *          привести к выбросу исключения. Безопасность обеспечивается обязательным указанием условия `where`.
     *          Запрос без условия `where` не будет выполнен. Ключи `group`, `order` и `limit` проверяются на
     *          корректность. Недопустимые ключи удаляются с записью в лог.
     *
     * Пример использования метода _delete_internal():
     * @code
     * $this->_delete_internal('users', [
     *     'where' => ['id' => 1],
     * ]);
     * @endcode
     * @see     PhotoRigma::Classes::Database::delete() Публичный метод-редирект для вызова этой логики.
     * @see     PhotoRigma::Classes::Database::execute_query() Выполняет SQL-запрос.
     * @see     PhotoRigma::Classes::Database::build_conditions() Формирует условия WHERE, ORDER BY и LIMIT для
     *          запроса.
     * @see     PhotoRigma::Classes::Database::$txt_query Свойство, в которое помещается текст SQL-запроса.
     * @see     PhotoRigma::Include::log_in_file() Функция для логирования ошибок.
     *
     */
    protected function _delete_internal(string $from_tbl, array $options = []): bool
    {
        // === 1. Валидация аргументов ===
        if (empty($options['where'])) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Запрос DELETE без условия WHERE запрещён | Причина: Соображения безопасности"
            );
        }

        // === 2. Проверка и удаление недопустимых ключей ===
        if (isset($options['group'])) {
            log_in_file(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Был использован GROUP BY в DELETE | Переданные опции: " . json_encode(
                    $options,
                    JSON_THROW_ON_ERROR | JSON_UNESCAPED_UNICODE | JSON_PRETTY_PRINT
                )
            );
            unset($options['group']); // Удаляем ключ 'group'
        }

        if ((isset($options['order']) && !isset($options['limit'])) || (!isset($options['order']) && isset($options['limit']))) {
            log_in_file(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | ORDER BY или LIMIT используются некорректно в DELETE | Переданные опции: " . json_encode(
                    $options,
                    JSON_THROW_ON_ERROR | JSON_UNESCAPED_UNICODE | JSON_PRETTY_PRINT
                )
            );
            unset($options['order'], $options['limit']); // Удаляем ключи 'order' и 'limit'
        }

        // === 3. Формирование базового запроса ===
        $this->txt_query = "DELETE FROM $from_tbl";

        // === 4. Добавление условий ===
        [$conditions, $params] = $this->build_conditions($options);
        $this->txt_query .= $conditions;

        // === 5. Выполнение запроса ===
        return $this->execute_query($params);
    }

    /**
     * @brief   Формирует строку дополнений для SQL-запроса (например, WHERE, GROUP BY, ORDER BY, LIMIT).
     *
     * @details Этот метод выполняет следующие шаги:
     *          1. Обрабатывает условие `WHERE`:
     *             - Если `where` является строкой, она используется как есть.
     *             - Если `where` является массивом, он преобразуется в SQL-условие.
     *          2. Обрабатывает ограничение `LIMIT`:
     *             - Проверяет, что значение является числом или строкой, и добавляет его к строке запроса.
     *          3. Возвращает результат:
     *             - Строка дополнений (например, WHERE, GROUP BY, ORDER BY, LIMIT).
     *             - Обновлённый массив параметров для подготовленного выражения.
     *
     * @callergraph
     * @callgraph
     *
     * @param array $options     Опции запроса:
     *                           - where (string|array): Условие WHERE.
     *                           Может быть строкой или ассоциативным массивом.
     *                           Если передан неверный тип, выбрасывается исключение
     *                           InvalidArgumentException.
     *                           - group (string): Группировка GROUP BY.
     *                           Должна быть строкой. Если передан неверный тип, выбрасывается исключение
     *                           InvalidArgumentException.
     *                           - order (string): Сортировка ORDER BY.
     *                           Должна быть строкой. Если передан неверный тип, выбрасывается исключение
     *                           InvalidArgumentException.
     *                           - limit (int|string): Ограничение LIMIT.
     *                           Должно быть числом или строкой (например "0, 10"). Если передан неверный
     *                           тип, выбрасывается исключение InvalidArgumentException.
     *                           - params (array): Параметры для подготовленного выражения (необязательно).
     *                           Если параметры не соответствуют условиям, выбрасывается исключение
     *                           InvalidArgumentException.
     *
     * @return array Массив с двумя элементами:
     *               - string $conditions - Строка дополнений (например, WHERE, GROUP BY, ORDER BY, LIMIT).
     *               - array $params - Обновлённый массив параметров для подготовленного выражения.
     *
     * @throws InvalidArgumentException Если параметры имеют недопустимый тип.
     *
     * Пример использования метода build_conditions():
     * @code
     * $options = [
     *     'where' => ['id' => 1, 'status' => 'active'],
     *     'group' => 'category_id',
     *     'order' => 'created_at DESC',
     *     'limit' => 10,
     *     'params' => [':id' => 1, ':status' => 'active'],
     * ];
     * [$conditions, $params] = $this->build_conditions($options);
     * echo "Условия: $conditions\n";
     * print_r($params);
     * @endcode
     * @see     PhotoRigma::Classes::Database::update()
     *      Метод, который вызывает build_conditions() для формирования UPDATE-запроса.
     * @see     PhotoRigma::Classes::Database::select()
     *      Метод, который вызывает build_conditions() для формирования SELECT-запроса.
     * @see     PhotoRigma::Classes::Database::join()
     *      Метод, который вызывает build_conditions() для формирования JOIN-запроса.
     *
     * @see     PhotoRigma::Classes::Database::delete()
     *      Метод, который вызывает build_conditions() для формирования DELETE-запроса.
     */
    private function build_conditions(array $options): array
    {
        $conditions = '';
        $params = $options['params'] ?? [];

        // === 1. Обработка WHERE ===
        if (isset($options['where'])) {
            if (is_string($options['where'])) {
                // Если where — строка, добавляем её напрямую
                $conditions .= ' WHERE ' . $options['where'];
            } elseif (is_array($options['where'])) {
                // Если where — массив, обрабатываем его
                $conditions .= ' WHERE ' . implode(' AND ', $options['where']);
            } else {
                throw new InvalidArgumentException(
                    __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Неверное условие 'where' | Ожидалась строка или массив, получено: " . gettype(
                        $options['where']
                    )
                );
            }
        }

        // === 2. Обработка GROUP BY ===
        if (isset($options['group'])) {
            if (is_string($options['group'])) {
                $conditions .= ' GROUP BY ' . $options['group'];
            } else {
                throw new InvalidArgumentException(
                    __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Неверное значение 'group' | Ожидалась строка, получено: " . gettype(
                        $options['group']
                    )
                );
            }
        }

        // === 3. Обработка ORDER BY ===
        if (isset($options['order'])) {
            if (is_string($options['order'])) {
                $conditions .= ' ORDER BY ' . $options['order'];
            } else {
                throw new InvalidArgumentException(
                    __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Неверное значение 'order' | Ожидалась строка, получено: " . gettype(
                        $options['order']
                    )
                );
            }
        }

        // === 4. Обработка LIMIT ===
        if (isset($options['limit'])) {
            if (is_numeric($options['limit'])) {
                $conditions .= ' LIMIT ' . (int)$options['limit'];
            } elseif (is_string($options['limit']) && preg_match('/^\d+\s*,\s*\d+$/', $options['limit'])) {
                [$offset, $count] = array_map('intval', explode(',', $options['limit']));
                $conditions .= ' LIMIT ' . $offset . ', ' . $count;
            } else {
                throw new InvalidArgumentException(
                    "[{__FILE__}:{__LINE__} ({__METHOD__ ?: __FUNCTION__ ?: 'global'})] | Неверное значение 'limit' | Ожидалось число или строка формата 'OFFSET, COUNT', получено: " . gettype(
                        $options['limit']
                    ) . " ($options[limit])"
                );
            }
        }

        return [$conditions, $params];
    }

    /**
     * @brief   Выполняет SQL-запрос с использованием подготовленных выражений.
     *
     * @details Этот метод выполняет следующие шаги:
     *          1. Проверяет состояние результата запроса и тип аргументов:
     *             - Убедитесь, что `$res_query` является экземпляром `\PDOStatement`.
     *             - Проверяется, что `$txt_query` является строкой.
     *             - Проверяется, что `$params` является массивом.
     *          2. Очищает внутренние свойства для вывода результата запроса:
     *             - Обнуляет `$res_query`, `$aff_rows`, `$insert_id`.
     *          3. Подготавливает и выполняет SQL-запрос с использованием PDO:
     *             - Использует `$pdo->prepare()` для подготовки запроса.
     *             - Выполняет запрос с переданными параметрами.
     *             - Получает количество затронутых строк (`$aff_rows`) и ID последней вставленной записи
     *             (`$insert_id`).
     *          4. Логирует медленные запросы:
     *             - Измеряет время выполнения запроса.
     *             - Если время выполнения превышает пороговое значение (200 мс), логирует запрос с помощью
     *             `log_in_file()`.
     *          5. Возвращает результат выполнения запроса:
     *             - Возвращает `true`, если запрос успешно выполнен.
     *
     * @callergraph
     * @callgraph
     *
     * @param array $params Массив параметров для подготовленного выражения (необязательно).
     *                      Если параметры не соответствуют плейсхолдерам, выбрасывается исключение
     *                      \\PDOException.
     *
     * @return bool Возвращает true, если запрос успешно выполнен.
     *
     * @throws InvalidArgumentException Если аргументы неверного типа.
     * @throws PDOException|Exception Если возникает ошибка при выполнении запроса.
     *
     * Пример использования метода execute_query():
     * @code
     * $query = "SELECT * FROM users WHERE id = :id";
     * $params = [':id' => 1];
     * $this->execute_query($query, $params);
     * echo "Запрос выполнен успешно!";
     * @endcode
     * @see     PhotoRigma::Classes::Database::$pdo
     *      Объект PDO, используемый для выполнения запроса.
     * @see     PhotoRigma::Classes::Database::$res_query
     *      Результат подготовленного выражения.
     * @see     PhotoRigma::Classes::Database::$aff_rows
     *      Количество затронутых строк после выполнения запроса.
     * @see     PhotoRigma::Classes::Database::$insert_id
     *      ID последней вставленной записи.
     * @see     PhotoRigma::Classes::Database::$txt_query
     *      Свойство, в которое помещается текст SQL-запроса.
     * @see     PhotoRigma::Classes::Database::delete()
     *      Метод, который вызывает execute_query() для выполнения DELETE-запроса.
     * @see     PhotoRigma::Classes::Database::truncate()
     *      Метод, который вызывает execute_query() для выполнения TRUNCATE-запроса.
     * @see     PhotoRigma::Classes::Database::update()
     *      Метод, который вызывает execute_query() для выполнения UPDATE-запроса.
     * @see     PhotoRigma::Classes::Database::insert()
     *      Метод, который вызывает execute_query() для выполнения INSERT-запроса.
     * @see     PhotoRigma::Classes::Database::select()
     *      Метод, который вызывает execute_query() для выполнения SELECT-запроса.
     * @see     PhotoRigma::Classes::Database::join()
     *      Метод, который вызывает execute_query() для выполнения JOIN-запроса.
     * @see     PhotoRigma::Classes::Database::log_query()
     *      Метод логирования медленніх запросов и запросов без плейсхолдеров.
     *
     */
    private function execute_query(array $params = []): bool
    {
        // Валидация состояния запроса и аргументов
        if (isset($this->res_query) && !($this->res_query instanceof PDOStatement)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректное состояние результата запроса | Текущее значение: " . gettype(
                    $this->res_query
                )
            );
        }
        // Очистка внутренних свойств для вывода результата запроса
        $this->res_query = null;
        $this->aff_rows = 0;
        $this->insert_id = 0;
        // Валидация аргументов
        if (!is_string($this->txt_query)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Неверный тип SQL-запроса | Ожидалась строка, получено: " . gettype(
                    $this->txt_query
                )
            );
        }

        // Финальное преобразование запроса в нужный формат СУБД.
        $this->convert_query();

        // Начало замера времени
        $start_time = microtime(true);
        $this->res_query = $this->pdo->prepare($this->txt_query);
        $this->res_query->execute($params);
        $this->aff_rows = $this->res_query->rowCount();
        $this->insert_id = (int)$this->pdo->lastInsertId();
        // Конец замера времени
        $end_time = microtime(true);
        $execution_time = ($end_time - $start_time) * 1000; // Время в миллисекундах
        // Логирование медленных запросов
        $slow_query_threshold = 200; // Порог в миллисекундах
        if ($execution_time > $slow_query_threshold) {
            // Сохраняем запрос в БД
            $this->log_query('slow', $execution_time);
        } elseif (empty($params)) {
            // Сохраняем запрос в БД с пустым плейсхолдером
            $this->log_query('no_placeholders', $execution_time);
        }
        // Очистка строки запроса после её выполнения
        $this->txt_query = null;
        return true;
    }

    /**
     * @brief   Производит финальное преобразование SQL-запроса в зависимости от типа СУБД.
     *
     * @details Этот метод выполняет финальное преобразование SQL-запроса для совместимости с целевой СУБД:
     *          - Для MariaDB (MySQL) запрос остается без изменений.
     *          - Для PostgreSQL заменяет обратные кавычки (\`) на двойные кавычки (").
     *          - Для SQLite удаляет все обратные кавычки (\`).
     *          Если тип СУБД не поддерживается, выбрасывается исключение.
     *          Этот метод является приватным и предназначен только для использования внутри класса.
     *
     * @callergraph
     *
     * @throws InvalidArgumentException Выбрасывается, если тип СУБД не поддерживается.
     *
     * Пример вызова метода внутри класса:
     * @code
     * $this->db_type = 'pgsql';
     * $this->txt_query = "SELECT * FROM `users` WHERE id = 1";
     * $this->convert_query();
     * echo $this->txt_query; // Результат: SELECT * FROM "users" WHERE id = 1
     * @endcode
     * @see     PhotoRigma::Classes::Database::$txt_query Текст запроса к СУБД.
     * @see     PhotoRigma::Classes::Database::execute_query() Метод, из которого вызывается данный метод.
     *
     * @see     PhotoRigma::Classes::Database::$db_type Тип используемой СУБД.
     */
    private function convert_query(): void
    {
        // Проверяем целевую СУБД
        $this->txt_query = match ($this->db_type) {
            'mysql'  => $this->txt_query, // Для MariaDB остается оригинал
            'pgsql'  => str_replace('`', '"', $this->txt_query), // Для PostgreSQL преобразуем ` в "
            'sqlite' => str_replace('`', '', $this->txt_query), // Для SQLite удаляем `
            default  => throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Не поддерживаемый тип СУБД | Тип: $this->db_type"
            ),
        };
    }

    /**
     * @brief   Логирует медленные запросы и запросы без использования плейсхолдеров.
     *
     * @details Этот метод выполняет логирование SQL-запросов в таблицу логов. Метод выполняет следующие шаги:
     *          1. Проверяет, что запрос существует, является строкой и не является запросом к таблице логов.
     *          2. Обрезает запрос до допустимой длины (например, 65,535 символов для TEXT в MySQL).
     *          3. Хэширует запрос для проверки на дублирование.
     *          4. Проверяет, существует ли запрос в таблице логов:
     *             - Если запрос уже существует, обновляет счетчик использования, время последнего использования и
     *             максимальное время выполнения.
     *             - Если запрос не существует, сохраняет его в таблицу логов.
     *          Этот метод является приватным и предназначен только для использования внутри класса.
     *
     * @callergraph
     *
     * @param string     $reason             Причина логирования запроса.
     *                                       Допустимые значения: 'slow' (медленный запрос), 'no_placeholders' (без
     *                                       плейсхолдеров), 'other' (другое). По умолчанию: 'other'.
     * @param float|null $execution_time_ms  Время выполнения запроса в миллисекундах.
     *                                       Должно быть положительным числом или null.
     *                                       Используется только для новых запросов или обновления максимального
     *                                       времени выполнения.
     *
     * @note    Метод использует кэширование (`$query_cache`) для оптимизации проверки существования запросов.
     * @warning Убедитесь, что `$txt_query` содержит корректный SQL-запрос перед вызовом метода.
     *          Также учтите, что слишком длинные запросы будут обрезаны до 65,530 символа.
     *
     * Пример вызова метода внутри класса:
     * @code
     * $this->txt_query = "SELECT * FROM users WHERE id = 1";
     * $this->log_query('slow', 1200.5); // Логирование медленного запроса с временем выполнения 1200.5 мс
     * @endcode
     * @see     PhotoRigma::Classes::Database::$txt_query Текущий SQL-запрос.
     * @see     PhotoRigma::Classes::Database::execute_query() Метод, из которого вызывается данный метод.
     *
     * @see     PhotoRigma::Classes::Database::$pdo Объект PDO для подключения к базе данных.
     * @see     PhotoRigma::Classes::Database::$query_cache Кэш для хранения результатов проверки существования
     *          запросов.
     */
    private function log_query(string $reason = 'other', ?float $execution_time_ms = null): void
    {
        // Проверяем, что запрос существует, является строкой и не является запросом к таблице логов
        if (!is_string($this->txt_query) || empty($this->txt_query) || str_contains($this->txt_query, TBL_LOG_QUERY)) {
            return;
        }

        // Проверяем и нормализуем время выполнения (минимальное значение 0)
        $execution_time_ms = max(0.0, (float)($execution_time_ms ?? 0));

        // Обрезаем запрос до допустимой длины (например, 65,530 символа для TEXT в MySQL)
        $max_query_length = 65530; // Максимальная длина для TEXT
        $log_txt_query = strlen($this->txt_query) > $max_query_length ? substr(
            $this->txt_query,
            0,
            $max_query_length
        ) . '...' // Добавляем суффикс, если текст обрезан
            : $this->txt_query;

        // Проверяем значение $reason через match
        $reason = match ($reason) {
            'slow', 'no_placeholders' => $reason, // Оставляем только допустимые значения
            default                   => 'other',
        };

        // Хэшируем запрос для проверки на дублирование
        $hash = md5($this->txt_query);

        // Проверяем кэш на наличие запроса
        if (!isset($this->query_cache[$hash])) {
            // Если запроса нет в кэше, проверяем его наличие в базе данных
            $stmt = $this->pdo->prepare(
                "SELECT id, usage_count, execution_time FROM " . TBL_LOG_QUERY . " WHERE query_hash = :hash"
            );
            $stmt->execute([':hash' => $hash]);
            $this->query_cache[$hash] = $stmt->fetch(PDO::FETCH_ASSOC); // Сохраняем результат в кэше
        }

        if ($this->query_cache[$hash]) {
            // Если запрос уже существует, обновляем счетчик использования, время последнего использования и максимальное время выполнения
            $new_usage_count = $this->query_cache[$hash]['usage_count'] + 1;
            $max_execution_time = max(
                (float)($this->query_cache[$hash]['execution_time'] ?? 0),
                (float)$execution_time_ms
            );

            $stmt = $this->pdo->prepare(
                "UPDATE " . TBL_LOG_QUERY . "
            SET usage_count = :usage_count, last_used_at = CURRENT_TIMESTAMP, execution_time = :execution_time
            WHERE id = :id"
            );
            $stmt->execute([
                ':usage_count'    => $new_usage_count,
                ':execution_time' => $max_execution_time,
                ':id'             => $this->query_cache[$hash]['id'],
            ]);
        } else {
            // Если запрос не существует, сохраняем его в таблицу логов
            $stmt = $this->pdo->prepare(
                "INSERT INTO " . TBL_LOG_QUERY . " (query_hash, query_text, reason, execution_time)
            VALUES (:hash, :text, :reason, :execution_time)"
            );
            $stmt->execute([
                ':hash'           => $hash,
                ':text'           => $log_txt_query,
                ':reason'         => $reason,
                ':execution_time' => $execution_time_ms, // Время в миллисекундах
            ]);
        }
    }

    /**
     * @brief   Форматирует дату в зависимости от типа СУБД.
     *
     * @details Этот метод является публичным редиректом, вызывающим защищённый метод `_format_date_internal()`.
     *          Метод выполняет формирование SQL-выражения для форматирования даты в зависимости от типа используемой
     *          СУБД. Параметры передаются напрямую в защищённый метод без дополнительной обработки. Основная логика
     *          описана в методе `_format_date_internal()`.
     *
     * @callgraph
     *
     * @param string $column Название столбца с датой.
     *                       Должен быть непустой строкой в формате имени столбца таблицы в БД.
     * @param string $format Формат даты (в стиле MariaDB).
     *                       Должен соответствовать формату MariaDB.
     *
     * @return string SQL-выражение для форматирования даты.
     *
     * @note    Метод использует функции форматирования даты, специфичные для каждой СУБД.
     * @warning Убедитесь, что `$column` и `$format` содержат корректные значения перед вызовом метода.
     *
     * Пример внешнего вызова метода:
     * @code
     * $object = new \PhotoRigma\Classes\Database();
     * $result = $object->format_date('created_at', '%Y-%m-%d');
     * echo $result;
     * // Результат для MySQL: DATE_FORMAT(created_at, '%Y-%m-%d')
     * @endcode
     * @see     PhotoRigma::Classes::Database::_format_date_internal() Защищённый метод, реализующий основную логику
     *          форматирования даты.
     *
     */
    public function format_date(string $column, string $format): string
    {
        return $this->_format_date_internal($column, $format);
    }

    /**
     * @brief   Форматирует дату в зависимости от типа СУБД.
     *
     * @details Этот метод формирует SQL-выражение для форматирования даты в зависимости от типа используемой СУБД.
     *          Метод выполняет следующие шаги:
     *          1. Проверяет тип СУБД (`$db_type`).
     *          2. Для MariaDB (MySQL) использует функцию `DATE_FORMAT`.
     *          3. Для PostgreSQL преобразует формат через метод `convert_to_postgres_format` и использует функцию
     *          `TO_CHAR`.
     *          4. Для SQLite преобразует формат через метод `convert_to_sqlite_format` и использует функцию
     *          `strftime`.
     *          5. Если тип СУБД не поддерживается, выбрасывает исключение.
     *          Этот метод является защищенным и предназначен для использования внутри класса или его наследников.
     *          Основная логика метода вызывается через публичный метод-редирект `format_date()`.
     *
     * @callgraph
     *
     * @param string $column Название столбца с датой.
     *                       Должен быть непустой строкой в формате имени столбца таблицы в БД.
     * @param string $format Формат даты (в стиле MariaDB).
     *                       Должен соответствовать формату MariaDB.
     *
     * @return string SQL-выражение для форматирования даты.
     *
     * @throws InvalidArgumentException Выбрасывается, если тип СУБД не поддерживается.
     *
     * @note    Метод использует функции форматирования даты, специфичные для каждой СУБД.
     * @warning Убедитесь, что `$column` и `$format` содержат корректные значения перед вызовом метода.
     *
     * Пример вызова метода внутри класса:
     * @code
     * $this->_format_date_internal('created_at', '%Y-%m-%d');
     * // Результат для MySQL: DATE_FORMAT(created_at, '%Y-%m-%d')
     * @endcode
     * @see     PhotoRigma::Classes::Database::$db_type Тип используемой СУБД.
     * @see     PhotoRigma::Classes::Database::convert_to_postgres_format() Преобразовывает формат даты в стиль
     *          PostgreSQL.
     * @see     PhotoRigma::Classes::Database::convert_to_sqlite_format() Преобразовывает формат даты в стиль SQLite.
     * @see     PhotoRigma::Classes::Database::format_date() Публичный метод-редирект для вызова этой логики.
     *
     */
    protected function _format_date_internal(string $column, string $format): string
    {
        // Используем match для выбора логики в зависимости от типа СУБД
        return match ($this->db_type) {
            'mysql'  => "DATE_FORMAT($column, '$format')", // Для MariaDB используем DATE_FORMAT
            'pgsql'  => "TO_CHAR($column, '" . $this->convert_to_postgres_format(
                $format
            ) . "')", // Для PostgreSQL преобразуем формат
            'sqlite' => "strftime('" . $this->convert_to_sqlite_format(
                $format
            ) . "', $column)", // Для SQLite используем strftime
            default  => throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Не поддерживаемый тип СУБД | Тип: $this->db_type"
            ),
        };
    }

    /**
     * @brief   Преобразует формат даты из стиля MariaDB в стиль PostgreSQL.
     *
     * @details Этот метод преобразует формат даты из стиля MariaDB в стиль PostgreSQL.
     *          Метод выполняет следующие шаги:
     *          1. Проверяет, есть ли уже преобразованный формат в кэше (`$format_cache`).
     *          2. Если формат отсутствует в кэше, создает карту соответствия между форматами MariaDB и PostgreSQL.
     *          3. Преобразует формат с использованием карты соответствия и сохраняет результат в кэше.
     *          4. Возвращает преобразованный формат из кэша.
     *          Этот метод является приватным и предназначен только для использования внутри класса.
     *
     * @callergraph
     *
     * @param string $mysql_format  Формат даты в стиле MariaDB.
     *                              Должен быть строкой, соответствующей формату MariaDB (например, '%Y-%m-%d').
     *
     * @return string Формат даты в стиле PostgreSQL.
     *
     * @note    Метод использует кэширование для оптимизации повторных преобразований.
     * @warning Убедитесь, что входной формат `$mysql_format` соответствует спецификации MariaDB.
     *
     * Пример вызова метода внутри класса:
     * @code
     * $converted_format = $this->convert_to_postgres_format('%Y-%m-%d');
     * echo $converted_format; // Результат: YYYY-MM-DD
     * @endcode
     * @see     PhotoRigma::Classes::Database::$format_cache Свойство класса для кеширования преобразованных форматов.
     * @see     PhotoRigma::Classes::Database::_format_date_internal() Защищённый метод, вызывающий этот метод для
     *          преобразования формата даты.
     *
     */
    private function convert_to_postgres_format(string $mysql_format): string
    {
        // Проверяем, есть ли уже преобразованный формат в кэше
        if (!isset($this->format_cache['pgsql'][$mysql_format])) {
            $format_map = [
                '%Y' => 'YYYY', // Год (например, 2023)
                '%m' => 'MM',   // Месяц (например, 01..12)
                '%d' => 'DD',   // День месяца (например, 01..31)
                '%H' => 'HH24', // Часы в 24-часовом формате
                '%i' => 'MI',   // Минуты (00..59)
                '%s' => 'SS',   // Секунды (00..59)
                '%a' => 'Dy',   // Сокращенное название дня недели (например, Mon)
                '%W' => 'Day',  // Полное название дня недели (например, Monday)
            ];
            // Преобразуем формат MariaDB в формат PostgreSQL и кэшируем результат
            $this->format_cache['pgsql'][$mysql_format] = strtr($mysql_format, $format_map);
        }
        return $this->format_cache['pgsql'][$mysql_format];
    }

    /**
     * @brief   Преобразует формат даты из стиля MariaDB в стиль SQLite.
     *
     * @details Этот метод преобразует формат даты из стиля MariaDB в стиль SQLite.
     *          Метод выполняет следующие шаги:
     *          1. Проверяет, есть ли уже преобразованный формат в кэше (`$format_cache`).
     *          2. Если формат отсутствует в кэше, создает карту соответствия между форматами MariaDB и SQLite.
     *          3. Преобразует формат с использованием карты соответствия и сохраняет результат в кэше.
     *          4. Возвращает преобразованный формат из кэша.
     *          Этот метод является приватным и предназначен только для использования внутри класса.
     *
     * @callergraph
     *
     * @param string $mysql_format  Формат даты в стиле MariaDB.
     *                              Должен быть строкой, соответствующей формату MariaDB (например, '%Y-%m-%d').
     *
     * @return string Формат даты в стиле SQLite.
     *
     * @note    Метод использует кэширование для оптимизации повторных преобразований.
     * @warning Убедитесь, что входной формат `$mysql_format` соответствует спецификации MariaDB.
     *
     * Пример вызова метода внутри класса:
     * @code
     * $converted_format = $this->convert_to_sqlite_format('%Y-%m-%d');
     * echo $converted_format; // Результат: %Y-%m-%d
     * @endcode
     * @see     PhotoRigma::Classes::Database::$format_cache Свойство класса для кеширования преобразованных форматов.
     * @see     PhotoRigma::Classes::Database::_format_date_internal() Защищённый метод, вызывающий этот метод для
     *          преобразования формата даты.
     *
     */
    private function convert_to_sqlite_format(string $mysql_format): string
    {
        // Проверяем, есть ли уже преобразованный формат в кэше
        if (!isset($this->format_cache['sqlite'][$mysql_format])) {
            $format_map = [
                '%Y' => '%Y', // Год (например, 2023)
                '%m' => '%m', // Месяц (например, 01..12)
                '%d' => '%d', // День месяца (например, 01..31)
                '%H' => '%H', // Часы в 24-часовом формате
                '%i' => '%M', // Минуты (00..59)
                '%s' => '%S', // Секунды (00..59)
                '%a' => '%w', // День недели (0=воскресенье, 6=суббота)
                '%W' => '%W', // Номер недели в году
            ];
            // Преобразуем формат MariaDB в формат SQLite и кэшируем результат
            $this->format_cache['sqlite'][$mysql_format] = strtr($mysql_format, $format_map);
        }
        return $this->format_cache['sqlite'][$mysql_format];
    }

    /**
     * @brief   Возвращает количество строк, затронутых последним запросом.
     *
     * @details Метод является публичным редиректом для защищённого метода `_get_affected_rows_internal()`, который
     *          реализует основную логику получения количества затронутых строк. Все параметры передаются напрямую в
     *          защищённый метод без дополнительных проверок или преобразований. Редиректов из внешних классов нет.
     *
     * @callgraph
     *
     * @return int Количество строк, затронутых последним SQL-запросом.
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                    - Свойство `$aff_rows` не установлено.
     *                                    - Значение свойства `$aff_rows` не является целым числом.
     *
     * @warning Метод чувствителен к состоянию свойства `$aff_rows`. Убедитесь, что перед вызовом метода был выполнен
     *          запрос, который установил значение `$aff_rows` как целое число.
     *
     * Пример использования метода get_affected_rows():
     * @code
     * $db->delete('users', ['where' => 'status = 0']);
     * echo "Affected rows: " . $db->get_affected_rows();
     * @endcode
     * @see     PhotoRigma::Classes::Database::execute_query() Метод, который обновляет значение `$aff_rows` после
     *          выполнения запроса.
     * @see     PhotoRigma::Classes::Database::delete() Метод, который может изменять значение `$aff_rows`.
     * @see     PhotoRigma::Classes::Database::update() Метод, который может изменять значение `$aff_rows`.
     * @see     PhotoRigma::Classes::Database::insert() Метод, который может изменять значение `$aff_rows`.
     *
     * @see     PhotoRigma::Classes::Database::_get_affected_rows_internal() Защищённый метод, реализующий основную
     *          логику.
     * @see     PhotoRigma::Classes::Database::$aff_rows Свойство, хранящее количество затронутых строк.
     */
    public function get_affected_rows(): int
    {
        return $this->_get_affected_rows_internal();
    }

    /**
     * @brief   Возвращает количество строк, затронутых последним запросом.
     *
     * @details Метод выполняет следующие шаги:
     * - Проверяет, что свойство `$aff_rows` установлено. Если это не так, выбрасывается исключение.
     * - Проверяет, что значение свойства `$aff_rows` является целым числом. Если это не так, выбрасывается исключение.
     * - Возвращает значение свойства `$aff_rows`, которое представляет собой количество строк, затронутых последним
     * SQL-запросом.
     *
     * Метод является защищенным и предназначен для использования внутри класса или его наследников. Основная логика
     * вызывается через публичный метод-редирект `get_affected_rows()`.
     *
     * @callergraph
     * @callgraph
     *
     * @return int Количество строк, затронутых последним SQL-запросом.
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                    - Свойство `$aff_rows` не установлено.
     *                                    - Значение свойства `$aff_rows` не является целым числом.
     *
     * @warning Метод чувствителен к состоянию свойства `$aff_rows`. Убедитесь, что перед вызовом метода был выполнен
     *          запрос, который установил значение `$aff_rows` как целое число.
     *
     * Пример использования метода _get_affected_rows_internal():
     * @code
     * $this->delete('users', ['where' => 'status = 0']);
     * echo "Affected rows: " . $this->_get_affected_rows_internal();
     * @endcode
     * @see     PhotoRigma::Classes::Database::execute_query() Метод, который обновляет значение `$aff_rows` после
     *          выполнения запроса.
     * @see     PhotoRigma::Classes::Database::delete() Метод, который может изменять значение `$aff_rows`.
     * @see     PhotoRigma::Classes::Database::update() Метод, который может изменять значение `$aff_rows`.
     * @see     PhotoRigma::Classes::Database::insert() Метод, который может изменять значение `$aff_rows`.
     *
     * @see     PhotoRigma::Classes::Database::get_affected_rows() Публичный метод-редирект для вызова этой логики.
     * @see     PhotoRigma::Classes::Database::$aff_rows Свойство, хранящее количество затронутых строк.
     */
    protected function _get_affected_rows_internal(): int
    {
        // === 1. Валидация состояния ===
        if (!isset($this->aff_rows)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Количество затронутых строк не установлено | Причина: Свойство aff_rows не определено"
            );
        }
        // === 2. Возврат значения ===
        return $this->aff_rows;
    }

    /**
     * @brief   Возвращает ID последней вставленной строки.
     *
     * @details Метод является публичным редиректом для защищённого метода `_get_last_insert_id_internal()`, который
     *          реализует основную логику получения ID последней вставленной строки. Все параметры передаются напрямую
     *          в защищённый метод без дополнительных проверок или преобразований. Редиректов из внешних классов нет.
     *
     * @callgraph
     *
     * @return int ID последней вставленной строки.
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                    - Свойство `$insert_id` не установлено.
     *                                    - Значение свойства `$insert_id` не является целым числом.
     *
     * @warning Метод чувствителен к состоянию свойства `$insert_id`. Убедитесь, что перед вызовом метода был выполнен
     *          запрос, который установил значение `$insert_id` как целое число.
     *
     * Пример использования метода get_last_insert_id():
     * @code
     * $db->insert(['name' => 'John Doe', 'email' => 'john@example.com'], 'users');
     * echo "Last insert ID: " . $db->get_last_insert_id();
     * @endcode
     * @see     PhotoRigma::Classes::Database::insert() Метод, который устанавливает значение `$insert_id`.
     * @see     PhotoRigma::Classes::Database::execute_query() Метод, который обновляет значение `$insert_id` после
     *          выполнения запроса.
     *
     * @see     PhotoRigma::Classes::Database::_get_last_insert_id_internal() Защищённый метод, реализующий основную
     *          логику.
     * @see     PhotoRigma::Classes::Database::$insert_id Свойство, хранящее ID последней вставленной строки.
     */
    public function get_last_insert_id(): int
    {
        return $this->_get_last_insert_id_internal();
    }

    /**
     * @brief   Возвращает ID последней вставленной строки.
     *
     * @details Метод выполняет следующие шаги:
     * - Проверяет, что свойство `$insert_id` установлено. Если это не так, выбрасывается исключение.
     * - Проверяет, что значение свойства `$insert_id` является целым числом. Если это не так, выбрасывается
     * исключение.
     * - Возвращает значение свойства `$insert_id`, которое представляет собой ID последней вставленной строки.
     *
     * Метод является защищенным и предназначен для использования внутри класса или его наследников. Основная логика
     * вызывается через публичный метод-редирект `get_last_insert_id()`.
     *
     * @callergraph
     * @callgraph
     *
     * @return int ID последней вставленной строки.
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                    - Свойство `$insert_id` не установлено.
     *                                    - Значение свойства `$insert_id` не является целым числом.
     *
     * @warning Метод чувствителен к состоянию свойства `$insert_id`. Убедитесь, что перед вызовом метода был выполнен
     *          запрос, который установил значение `$insert_id` как целое число.
     *
     * Пример использования метода _get_last_insert_id_internal():
     * @code
     * $this->insert(['name' => 'John Doe', 'email' => 'john@example.com'], 'users');
     * echo "Last insert ID: " . $this->_get_last_insert_id_internal();
     * @endcode
     * @see     PhotoRigma::Classes::Database::insert() Метод, который устанавливает значение `$insert_id`.
     * @see     PhotoRigma::Classes::Database::execute_query() Метод, который обновляет значение `$insert_id` после
     *          выполнения запроса.
     *
     * @see     PhotoRigma::Classes::Database::get_last_insert_id() Публичный метод-редирект для вызова этой логики.
     * @see     PhotoRigma::Classes::Database::$insert_id Свойство, хранящее ID последней вставленной строки.
     */
    protected function _get_last_insert_id_internal(): int
    {
        // === 1. Валидация состояния ===
        if (!isset($this->insert_id)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | ID последней вставленной строки не установлен | Причина: Свойство insert_id не определено"
            );
        }
        // === 2. Возврат значения ===
        return $this->insert_id;
    }

    /**
     * @brief   Формирует SQL-запрос на вставку данных в таблицу, основываясь на полученных аргументах, размещает его в
     *          свойстве `$txt_query` и выполняет.
     *
     * @details Метод является публичным редиректом для защищённого метода `_insert_internal()`, который реализует
     *          основную логику формирования и выполнения SQL-запроса INSERT. Все параметры передаются напрямую в
     *          защищённый метод без дополнительных проверок или преобразований. Редиректов из внешних классов нет.
     *
     * @callgraph
     *
     * @param array  $insert  Ассоциативный массив данных для вставки в формате: 'имя_поля' => 'значение'.
     * @param string $to_tbl  Имя таблицы, в которую необходимо вставить данные.
     *                        Должно быть строкой, содержащей только допустимые имена таблиц без специальных символов.
     * @param string $type    Тип запроса (необязательно). Определяет тип SQL-запроса на вставку. Допустимые значения:
     *                        - 'ignore': Формирует запрос типа "INSERT IGNORE INTO".
     *                        - 'replace': Формирует запрос типа "REPLACE INTO".
     *                        - 'into': Формирует запрос типа "INSERT INTO" (явное указание).
     *                        - '' (пустая строка): Формирует запрос типа "INSERT INTO" (по умолчанию).
     *                        Если указан недопустимый тип, выбрасывается исключение.
     * @param array  $options Массив опций для формирования запроса. Поддерживаемые ключи:
     *                        - params (array): Параметры для подготовленного выражения. Ассоциативный массив значений,
     *                        используемых в запросе (например, [":name" => "John Doe", ":email" =>
     *                        "john@example.com"]).
     *
     * @return bool Возвращает true, если запрос успешно выполнен (даже если результат пустой).
     *
     * @throws InvalidArgumentException|Exception Выбрасывается, если:
     *                                    - `$insert` не является массивом или является пустым массивом.
     *                                    - `$to_tbl` не является строкой.
     *                                    - `$type` содержит недопустимое значение (не '', 'ignore', 'replace',
     *                                    'into').
     *                                    - `$options` не является массивом.
     *
     * @warning Метод чувствителен к корректности входных данных. Неверные типы данных или некорректные значения могут
     *          привести к выбросу исключения. Убедитесь, что массив `$insert` не пустой и содержит корректные данные.
     *          Параметр `$type` должен быть одним из допустимых значений: '', 'ignore', 'replace', 'into'.
     *
     * Пример использования метода insert():
     * @code
     * $db = new \\PhotoRigma\\Classes\\Database();
     * $db->insert(['name' => 'John Doe', 'email' => 'john@example.com'], 'users');
     * @endcode
     * @see     PhotoRigma::Classes::Database::_insert_internal() Защищённый метод, реализующий основную логику.
     * @see     PhotoRigma::Classes::Database::execute_query() Выполняет SQL-запрос.
     * @see     PhotoRigma::Classes::Database::$txt_query Свойство, в которое помещается текст SQL-запроса.
     *
     */
    public function insert(array $insert, string $to_tbl, string $type = '', array $options = []): bool
    {
        return $this->_insert_internal($insert, $to_tbl, $type, $options);
    }

    /**
     * @brief   Формирует SQL-запрос на вставку данных в таблицу, основываясь на полученных аргументах, размещает его в
     *          свойстве `$txt_query` и выполняет.
     *
     * @details Метод выполняет следующие шаги:
     * - Проверяет типы входных данных: `$insert` (ассоциативный массив), `$to_tbl` (строка), `$type` (строка),
     * `$options` (массив).
     * - Проверяет, что массив `$insert` не пустой. Если массив пустой, выбрасывается исключение.
     * - Нормализует параметр `$type`, приводя его к нижнему регистру, и проверяет на допустимые значения: `'ignore'`,
     * `'replace'`, `'into'`, `''`. Если указан недопустимый тип, выбрасывается исключение.
     * - Определяет тип запроса на основе параметра `$type`:
     *   - `'ignore'`: Формирует запрос типа "INSERT IGNORE INTO".
     *   - `'replace'`: Формирует запрос типа "REPLACE INTO".
     *   - `'into'` или пустая строка (`''`): Формирует запрос типа "INSERT INTO" (по умолчанию).
     * - Формирует базовый SQL-запрос INSERT с использованием преобразованных данных.
     * - Выполняет сформированный запрос через метод `execute_query`.
     *
     * Метод является защищенным и предназначен для использования внутри класса или его наследников. Основная логика
     * вызывается через публичный метод-редирект `insert()`.
     *
     * @callergraph
     * @callgraph
     *
     * @param array  $insert  Ассоциативный массив данных для вставки в формате: 'имя_поля' => 'значение'.
     *                        Если передан пустой массив, выбрасывается исключение.
     * @param string $to_tbl  Имя таблицы, в которую необходимо вставить данные.
     *                        Должно быть строкой, содержащей только допустимые имена таблиц без специальных символов.
     * @param string $type    Тип запроса (необязательно). Определяет тип SQL-запроса на вставку. Допустимые значения:
     *                        - 'ignore': Формирует запрос типа "INSERT IGNORE INTO".
     *                        - 'replace': Формирует запрос типа "REPLACE INTO".
     *                        - 'into': Формирует запрос типа "INSERT INTO" (явное указание).
     *                        - '' (пустая строка): Формирует запрос типа "INSERT INTO" (по умолчанию).
     *                        Если указан недопустимый тип, выбрасывается исключение.
     * @param array  $options Массив опций для формирования запроса. Поддерживаемые ключи:
     *                        - params (array): Параметры для подготовленного выражения. Ассоциативный массив значений,
     *                        используемых в запросе (например, [":name" => "John Doe", ":email" =>
     *                        "john@example.com"]).
     *
     * @return bool Возвращает true, если запрос успешно выполнен (даже если результат пустой).
     *               В случае ошибки выбрасывается исключение.
     *
     * @throws InvalidArgumentException|Exception Выбрасывается, если:
     *                                    - `$insert` не является массивом или является пустым массивом.
     *                                    - `$to_tbl` не является строкой.
     *                                    - `$type` содержит недопустимое значение (не '', 'ignore', 'replace',
     *                                    'into').
     *                                    - `$options` не является массивом.
     *
     * @warning Метод чувствителен к корректности входных данных. Неверные типы данных или некорректные значения могут
     *          привести к выбросу исключения. Убедитесь, что массив `$insert` не пустой и содержит корректные данные.
     *          Параметр `$type` должен быть одним из допустимых значений: '', 'ignore', 'replace', 'into'.
     *
     * Пример использования метода _insert_internal():
     * @code
     * $this->_insert_internal(['name' => 'John Doe', 'email' => 'john@example.com'], 'users');
     * @endcode
     * @see     PhotoRigma::Classes::Database::insert() Публичный метод-редирект для вызова этой логики.
     * @see     PhotoRigma::Classes::Database::execute_query() Выполняет SQL-запрос.
     * @see     PhotoRigma::Classes::Database::$txt_query Свойство, в которое помещается текст SQL-запроса.
     *
     */
    protected function _insert_internal(array $insert, string $to_tbl, string $type = '', array $options = []): bool
    {
        // === 1. Валидация аргументов ===
        if (empty($insert)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Данные для вставки не могут быть пустыми | Причина: Пустой массив данных"
            );
        }
        // Нормализация $type (приведение к нижнему регистру)
        $type = strtolower($type);
        // Проверка допустимых значений для $type
        if (!in_array($type, ['', 'ignore', 'replace', 'into'], true)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Недопустимый тип вставки | Разрешённые значения: '', 'ignore', 'replace', 'into'. Получено: '$type'"
            );
        }
        // === 2. Определение типа запроса ===
        if ($type === 'ignore') {
            $query_type = 'INSERT IGNORE INTO';
        } elseif ($type === 'replace') {
            $query_type = 'REPLACE INTO';
        } else {
            $query_type = 'INSERT INTO'; // По умолчанию или если указано 'into'
        }
        // === 3. Подготовка данных для запроса ===
        $keys = implode(', ', array_keys($insert));
        $values = implode(', ', $insert);

        // === 4. Формирование базового запроса ===
        $this->txt_query = "$query_type $to_tbl ($keys) VALUES ($values)";
        // === 5. Выполнение запроса ===
        return $this->execute_query($options['params']);
    }

    /**
     * @brief   Формирует SQL-запрос с использованием JOIN для выборки данных из нескольких таблиц, основываясь на
     *          полученных аргументах, размещает его в свойстве `$txt_query` и выполняет.
     *
     * @details Метод является публичным редиректом для защищённого метода `_join_internal()`, который реализует
     *          основную логику формирования и выполнения SQL-запроса с использованием JOIN. Все параметры передаются
     *          напрямую в защищённый метод без дополнительных проверок или преобразований. Редиректов из внешних
     *          классов нет.
     *
     * @callgraph
     *
     * @param string|array $select       Список полей для выборки. Может быть строкой (имя одного поля) или массивом
     *                                   (список полей). Если передан массив, он преобразуется в строку с разделителем
     *                                   `, `. Пример: "id", ["id", "name"].
     * @param string       $from_tbl     Имя основной таблицы, из которой начинается выборка.
     *                                   Должно быть строкой, содержащей только допустимые имена таблиц без специальных
     *                                   символов.
     * @param array        $join         Массив описаний JOIN-операций. Каждый элемент массива должен содержать
     *                                   следующие ключи:
     *                                   - table (string): Имя таблицы для JOIN. Должно быть строкой, содержащей только
     *                                   допустимые имена таблиц.
     *                                   - type (string, optional): Тип JOIN (например, INNER, LEFT, RIGHT). Если тип
     *                                   не указан, используется INNER по умолчанию.
     *                                   - on (string): Условие для JOIN. Должно быть строкой с допустимым условием
     *                                   сравнения полей. Если условие отсутствует, выбрасывается исключение. Пример:
     *                                   [['type' => 'INNER', 'table' => 'orders', 'on' => 'users.id =
     *                                   orders.user_id']].
     * @param array        $options      Массив опций для формирования запроса. Поддерживаемые ключи:
     *                                   - where (string|array): Условие WHERE. Может быть строкой (например, "status =
     *                                   1") или ассоциативным массивом (например, ["id" => 1, "status" => "active"]).
     *                                   - group (string): Группировка GROUP BY. Должна быть строкой с именами полей
     *                                   (например, "category_id").
     *                                   - order (string): Сортировка ORDER BY. Должна быть строкой с именами полей и
     *                                   направлением (например, "created_at DESC").
     *                                   - limit (int|string): Ограничение LIMIT. Может быть числом (например, 10) или
     *                                   строкой с диапазоном (например, "0, 10").
     *                                   - params (array): Параметры для подготовленного выражения. Ассоциативный
     *                                   массив значений, используемых в запросе (например, [":id" => 1, ":status" =>
     *                                   "active"]).
     *
     * @return bool Возвращает true, если запрос успешно выполнен (даже если результат пустой).
     *
     * @throws InvalidArgumentException|Exception Выбрасывается, если:
     *                                    - `$from_tbl` не является строкой.
     *                                    - `$join` не является массивом.
     *                                    - `$select` не является строкой или массивом.
     *                                    - Отсутствует имя таблицы (`table`) или условие (`on`) в описании JOIN.
     *
     * @warning Метод чувствителен к корректности входных данных. Неверные типы данных или некорректные значения могут
     *          привести к выбросу исключения.
     *
     * Пример использования метода join():
     * @code
     * $db = new \\PhotoRigma\\Classes\\Database();
     * $db->join(
     *     ['users.id', 'users.name', 'orders.order_date'],
     *     'users',
     *     [
     *         ['type' => 'INNER', 'table' => 'orders', 'on' => 'users.id = orders.user_id'],
     *     ],
     *     [
     *         'where' => ['users.status' => 1],
     *     ]
     * );
     * @endcode
     * @see     PhotoRigma::Classes::Database::_join_internal() Защищённый метод, реализующий основную логику.
     * @see     PhotoRigma::Classes::Database::execute_query() Выполняет SQL-запрос.
     * @see     PhotoRigma::Classes::Database::build_conditions() Формирует условия WHERE, GROUP BY, ORDER BY и LIMIT
     *          для запроса.
     * @see     PhotoRigma::Classes::Database::$txt_query Свойство, в которое помещается текст SQL-запроса.
     *
     */
    public function join(string|array $select, string $from_tbl, array $join, array $options = []): bool
    {
        return $this->_join_internal($select, $from_tbl, $join, $options);
    }

    /**
     * @brief   Формирует SQL-запрос с использованием JOIN для выборки данных из нескольких таблиц, основываясь на
     *          полученных аргументах, размещает его в свойстве `$txt_query` и выполняет.
     *
     * @details Метод выполняет следующие шаги:
     * - Проверяет типы входных данных: `$select` (строка или массив), `$from_tbl` (строка), `$join` (массив),
     * `$options` (массив).
     * - Обрабатывает список полей для выборки (`$select`), преобразуя его в строку с именами полей.
     *   Каждое имя поля оборачивается в обратные кавычки (\` \`).
     * - Обрабатывает массив JOIN-операций (`$join`):
     *   - Для каждой операции проверяется наличие имени таблицы (`table`) и условия (`on`).
     *   - Если тип JOIN не указан, используется `INNER` по умолчанию.
     * - Формирует базовый SQL-запрос с использованием JOIN-операций.
     * - Добавляет условия WHERE, GROUP BY, ORDER BY и LIMIT, если они указаны в параметре `$options`.
     * - Выполняет сформированный запрос через метод `execute_query`.
     *
     * Метод является защищенным и предназначен для использования внутри класса или его наследников. Основная логика
     * вызывается через публичный метод-редирект `join()`.
     *
     * @callergraph
     * @callgraph
     *
     * @param string|array $select       Список полей для выборки. Может быть строкой (имя одного поля) или массивом
     *                                   (список полей). Если передан массив, он преобразуется в строку с разделителем
     *                                   `, `. Пример: "id", ["id", "name"].
     * @param string       $from_tbl     Имя основной таблицы, из которой начинается выборка.
     *                                   Должно быть строкой, содержащей только допустимые имена таблиц без специальных
     *                                   символов.
     * @param array        $join         Массив описаний JOIN-операций. Каждый элемент массива должен содержать
     *                                   следующие ключи:
     *                                   - table (string): Имя таблицы для JOIN. Должно быть строкой, содержащей только
     *                                   допустимые имена таблиц.
     *                                   - type (string, optional): Тип JOIN (например, INNER, LEFT, RIGHT). Если тип
     *                                   не указан, используется INNER по умолчанию.
     *                                   - on (string): Условие для JOIN. Должно быть строкой с допустимым условием
     *                                   сравнения полей. Если условие отсутствует, выбрасывается исключение. Пример:
     *                                   [['type' => 'INNER', 'table' => 'orders', 'on' => 'users.id =
     *                                   orders.user_id']].
     * @param array        $options      Массив опций для формирования запроса. Поддерживаемые ключи:
     *                                   - where (string|array): Условие WHERE. Может быть строкой (например, "status =
     *                                   1") или ассоциативным массивом (например, ["id" => 1, "status" => "active"]).
     *                                   - group (string): Группировка GROUP BY. Должна быть строкой с именами полей
     *                                   (например, "category_id").
     *                                   - order (string): Сортировка ORDER BY. Должна быть строкой с именами полей и
     *                                   направлением (например, "created_at DESC").
     *                                   - limit (int|string): Ограничение LIMIT. Может быть числом (например, 10) или
     *                                   строкой с диапазоном (например, "0, 10").
     *                                   - params (array): Параметры для подготовленного выражения. Ассоциативный
     *                                   массив значений, используемых в запросе (например, [":id" => 1, ":status" =>
     *                                   "active"]).
     *
     * @return bool Возвращает true, если запрос успешно выполнен (даже если результат пустой).
     *               В случае ошибки выбрасывается исключение.
     *
     * @throws InvalidArgumentException|Exception Выбрасывается, если:
     *                                    - `$from_tbl` не является строкой.
     *                                    - `$join` не является массивом.
     *                                    - `$select` не является строкой или массивом.
     *                                    - Отсутствует имя таблицы (`table`) или условие (`on`) в описании JOIN.
     *
     * @warning Метод чувствителен к корректности входных данных. Неверные типы данных или некорректные значения могут
     *          привести к выбросу исключения.
     *
     * Пример использования метода _join_internal():
     * @code
     * $this->_join_internal(
     *     ['users.id', 'users.name', 'orders.order_date'],
     *     'users',
     *     [
     *         ['type' => 'INNER', 'table' => 'orders', 'on' => 'users.id = orders.user_id'],
     *     ],
     *     [
     *         'where' => ['users.status' => 1],
     *     ]
     * );
     * @endcode
     * @see     PhotoRigma::Classes::Database::join() Публичный метод-редирект для вызова этой логики.
     * @see     PhotoRigma::Classes::Database::execute_query() Выполняет SQL-запрос.
     * @see     PhotoRigma::Classes::Database::build_conditions() Формирует условия WHERE, GROUP BY, ORDER BY и LIMIT
     *          для запроса.
     * @see     PhotoRigma::Classes::Database::$txt_query Свойство, в которое помещается текст SQL-запроса.
     *
     */
    protected function _join_internal(string|array $select, string $from_tbl, array $join, array $options = []): bool
    {
        // === 1. Обработка $select ===
        if (!is_array($select)) {
            $select = [$select];
        }
        $select = implode(', ', $select);
        // === 2. Обработка $join ===
        $join_clauses = [];
        foreach ($join as $j) {
            if (empty($j['table'])) {
                throw new InvalidArgumentException(
                    __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Отсутствует имя таблицы в описании JOIN | Проверьте структуру массива \$join"
                );
            }
            if (empty($j['on'])) {
                throw new InvalidArgumentException(
                    __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Отсутствует условие 'on' для таблицы '{$j['table']}' в описании JOIN | Проверьте структуру массива \$join"
                );
            }
            $table = $j['table'];
            $on_condition = $j['on'];
            $type = !empty($j['type']) ? strtoupper($j['type']) . ' ' : 'INNER ';
            $join_clauses[] = "{$type}JOIN $table ON $on_condition";
        }
        // === 3. Формирование базового запроса ===
        $this->txt_query = "SELECT $select FROM $from_tbl " . implode(' ', $join_clauses);
        // === 4. Добавление условий ===
        [$conditions, $params] = $this->build_conditions($options);
        $this->txt_query .= $conditions;
        // === 6. Выполнение запроса ===
        return $this->execute_query($params);
    }

    /**
     * @brief   Извлекает все строки результата из подготовленного выражения, хранящегося в свойстве `$res_query`, и
     *          возвращает их как массив.
     *
     * @details Метод является публичным редиректом для защищённого метода `_res_arr_internal()`, который реализует
     *          основную логику извлечения всех строк результата. Все параметры передаются напрямую в защищённый метод
     *          без дополнительных проверок или преобразований. Редиректов из внешних классов нет.
     *
     * @callgraph
     *
     * @return array|false Возвращает массив ассоциативных массивов, содержащих данные всех строк результата, если они
     *                     доступны. Если результатов нет, возвращает `false`.
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                    - Свойство `$res_query` не установлено.
     *                                    - Свойство `$res_query` не является объектом типа `\PDOStatement`.
     *
     * @warning Метод чувствителен к состоянию свойства `$res_query`. Убедитесь, что перед вызовом метода был выполнен
     *          запрос, который установил значение `$res_query` как объект `\PDOStatement`.
     *
     * Пример использования метода res_arr():
     * @code
     * $db->select(['id', 'name'], 'users', ['where' => 'status = 1']);
     * $results = $db->res_arr();
     * if ($results) {
     *     foreach ($results as $row) {
     *         echo "ID: " . $row['id'] . ", Name: " . $row['name'] . "\n";
     *     }
     * } else {
     *     echo "No results found.";
     * }
     * @endcode
     * @see     PhotoRigma::Classes::Database::execute_query() Метод, который устанавливает значение `$res_query`.
     * @see     PhotoRigma::Classes::Database::select() Метод, который может использовать `res_arr()` для получения
     *          результатов SELECT-запроса.
     * @see     PhotoRigma::Classes::Database::join() Метод, который может использовать `res_arr()` для получения
     *          результатов SELECT-запроса с использованием JOIN.
     *
     * @see     PhotoRigma::Classes::Database::_res_arr_internal() Защищённый метод, реализующий основную логику.
     * @see     PhotoRigma::Classes::Database::$res_query Свойство, хранящее результат подготовленного выражения.
     */
    public function res_arr(): array|false
    {
        return $this->_res_arr_internal();
    }

    /**
     * @brief   Извлекает все строки результата из подготовленного выражения, хранящегося в свойстве `$res_query`, и
     *          возвращает их как массив.
     *
     * @details Метод выполняет следующие шаги:
     * - Проверяет, что свойство `$res_query` установлено и является объектом типа `\PDOStatement`. Если это не так,
     * выбрасывается исключение.
     * - Использует метод `fetchAll(\PDO::FETCH_ASSOC)` для извлечения всех строк результата в виде массива
     * ассоциативных массивов.
     * - Если результатов нет (метод `fetchAll` возвращает пустой массив), явно возвращает `false`.
     * - В противном случае возвращает массив, содержащий все строки результата.
     *
     * Метод является защищенным и предназначен для использования внутри класса или его наследников. Основная логика
     * вызывается через публичный метод-редирект `res_arr()`.
     *
     * @callergraph
     * @callgraph
     *
     * @return array|false Возвращает массив ассоциативных массивов, содержащих данные всех строк результата, если они
     *                     доступны. Если результатов нет, возвращает `false`.
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                    - Свойство `$res_query` не установлено.
     *                                    - Свойство `$res_query` не является объектом типа `\PDOStatement`.
     *
     * @warning Метод чувствителен к состоянию свойства `$res_query`. Убедитесь, что перед вызовом метода был выполнен
     *          запрос, который установил значение `$res_query` как объект `\PDOStatement`.
     *
     * Пример использования метода _res_arr_internal():
     * @code
     * $db->select(['id', 'name'], 'users', ['where' => 'status = 1']);
     * $results = $this->_res_arr_internal();
     * if ($results) {
     *     foreach ($results as $row) {
     *         echo "ID: " . $row['id'] . ", Name: " . $row['name'] . "\n";
     *     }
     * } else {
     *     echo "No results found.";
     * }
     * @endcode
     * @see     PhotoRigma::Classes::Database::execute_query() Метод, который устанавливает значение `$res_query`.
     * @see     PhotoRigma::Classes::Database::select() Метод, который может использовать `_res_arr_internal()` для
     *          получения результатов SELECT-запроса.
     * @see     PhotoRigma::Classes::Database::join() Метод, который может использовать `_res_arr_internal()` для
     *          получения результатов SELECT-запроса с использованием JOIN.
     *
     * @see     PhotoRigma::Classes::Database::res_arr() Публичный метод-редирект для вызова этой логики.
     * @see     PhotoRigma::Classes::Database::$res_query Свойство, хранящее результат подготовленного выражения.
     */
    protected function _res_arr_internal(): array|false
    {
        // === 1. Валидация состояния запроса ===
        if (!isset($this->res_query) || !($this->res_query instanceof PDOStatement)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Результат запроса недоступен или имеет неверный тип | Причина: Отсутствует или некорректен объект PDOStatement"
            );
        }
        // === 2. Извлечение всех строк результата ===
        $rows = $this->res_query->fetchAll(PDO::FETCH_ASSOC);
        if (empty($rows)) {
            return false; // Явно возвращаем false, если результатов нет
        }
        return $rows;
    }

    /**
     * @brief   Извлекает одну строку результата из подготовленного выражения, хранящегося в свойстве `$res_query`.
     *
     * @details Метод является публичным редиректом для защищённого метода `_res_row_internal()`, который реализует
     *          основную логику извлечения строки результата. Все параметры передаются напрямую в защищённый метод без
     *          дополнительных проверок или преобразований. Редиректов из внешних классов нет.
     *
     * @callgraph
     *
     * @return array|false Возвращает ассоциативный массив, содержащий данные одной строки результата, если они
     *                     доступны. Если результатов нет, возвращает `false`.
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                    - Свойство `$res_query` не установлено.
     *                                    - Свойство `$res_query` не является объектом типа `\PDOStatement`.
     *
     * @warning Метод чувствителен к состоянию свойства `$res_query`. Убедитесь, что перед вызовом метода был выполнен
     *          запрос, который установил значение `$res_query` как объект `\PDOStatement`.
     *
     * Пример использования метода res_row()
     * @code
     * $db->select(['id', 'name'], 'users', ['where' => 'status = 1']);
     * while ($row = $db->res_row()) {
     *     echo "ID: " . $row['id'] . ", Name: " . $row['name'] . "\n";
     * }
     * @endcode
     * @see     PhotoRigma::Classes::Database::execute_query() Метод, который устанавливает значение `$res_query`.
     * @see     PhotoRigma::Classes::Database::select() Метод, который может использовать `res_row()` для получения
     *          результатов SELECT-запроса.
     *
     * @see     PhotoRigma::Classes::Database::_res_row_internal() Защищённый метод, реализующий основную логику.
     * @see     PhotoRigma::Classes::Database::$res_query Свойство, хранящее результат подготовленного выражения.
     */
    public function res_row(): array|false
    {
        return $this->_res_row_internal();
    }

    /**
     * @brief   Извлекает одну строку результата из подготовленного выражения, хранящегося в свойстве `$res_query`.
     *
     * @details Метод выполняет следующие шаги:
     * - Проверяет, что свойство `$res_query` установлено и является объектом типа `\PDOStatement`. Если это не так,
     * выбрасывается исключение.
     * - Использует метод `fetch(\PDO::FETCH_ASSOC)` для извлечения одной строки результата в виде ассоциативного
     * массива.
     * - Если результатов нет (метод `fetch` возвращает `false`), явно возвращает `false`.
     * - В противном случае возвращает ассоциативный массив, содержащий данные строки.
     *
     * Метод является защищенным и предназначен для использования внутри класса или его наследников. Основная логика
     * вызывается через публичный метод-редирект `res_row()`.
     *
     * @callergraph
     * @callgraph
     *
     * @return array|false Возвращает ассоциативный массив, содержащий данные одной строки результата, если они
     *                     доступны. Если результатов нет, возвращает `false`.
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                    - Свойство `$res_query` не установлено.
     *                                    - Свойство `$res_query` не является объектом типа `\PDOStatement`.
     *
     * @warning Метод чувствителен к состоянию свойства `$res_query`. Убедитесь, что перед вызовом метода был выполнен
     *          запрос, который установил значение `$res_query` как объект `\PDOStatement`.
     *
     * Пример использования метода _res_row_internal()
     * @code
     * $db->select(['id', 'name'], 'users', ['where' => 'status = 1']);
     * while ($row = $this->_res_row_internal()) {
     *     echo "ID: " . $row['id'] . ", Name: " . $row['name'] . "\n";
     * }
     * @endcode
     * @see     PhotoRigma::Classes::Database::execute_query() Метод, который устанавливает значение `$res_query`.
     * @see     PhotoRigma::Classes::Database::select() Метод, который может использовать `_res_row_internal()` для
     *          получения результатов SELECT-запроса.
     *
     * @see     PhotoRigma::Classes::Database::res_row() Публичный метод-редирект для вызова этой логики.
     * @see     PhotoRigma::Classes::Database::$res_query Свойство, хранящее результат подготовленного выражения.
     */
    protected function _res_row_internal(): array|false
    {
        // === 1. Валидация состояния запроса ===
        if (!isset($this->res_query) || !($this->res_query instanceof PDOStatement)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Результат запроса недоступен или имеет неверный тип | Причина: Отсутствует или некорректен объект PDOStatement"
            );
        }
        // === 2. Извлечение строки результата ===
        return $this->res_query->fetch(PDO::FETCH_ASSOC);
    }

    /**
     * @brief   Формирует SQL-запрос на выборку данных из таблицы, основываясь на полученных аргументах, размещает его
     *          в свойстве `$txt_query` и выполняет.
     *
     * @details Метод является публичным редиректом для защищённого метода `_select_internal()`, который реализует
     *          основную логику формирования и выполнения SQL-запроса. Все параметры передаются напрямую в защищённый
     *          метод без дополнительных проверок или преобразований. Редиректов из внешних классов нет.
     *
     * @callgraph
     *
     * @param string|array $select   Список полей для выборки. Может быть строкой (имя одного поля) или массивом
     *                               (список полей). Если передан массив, он преобразуется в строку с разделителем `,
     *                               `. Пример: "id", ["id", "name"].
     * @param string       $from_tbl Имя таблицы, из которой выбираются данные.
     *                               Должно быть строкой, содержащей только допустимые имена таблиц без специальных
     *                               символов.
     * @param array        $options  Массив опций для формирования запроса. Поддерживаемые ключи:
     *                               - where (string|array): Условие WHERE. Может быть строкой (например, "status = 1")
     *                               или ассоциативным массивом (например, ["id" => 1, "status" => "active"]).
     *                               - group (string): Группировка GROUP BY. Должна быть строкой с именами полей
     *                               (например, "category_id").
     *                               - order (string): Сортировка ORDER BY. Должна быть строкой с именами полей и
     *                               направлением (например, "created_at DESC").
     *                               - limit (int|string): Ограничение LIMIT. Может быть числом (например, 10) или
     *                               строкой с диапазоном (например, "0, 10").
     *                               - params (array): Параметры для подготовленного выражения. Ассоциативный массив
     *                               значений, используемых в запросе (например, [":id" => 1, ":status" => "active"]).
     *
     * @return bool Возвращает true, если запрос успешно выполнен (даже если результат пустой).
     *
     * @throws InvalidArgumentException|Exception Выбрасывается, если:
     *                                    - `$from_tbl` не является строкой.
     *                                    - `$options` не является массивом.
     *                                    - `$select` не является строкой или массивом.
     *
     * @warning Метод чувствителен к корректности входных данных. Неверные типы данных или некорректные значения могут
     *          привести к выбросу исключения.
     *
     * Пример использования метода select():
     * @code
     * $db = new \\PhotoRigma\\Classes\\Database();
     * $db->select(['id', 'name'], 'users', [
     *     'where' => ['status' => 'active'],
     *     'group' => 'category_id',
     *     'order' => 'created_at DESC',
     *     'limit' => 10,
     * ]);
     * @endcode
     * @see     PhotoRigma::Classes::Database::_select_internal() Защищённый метод, реализующий основную логику.
     * @see     PhotoRigma::Classes::Database::execute_query() Выполняет SQL-запрос.
     * @see     PhotoRigma::Classes::Database::build_conditions() Формирует условия WHERE, GROUP BY, ORDER BY и LIMIT
     *          для запроса.
     * @see     PhotoRigma::Classes::Database::$txt_query Свойство, в которое помещается текст SQL-запроса.
     *
     */
    public function select(string|array $select, string $from_tbl, array $options = []): bool
    {
        return $this->_select_internal($select, $from_tbl, $options);
    }

    /**
     * @brief   Формирует SQL-запрос на выборку данных из таблицы, основываясь на полученных аргументах, размещает его
     *          в свойстве `$txt_query` и выполняет.
     *
     * @details Метод выполняет следующие шаги:
     * - Проверяет типы входных данных: `$select` (строка или массив), `$from_tbl` (строка), `$options` (массив).
     * - Обрабатывает список полей для выборки (`$select`), преобразуя его в строку с именами полей.
     * - Формирует базовый SQL-запрос.
     * - Добавляет условия WHERE, GROUP BY, ORDER BY и LIMIT, если они указаны в параметре `$options`.
     * - Выполняет сформированный запрос через метод `execute_query`.
     *
     * Метод является защищенным и предназначен для использования внутри класса или его наследников. Основная логика
     * вызывается через публичный метод-редирект `select()`.
     *
     * @callergraph
     * @callgraph
     *
     * @param string|array $select   Список полей для выборки. Может быть строкой (имя одного поля) или массивом
     *                               (список полей). Если передан массив, он преобразуется в строку с разделителем `,
     *                               `. Пример: "id", ["id", "name"].
     * @param string       $from_tbl Имя таблицы, из которой выбираются данные.
     *                               Должно быть строкой, содержащей только допустимые имена таблиц без специальных
     *                               символов.
     * @param array        $options  Массив опций для формирования запроса. Поддерживаемые ключи:
     *                               - where (string|array): Условие WHERE. Может быть строкой (например, "status = 1")
     *                               или ассоциативным массивом (например, ["id" => 1, "status" => "active"]).
     *                               - group (string): Группировка GROUP BY. Должна быть строкой с именами полей
     *                               (например, "category_id").
     *                               - order (string): Сортировка ORDER BY. Должна быть строкой с именами полей и
     *                               направлением (например, "created_at DESC").
     *                               - limit (int|string): Ограничение LIMIT. Может быть числом (например, 10) или
     *                               строкой с диапазоном (например, "0, 10").
     *                               - params (array): Параметры для подготовленного выражения. Ассоциативный массив
     *                               значений, используемых в запросе (например, [":id" => 1, ":status" => "active"]).
     *
     * @return bool Возвращает true, если запрос успешно выполнен (даже если результат пустой).
     *               В случае ошибки выбрасывается исключение.
     *
     * @throws InvalidArgumentException|Exception Выбрасывается, если:
     *                                    - `$from_tbl` не является строкой.
     *                                    - `$options` не является массивом.
     *                                    - `$select` не является строкой или массивом.
     *
     * @warning Метод чувствителен к корректности входных данных. Неверные типы данных или некорректные значения могут
     *          привести к выбросу исключения.
     *
     * Пример использования метода _select_internal():
     * @code
     * $this->_select_internal(['id', 'name'], 'users', [
     *     'where' => ['status' => 'active'],
     *     'group' => 'category_id',
     *     'order' => 'created_at DESC',
     *     'limit' => 10,
     * ]);
     * @endcode
     * @see     PhotoRigma::Classes::Database::select() Публичный метод-редирект для вызова этой логики.
     * @see     PhotoRigma::Classes::Database::execute_query() Выполняет SQL-запрос.
     * @see     PhotoRigma::Classes::Database::build_conditions() Формирует условия WHERE, GROUP BY, ORDER BY и LIMIT
     *          для запроса.
     * @see     PhotoRigma::Classes::Database::$txt_query Свойство, в которое помещается текст SQL-запроса.
     *
     */
    protected function _select_internal(string|array $select, string $from_tbl, array $options = []): bool
    {
        // Обработка $select
        if (!is_array($select)) {
            // Разбиваем строку по запятым, если это строка
            $select = array_map('trim', explode(',', $select));
        }

        // Проверяем каждую часть выборки на корректность
        foreach ($select as $field) {
            if (!is_string($field)) {
                throw new InvalidArgumentException(
                    __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Недопустимый элемент в выборке | Ожидалась строка, получено: " . gettype(
                        $field
                    )
                );
            }
        }

        // Санитизация каждого поля выборки
        $select = implode(', ', $select);

        // Формирование базового запроса
        $this->txt_query = "SELECT $select FROM $from_tbl";

        // Добавление условий
        [$conditions, $params] = $this->build_conditions($options);
        $this->txt_query .= $conditions;

        // Выполнение запроса
        return $this->execute_query($params);
    }

    /**
     * @brief   Формирует SQL-запрос на очистку таблицы (TRUNCATE), размещает его в свойстве `$txt_query` и выполняет.
     *
     * @details Метод является публичным редиректом для защищённого метода `_truncate_internal()`, который реализует
     *          основную логику формирования и выполнения SQL-запроса TRUNCATE. Все параметры передаются напрямую в
     *          защищённый метод без дополнительных проверок или преобразований. Запрос TRUNCATE полностью очищает
     *          таблицу, удаляя все строки без возможности восстановления. Используйте этот метод с осторожностью.
     *          Редиректов из внешних классов нет.
     *
     * @callgraph
     *
     * @param string $from_tbl Имя таблицы, которую необходимо очистить.
     *                         Должно быть строкой, содержащей только допустимые имена таблиц без специальных символов.
     *
     * @return bool Возвращает true, если запрос успешно выполнен (даже если результат пустой).
     *
     * @throws InvalidArgumentException|Exception Выбрасывается, если:
     *                                    - `$from_tbl` не является строкой.
     *
     * @warning Метод чувствителен к корректности входных данных. Неверные типы данных или некорректные значения могут
     *          привести к выбросу исключения. Запрос TRUNCATE полностью очищает таблицу, удаляя все строки без
     *          возможности восстановления. Используйте этот метод с осторожностью.
     *
     * Пример использования метода truncate()
     * @code
     * $db = new \\PhotoRigma\\Classes\\Database();
     * $db->truncate('users');
     * @endcode
     * @see     PhotoRigma::Classes::Database::$txt_query Свойство, в которое помещается текст SQL-запроса.
     *
     * @see     PhotoRigma::Classes::Database::_truncate_internal() Защищённый метод, реализующий основную логику.
     * @see     PhotoRigma::Classes::Database::execute_query() Выполняет SQL-запрос.
     */
    public function truncate(string $from_tbl): bool
    {
        return $this->_truncate_internal($from_tbl);
    }

    /**
     * @brief   Формирует SQL-запрос на очистку таблицы (TRUNCATE), размещает его в свойстве `$txt_query` и выполняет.
     *
     * @details Метод выполняет следующие шаги:
     * - Проверяет тип входных данных: `$from_tbl` должен быть строкой. Если передан неверный тип, выбрасывается
     * исключение.
     * - Формирует базовый SQL-запрос TRUNCATE TABLE.
     * - Выполняет сформированный запрос через метод `execute_query`.
     *
     * Метод является защищенным и предназначен для использования внутри класса или его наследников. Основная логика
     * вызывается через публичный метод-редирект `truncate()`.
     *
     * @callergraph
     * @callgraph
     *
     * @param string $from_tbl Имя таблицы, которую необходимо очистить.
     *                         Должно быть строкой, содержащей только допустимые имена таблиц без специальных символов.
     *
     * @return bool Возвращает true, если запрос успешно выполнен (даже если результат пустой).
     *               В случае ошибки выбрасывается исключение.
     *
     * @throws InvalidArgumentException|Exception Выбрасывается, если:
     *                                    - `$from_tbl` не является строкой.
     *
     * @warning Метод чувствителен к корректности входных данных. Неверные типы данных или некорректные значения могут
     *          привести к выбросу исключения. Запрос TRUNCATE полностью очищает таблицу, удаляя все строки без
     *          возможности восстановления. Используйте этот метод с осторожностью.
     *
     * Пример использования метода _truncate_internal():
     * @code
     * $this->_truncate_internal('users');
     * @endcode
     * @see     PhotoRigma::Classes::Database::$txt_query Свойство, в которое помещается текст SQL-запроса.
     *
     * @see     PhotoRigma::Classes::Database::truncate() Публичный метод-редирект для вызова этой логики.
     * @see     PhotoRigma::Classes::Database::execute_query() Выполняет SQL-запрос.
     */
    protected function _truncate_internal(string $from_tbl): bool
    {
        // Формирование базового запроса
        $this->txt_query = "TRUNCATE TABLE $from_tbl";
        // Выполнение запроса
        return $this->execute_query();
    }

    /**
     * @brief   Формирует SQL-запрос на обновление данных в таблице, основываясь на полученных аргументах, размещает
     *          его в свойстве `$txt_query` и выполняет.
     *
     * @details Метод является публичным редиректом для защищённого метода `_update_internal()`, который реализует
     *          основную логику формирования и выполнения SQL-запроса UPDATE. Все параметры передаются напрямую в
     *          защищённый метод без дополнительных проверок или преобразований. Безопасность обеспечивается
     *          обязательным указанием условия `where`. Запрос без условия `where` не будет выполнен. Редиректов из
     *          внешних классов нет.
     *
     * @callgraph
     *
     * @param array  $update        Ассоциативный массив данных для обновления в формате: 'имя_поля' => 'значение'.
     * @param string $from_tbl      Имя таблицы, в которой необходимо обновить данные.
     *                              Должно быть строкой, содержащей только допустимые имена таблиц без специальных
     *                              символов.
     * @param array  $options       Массив опций для формирования запроса. Поддерживаемые ключи:
     *                              - where (string|array): Условие WHERE. Может быть строкой (например, "status = 1")
     *                              или ассоциативным массивом (например, ["id" => 1, "status" => "active"]).
     *                              Обязательный параметр для безопасности. Без условия WHERE запрос не будет выполнен.
     *                              - order (string): Сортировка ORDER BY. Должна быть строкой с именами полей и
     *                              направлением (например, "created_at DESC").
     *                              - limit (int|string): Ограничение LIMIT. Может быть числом (например, 10) или
     *                              строкой с диапазоном (например, "0, 10").
     *                              - params (array): Параметры для подготовленного выражения. Ассоциативный массив
     *                              значений, используемых в запросе (например, [":id" => 1, ":status" => "active"]).
     *                              - group (string): Группировка GROUP BY. Не поддерживается в запросах UPDATE и
     *                              удаляется с записью в лог.
     *
     * @return bool Возвращает true, если запрос успешно выполнен (даже если результат пустой).
     *
     * @throws InvalidArgumentException|Exception Выбрасывается, если:
     *                                    - `$update` не является массивом.
     *                                    - `$from_tbl` не является строкой.
     *                                    - `$options` не является массивом.
     *                                    - Отсутствует обязательное условие `where` в массиве `$options`.
     *
     * @warning Метод чувствителен к корректности входных данных. Неверные типы данных или некорректные значения могут
     *          привести к выбросу исключения. Безопасность обеспечивается обязательным указанием условия `where`.
     *          Запрос без условия `where` не будет выполнен. Ключ `group` не поддерживается в запросах UPDATE и
     *          удаляется с записью в лог.
     *
     * Пример использования метода update()
     * @code
     * $db = new \\PhotoRigma\\Classes\\Database();
     * $db->update(['name' => 'John Doe'], 'users', [
     *     'where' => ['id' => 1],
     * ]);
     * @endcode
     * @see     PhotoRigma::Classes::Database::_update_internal() Защищённый метод, реализующий основную логику.
     * @see     PhotoRigma::Classes::Database::execute_query() Выполняет SQL-запрос.
     * @see     PhotoRigma::Classes::Database::build_conditions() Формирует условия WHERE, ORDER BY и LIMIT для
     *          запроса.
     * @see     PhotoRigma::Classes::Database::$txt_query Свойство, в которое помещается текст SQL-запроса.
     *
     */
    public function update(array $update, string $from_tbl, array $options = []): bool
    {
        return $this->_update_internal($update, $from_tbl, $options);
    }

    /**
     * @brief   Формирует SQL-запрос на обновление данных в таблице, основываясь на полученных аргументах, размещает
     *          его в свойстве `$txt_query` и выполняет.
     *
     * @details Метод выполняет следующие шаги:
     * - Проверяет типы входных данных: `$update` (ассоциативный массив), `$from_tbl` (строка), `$options` (массив).
     * - Проверяет наличие обязательного условия `where` в массиве `$options`. Если условие отсутствует, выбрасывается
     * исключение для предотвращения случайного обновления всех данных.
     * - Удаляет недопустимый ключ `group` из массива `$options` с записью в лог, так как GROUP BY не поддерживается в
     * запросах UPDATE.
     * - Формирует базовый SQL-запрос UPDATE с использованием преобразованных данных.
     * - Добавляет условия WHERE, ORDER BY и LIMIT, если они указаны в параметре `$options`.
     * - Выполняет сформированный запрос через метод `execute_query`.
     *
     * Метод является защищенным и предназначен для использования внутри класса или его наследников. Основная логика
     * вызывается через публичный метод-редирект `update()`.
     *
     * @callergraph
     * @callgraph
     *
     * @param array  $update        Ассоциативный массив данных для обновления в формате: 'имя_поля' => 'значение'.
     * @param string $from_tbl      Имя таблицы, в которой необходимо обновить данные.
     *                              Должно быть строкой, содержащей только допустимые имена таблиц без специальных
     *                              символов.
     * @param array  $options       Массив опций для формирования запроса. Поддерживаемые ключи:
     *                              - where (string|array): Условие WHERE. Может быть строкой (например, "status = 1")
     *                              или ассоциативным массивом (например, ["id" => 1, "status" => "active"]).
     *                              Обязательный параметр для безопасности. Без условия WHERE запрос не будет выполнен.
     *                              - order (string): Сортировка ORDER BY. Должна быть строкой с именами полей и
     *                              направлением (например, "created_at DESC").
     *                              - limit (int|string): Ограничение LIMIT. Может быть числом (например, 10) или
     *                              строкой с диапазоном (например, "0, 10").
     *                              - params (array): Параметры для подготовленного выражения. Ассоциативный массив
     *                              значений, используемых в запросе (например, [":id" => 1, ":status" => "active"]).
     *                              - group (string): Группировка GROUP BY. Не поддерживается в запросах UPDATE и
     *                              удаляется с записью в лог.
     *
     * @return bool Возвращает true, если запрос успешно выполнен (даже если результат пустой).
     *               В случае ошибки выбрасывается исключение.
     *
     * @throws InvalidArgumentException|Exception Выбрасывается, если:
     *                                    - `$update` не является массивом.
     *                                    - `$from_tbl` не является строкой.
     *                                    - `$options` не является массивом.
     *                                    - Отсутствует обязательное условие `where` в массиве `$options`.
     *
     * @warning Метод чувствителен к корректности входных данных. Неверные типы данных или некорректные значения могут
     *          привести к выбросу исключения. Безопасность обеспечивается обязательным указанием условия `where`.
     *          Запрос без условия `where` не будет выполнен. Ключ `group` не поддерживается в запросах UPDATE и
     *          удаляется с записью в лог.
     *
     * Пример использования метода _update_internal():
     * @code
     * $this->_update_internal(['name' => 'John Doe'], 'users', [
     *     'where' => ['id' => 1],
     * ]);
     * @endcode
     * @see     PhotoRigma::Classes::Database::update() Публичный метод-редирект для вызова этой логики.
     * @see     PhotoRigma::Classes::Database::execute_query() Выполняет SQL-запрос.
     * @see     PhotoRigma::Classes::Database::build_conditions() Формирует условия WHERE, ORDER BY и LIMIT для
     *          запроса.
     * @see     PhotoRigma::Classes::Database::$txt_query Свойство, в которое помещается текст SQL-запроса.
     *
     */
    protected function _update_internal(array $update, string $from_tbl, array $options = []): bool
    {
        // === 1. Валидация аргументов ===
        if (empty($options['where'])) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Запрос UPDATE без условия WHERE запрещён | Причина: Соображения безопасности"
            );
        }

        // === 2. Удаление недопустимого ключа `group` ===
        if (isset($options['group'])) {
            log_in_file(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Был использован GROUP BY в UPDATE | Переданные опции: " . json_encode(
                    $options,
                    JSON_THROW_ON_ERROR | JSON_UNESCAPED_UNICODE | JSON_PRETTY_PRINT
                )
            );
            unset($options['group']); // Удаляем ключ 'group'
        }

        // === 3. Формирование списка полей для обновления ===
        $update = array_map(static function ($key, $value) {
            return "$key = $value";
        }, array_keys($update), array_values($update));
        $set_clause = implode(', ', $update);

        // === 4. Формирование базового запроса ===
        $this->txt_query = "UPDATE $from_tbl SET $set_clause";

        // === 5. Добавление условий ===
        [$conditions, $params] = $this->build_conditions($options);
        $this->txt_query .= $conditions;

        // === 6. Выполнение запроса ===
        return $this->execute_query($params);
    }
}
