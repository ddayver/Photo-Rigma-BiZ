<?php

/**
 * @file        include/Template.php
 * @brief       Класс для работы с HTML-шаблонами, включая рендеринг и подстановку данных.
 *
 * @author      Dark Dayver
 * @version     0.4.1-rc1
 * @date        2025-04-25
 * @namespace   Photorigma\\Classes
 *
 * @details     Этот файл содержит реализацию класса `Template`, который предоставляет методы для работы с
 *              HTML-шаблонами:
 *              - Обработка шаблонов с реализацией алгоритмов IF/ELSE, ARRAY, SWITCH/CASE.
 *              - Формирование заголовка и подвала HTML-страницы.
 *              - Поддержка читаемых URL через параметр `$mod_rewrite`.
 *              - Все ошибки, возникающие при работе с шаблонами, обрабатываются через исключения.
 *
 * @section     Основные функции
 *              - Добавление строковых данных, условий и блоков выбора для замены в шаблоне.
 *              - Формирование заголовка и подвала HTML-страницы.
 *              - Создание и обработка шаблона с подстановкой данных.
 *              - Поддержка читаемых URL через параметр `$mod_rewrite`.
 *
 * @see         PhotoRigma::Classes::Template Класс для работы с шаблонами.
 * @see         PhotoRigma::Classes::Template_Interface Интерфейс для работы с шаблонами.
 *
 * @note        Этот файл является частью системы PhotoRigma и играет ключевую роль в организации работы приложения.
 *
 * @copyright   Copyright (c) 2008-2025 Dark Dayver. Все права защищены.
 * @license     MIT License (https://opensource.org/licenses/MIT)
 *              Разрешается использовать, копировать, изменять, объединять, публиковать, распространять,
 *              сублицензировать и/или продавать копии программного обеспечения, а также разрешать лицам, которым
 *              предоставляется данное программное обеспечение, делать это при соблюдении следующих условий:
 *              - Уведомление об авторских правах и условия лицензии должны быть включены во все копии или значимые
 *              части программного обеспечения.
 */

namespace PhotoRigma\Classes;

use Exception;
use InvalidArgumentException;
use PhotoRigma\Interfaces\Template_Interface;
use PhotoRigma\Interfaces\Work_Interface;
use Random;
use RuntimeException;

// Предотвращение прямого вызова файла
if (!defined('IN_GALLERY') || IN_GALLERY !== true) {
    error_log(
        date('H:i:s') . " [ERROR] | " . (filter_input(
            INPUT_SERVER,
            'REMOTE_ADDR',
            FILTER_VALIDATE_IP
        ) ?: 'UNKNOWN_IP') . " | " . __FILE__ . " | Попытка прямого вызова файла"
    );
    die("HACK!");
}

/**
 * @class   Template
 * @brief   Класс для работы с шаблонами.
 *
 * @details Этот класс реализует интерфейс `Template_Interface` и предоставляет функционал для работы с HTML-шаблонами.
 *          Основные возможности:
 *          - Добавление строковых данных, условий и блоков выбора для замены в шаблоне.
 *          - Формирование заголовка и подвала HTML-страницы.
 *          - Создание и обработка шаблона с подстановкой данных.
 *          - Поддержка читаемых URL через параметр `$mod_rewrite`.
 *          Все ошибки, возникающие при работе с шаблонами, обрабатываются через исключения.
 *
 * @property string              $ins_header    Данные, вставляемые в заголовок.
 * @property string              $content       Содержимое для вывода.
 * @property bool                $mod_rewrite   Включение читаемых URL.
 * @property string              $template_file Файл шаблона.
 * @property array               $block_object  Блок массивов объектов для обработки.
 * @property array               $block_string  Блок строковых данных для замены.
 * @property array               $block_if      Блок условий для обработки.
 * @property array               $block_case    Блок массивов выбора блока для обработки.
 * @property string              $themes_path   Путь к корню темы.
 * @property string              $themes_url    Ссылка на корень темы.
 * @property string              $site_url      Ссылка корня сайта.
 * @property string              $site_dir      Путь к корню сайта.
 * @property string              $theme         Тема пользователя.
 * @property Work_Interface|null $work          Свойство для объекта класса Work_Interface.
 *
 * Пример создания объекта класса Template:
 * @code
 * $template = new \\PhotoRigma\\Classes\\Template(
 *     'https://example.com',
 *     '/var/www/html',
 *     'default_theme',
 *     true
 * );
 * @endcode
 * @see     Photorigma::Interfaces::Template_Interface Интерфейс, который реализует класс.
 */
class Template implements Template_Interface
{
    // Свойства:
    private string $ins_header = ''; ///< Данные, вставляемые в заголовок
    private string $content = ''; ///< Содержимое для вывода
    private bool $mod_rewrite; ///< Включение читаемых URL
    private string $template_file = 'main.html'; ///< Файл шаблона
    private array $block_object = []; ///< Блок массивов объектов для обработки
    private array $block_string = []; ///< Блок строковых данных для замены
    private array $block_if = []; ///< Блок условий для обработки
    private array $block_case = []; ///< Блок массивов выбора блока для обработки
    private string $themes_path; ///< Путь к корню темы
    private string $themes_url; ///< Ссылка на корень темы
    private string $site_url; ///< Ссылка корня сайта
    private string $site_dir; ///< Путь к корню сайта
    private string $theme; ///< Тема пользователя
    private ?Work_Interface $work = null; ///< Свойство для объекта класса Work_Interface

    /**
     * @brief   Конструктор класса, инициализирующий основные параметры сайта и темы оформления.
     *
     * @details Этот метод выполняет проверку входных данных, инициализирует свойства класса и вычисляет пути к
     *          директориям тем. Выполняется автоматически при создании объекта класса. Алгоритм работы:
     *          1. Проверяет, что `$site_url` является валидным URL.
     *          2. Проверяет, что `$site_dir` существует и является директорией.
     *          3. Проверяет корректность имени темы `$theme` (должно содержать только латинские буквы, цифры, дефисы и
     *             подчеркивания).
     *          4. Инициализирует свойства класса (`$site_url`, `$site_dir`, `$theme`, `$mod_rewrite`).
     *          5. Вычисляет пути к директориям тем (`$themes_path` и `$themes_url`).
     *          6. Проверяет, что директория тем существует и доступна для чтения.
     *          7. Проверяет наличие шаблона по умолчанию с помощью метода `find_template_file()`.
     *          Если на любом этапе возникает ошибка, выбрасывается соответствующее исключение.
     *
     * @callgraph
     *
     * @param string $site_url    URL сайта.
     *                            Должен быть валидным URL.
     *                            Пример: 'https://example.com'.
     *                            Ограничения: должен проходить проверку через `FILTER_VALIDATE_URL`.
     * @param string $site_dir    Директория сайта.
     *                            Должна существовать и быть доступной для чтения.
     *                            Пример: '/var/www/example'.
     *                            Ограничения: должна быть действительной директорией.
     * @param string $theme       Имя темы оформления.
     *                            Должно содержать только латинские буквы, цифры, дефисы и подчеркивания.
     *                            Пример: 'default'.
     *                            Ограничения: не должно быть пустым и должно соответствовать регулярному выражению
     *                            `/^[a-zA-Z0-9_-]+$/`.
     * @param bool   $mod_rewrite Включение читаемых URL. По умолчанию `false`.
     *                            Пример: `true`.
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                  - `$site_url` не является валидным URL.
     *                                    Пример сообщения:
     *                                        Некорректный URL сайта | Значение: [$site_url]
     *                                  - `$site_dir` не существует или не является директорией.
     *                                    Пример сообщения:
     *                                        Некорректная директория сайта | Значение: [$site_dir]
     *                                  - `$theme` пустое или содержит недопустимые символы.
     *                                    Пример сообщения:
     *                                        Некорректное имя темы | Значение: [$theme]
     * @throws RuntimeException Выбрасывается, если:
     *                                  - Директория тем не найдена.
     *                                    Пример сообщения:
     *                                        Директория тем не найдена | Путь: [$themes_path]
     *                                  - Нет прав доступа к директории тем.
     *                                    Пример сообщения:
     *                                        Нет прав доступа к директории тем | Путь: [$themes_path]
     *
     * @note    Метод использует свойства класса для хранения URL сайта, директории сайта, имени темы, путей к темам и
     *          настройки читаемых URL.
     *          Пример вычисляемых путей:
     *          - `$themes_path`: '/var/www/example/themes/default/'.
     *          - `$themes_url`: 'https://example.com/themes/default/'.
     *
     * @warning Убедитесь, что передаваемые параметры корректны:
     *          - `$site_url` должен быть валидным URL.
     *          - `$site_dir` должна существовать и быть доступной для чтения.
     *          - `$theme` должно содержать только допустимые символы.
     *
     * Пример создания объекта:
     * @code
     * $object = new \PhotoRigma\Classes\Template(
     *     'https://example.com',
     *     '/var/www/example',
     *     'default',
     *     true
     * );
     * @endcode
     * @see     PhotoRigma::Classes::Template::$site_url
     *         Свойство, хранящее URL сайта.
     * @see     PhotoRigma::Classes::Template::$site_dir
     *         Свойство, хранящее директорию сайта.
     * @see     PhotoRigma::Classes::Template::$theme
     *         Свойство, хранящее имя темы.
     * @see     PhotoRigma::Classes::Template::$themes_path
     *         Свойство, хранящее путь к директории тем.
     * @see     PhotoRigma::Classes::Template::$themes_url
     *         Свойство, хранящее URL директории тем.
     * @see     PhotoRigma::Classes::Template::$mod_rewrite
     *         Свойство, указывающее на включение читаемых URL.
     * @see     PhotoRigma::Classes::Template::find_template_file()
     *         Метод, проверяющий наличие шаблона по умолчанию.
     */
    public function __construct(string $site_url, string $site_dir, string $theme, bool $mod_rewrite = false)
    {
        // Проверяем, что $site_url является валидным URL
        if (!filter_var($site_url, FILTER_VALIDATE_URL)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректный URL сайта | Значение: $site_url"
            );
        }

        // Проверяем, что $site_dir существует и является директорией
        if (!is_dir($site_dir)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректная директория сайта | Значение: $site_dir"
            );
        }

        // Проверяем корректность $theme
        if (empty($theme) || !preg_match('/^[a-zA-Z0-9_-]+$/', $theme)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректное имя темы | Значение: $theme"
            );
        }

        // Инициализация свойств
        $this->site_url = $site_url;
        $this->site_dir = $site_dir;
        $this->theme = $theme;
        $this->mod_rewrite = $mod_rewrite;

        // Вычисляем пути к темам
        $this->themes_path = $this->site_dir . 'themes/' . $this->theme . '/';
        $this->themes_url = $this->site_url . 'themes/' . $this->theme . '/';

        // Проверяем, что директория тем существует
        if (!is_dir($this->themes_path)) {
            throw new RuntimeException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Директория тем не найдена | Путь: $this->themes_path"
            );
        }

        // Проверяем права доступа к директории тем
        if (!is_readable($this->themes_path)) {
            throw new RuntimeException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Нет прав доступа к директории тем | Путь: $this->themes_path"
            );
        }

        // Проверяем существует ли шаблон по-умолчанию.
        $this->find_template_file();
    }

    /**
     * @brief   Метод проверяет, является ли файл шаблона корректным и доступным для чтения.
     *
     * @details Этот метод выполняет следующие шаги:
     *          1. Строит полный путь к файлу шаблона, объединяя `$themes_path` и `$template_file`.
     *          2. Проверяет, является ли указанный путь файлом.
     *          3. Проверяет, доступен ли файл для чтения.
     *          4. Если все проверки пройдены, сохраняет полный путь к файлу в свойство `$template_file`.
     *          Метод является приватным и предназначен только для использования внутри класса.
     *
     * @callergraph
     *
     * @throws RuntimeException Выбрасывается, если:
     *                                  - Указанный путь не является файлом.
     *                                    Пример сообщения:
     *                                        Указанный путь не является файлом | Путь: [$full_path]
     *                                  - Файл недоступен для чтения.
     *                                    Пример сообщения:
     *                                        Файл недоступен для чтения | Путь: [$full_path]
     *
     * @note    Метод автоматически проверяет корректность передаваемого имени файла шаблона.
     *          Полный путь к файлу строится на основе свойств `$themes_path` и `$template_file`.
     *
     * @warning Убедитесь, что файл шаблона существует и доступен для чтения.
     *          Некорректные пути или отсутствие прав доступа могут привести к исключениям.
     *
     * Пример вызова метода внутри класса:
     * @code
     * $this->find_template_file();
     * @endcode
     * @see     PhotoRigma::Classes::Template::$template_file
     *         Свойство, содержащее имя или путь к файлу шаблона.
     * @see     PhotoRigma::Classes::Template::$themes_path
     *         Свойство, содержащее путь к директории тем.
     */
    private function find_template_file(): void
    {
        $full_path = $this->themes_path . $this->template_file;
        // Проверяем существование файла шаблона по указанному пути
        if (!is_file($full_path)) {
            throw new RuntimeException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Указанный путь не является файлом | Путь: $full_path"
            );
        }

        // Проверяем, доступен ли файл для чтения
        if (!is_readable($full_path)) {
            throw new RuntimeException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Файл недоступен для чтения | Путь: $full_path"
            );
        }
        // Если все проверки пройдены, сохраняем полный путь к файлу
        $this->template_file = $full_path;
    }

    /**
     * @brief   Магический метод для получения значения свойства `$content`.
     *
     * @details Этот метод вызывается автоматически при попытке получить значение недоступного свойства.
     *          Доступ разрешён только к свойству `$content`. Если запрашивается другое свойство,
     *          выбрасывается исключение `InvalidArgumentException`.
     *          Алгоритм работы:
     *          1. Проверяет, соответствует ли имя свойства допустимому значению (`content`).
     *          2. Если имя свойства корректно, возвращает значение свойства `$content`.
     *          3. Если имя свойства некорректно, выбрасывает исключение.
     *
     * @callgraph
     *
     * @param string $name Имя свойства:
     *                     - Допустимое значение: 'content'.
     *                     - Если указано другое имя, выбрасывается исключение.
     *                     Пример: 'content'.
     *                     Ограничения: только одно допустимое значение.
     *
     * @return string Значение свойства `$content`.
     *
     * @throws InvalidArgumentException Выбрасывается, если запрашиваемое свойство не существует или недоступно.
     *                                  Пример сообщения:
     *                                      Свойство не существует | Получено: [$name]
     *
     * @note    Этот метод предназначен только для доступа к свойству `$content`.
     *          Любые другие запросы будут игнорироваться с выбросом исключения.
     *
     * @warning Попытка доступа к несуществующему свойству вызовет исключение.
     *          Убедитесь, что вы запрашиваете только допустимые свойства.
     *
     * Пример использования метода:
     * @code
     * $template = new \PhotoRigma\Classes\Template();
     * echo $template->content; // Выведет содержимое свойства $content
     * @endcode
     * @see     PhotoRigma::Classes::Template::$content
     *         Свойство, содержащее содержимое для вывода.
     */
    public function __get(string $name): string
    {
        if ($name === 'content') {
            return $this->content;
        }
        throw new InvalidArgumentException(
            __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Свойство не существует | Получено: '$name'"
        );
    }

    /**
     * @brief   Устанавливает значение приватных свойств `$template_file` и `$ins_header`.
     *
     * @details Этот метод позволяет изменить значения приватных свойств `$template_file` и `$ins_header`.
     *          Алгоритм работы:
     *          1. Проверяет, соответствует ли имя свойства допустимым значениям (`template_file` или `ins_header`).
     *          2. Если имя свойства корректно:
     *             - Для `$template_file`:
     *               - Устанавливается новое значение.
     *               - Выполняется проверка доступности файла по пути `$themes_path . $template_file` с помощью метода
     *                 `find_template_file()`.
     *               - Если файл не найден или недоступен для чтения, выбрасывается исключение.
     *             - Для `$ins_header`:
     *               - Устанавливается новое значение без дополнительных проверок.
     *          3. Если имя свойства некорректно, выбрасывается исключение.
     *
     * @callgraph
     *
     * @param string $name  Имя свойства:
     *                      - Допустимые значения: 'template_file' и 'ins_header'.
     *                      - Если указано другое имя, выбрасывается исключение.
     *                      Пример: 'template_file'.
     *                      Ограничения: только два допустимых значения.
     * @param string $value Новое значение свойства.
     *                      Должно быть строкой.
     *                      Пример: 'main.html'.
     *
     * @throws InvalidArgumentException Выбрасывается, если переданное имя свойства не соответствует допустимым
     *                                  значениям. Пример сообщения: Свойство не может быть установлено | Получено:
     *                                  [$name]
     * @throws RuntimeException Выбрасывается, если файл по указанному пути не существует или недоступен для чтения.
     *                                  Пример сообщения:
     *                                      Файл недоступен для чтения | Путь: [$themes_path . $template_file]
     *
     * @note    Этот метод предназначен только для изменения свойств `$template_file` и `$ins_header`.
     *          Любые другие запросы будут игнорироваться с выбросом исключения.
     *
     * @warning Убедитесь, что вы запрашиваете только допустимые свойства.
     *          Некорректные имена свойств или недоступные файлы вызовут исключения.
     *
     * Пример использования метода:
     * @code
     * $template = new \PhotoRigma\Classes\Template();
     * $template->template_file = 'main.html'; // Установит файл шаблона, если он доступен
     * $template->ins_header = '<meta name="description" content="Example">'; // Установит содержимое заголовка
     * @endcode
     * @see     PhotoRigma::Classes::Template::$themes_path
     *         Свойство, содержащее путь к директории тем.
     * @see     PhotoRigma::Classes::Template::$template_file
     *         Свойство, содержащее имя файла шаблона.
     * @see     PhotoRigma::Classes::Template::$ins_header
     *         Свойство, вставляемое в заголовок.
     * @see     PhotoRigma::Classes::Template::find_template_file()
     *         Метод, проверяющий правильность переданного имени файла шаблона.
     */
    public function __set(string $name, string $value): void
    {
        if ($name === 'template_file') {
            $this->template_file = $value;
            $this->find_template_file();
            $this->template_file = $this->themes_path . $value;
        } elseif ($name === 'ins_header') {
            $this->ins_header = $value;
        } else {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Свойство не может быть установлено | Получено: '$name'"
            );
        }
    }

    /**
     * @brief   Проверяет существование недоступного свойства.
     *
     * @details Этот метод вызывается автоматически при использовании оператора `isset()` для проверки
     *          существования недоступного свойства. Метод возвращает `true`, если свойство существует,
     *          и `false` в противном случае.
     *
     * @callgraph
     *
     * @param string $name Имя свойства:
     *                     - Проверяется на существование.
     *
     * @return bool Результат проверки:
     *              - `true`, если свойство существует.
     *              - `false`, если свойство не существует.
     *
     * @note    Этот метод предназначен только для проверки существования свойств.
     *
     * @warning Если свойство не определено или является недоступным, результат будет `false`.
     *
     * Пример использования метода:
     * @code
     * $template = new \PhotoRigma\Classes\Template();
     * if (isset($template->content)) {
     *     echo "Свойство 'content' существует.";
     * } else {
     *     echo "Свойство 'content' не существует.";
     * }
     * @endcode
     */
    public function __isset(string $name): bool
    {
        return isset($this->$name);
    }

    /**
     * @brief   Установка объекта, реализующего интерфейс Work_Interface, через сеттер.
     *
     * @details Этот метод позволяет установить объект, реализующий интерфейс `Work_Interface`.
     *          Метод выполняет следующие действия:
     *          1. Проверяет, что переданный объект реализует интерфейс `Work_Interface`.
     *          2. Присваивает объект свойству текущего класса для дальнейшего использования.
     *
     * @param Work_Interface $object Объект, реализующий интерфейс `Work_Interface`:
     *                               - Должен быть экземпляром класса, реализующего интерфейс `Work_Interface`.
     *
     * @throws InvalidArgumentException Если передан некорректный объект (не реализует интерфейс `Work_Interface`).
     *
     * @note    Метод проверяет тип переданного объекта.
     *          Объект используется для взаимодействия с другими компонентами системы.
     *
     * @warning Некорректный объект (не реализует интерфейс `Work_Interface`) вызывает исключение.
     *
     * Пример использования:
     * @code
     * // Создание объекта Template и установка объекта Work
     * $template = new \PhotoRigma\Classes\Template();
     * $work = new \PhotoRigma\Classes\Work(); // Класс, реализующий Work_Interface
     * $template->set_work($work);
     * @endcode
     * @see     PhotoRigma::Classes::Work_Interface
     *          Интерфейс, которому должен соответствовать объект.
     */
    public function set_work(Work_Interface $work): void
    {
        $this->work = $work;
    }

    /**
     * @brief   Добавляет массив условий для вывода фрагментов шаблона через вызов внутреннего метода.
     *
     * @details Этот публичный метод является обёрткой для защищённого метода _add_if_ar_internal().
     *          Он добавляет массив данных об условиях вывода фрагментов шаблона, с возможностью рекурсивного
     *          размещения. Метод проверяет корректность входных данных и использует метод `add_if()` для добавления
     *          каждой пары ключ-значение. Предназначен для прямого использования извне.
     *
     * @param array        $array_data Массив условий:
     *                                 - Ключи должны содержать только латинские буквы, цифры и подчеркивания.
     *                                 - Значения должны быть булевыми (`true` или `false`).
     *                                 Пример: ["SHOW_HEADER" => true, "SHOW_FOOTER" => false].
     *                                 Ограничения: массив не может быть пустым.
     * @param string|false $path_array Путь для рекурсивного размещения условий:
     *                                 - Должен быть строкой (например, "Массив1[0]->Массив1.0[0]") или `false` (по
     *                                 умолчанию).
     *                                 - Убедитесь, что путь передан в правильном формате.
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                  - Массив данных пуст.
     *                                    Пример сообщения:
     *                                        Массив данных пуст | Ожидался массив в аргументе $array_data
     *                                  - Путь (`$path_array`) имеет некорректный формат (не строка и не `false`).
     *                                    Пример сообщения:
     *                                        Некорректный формат пути | Ожидается строка или FALSE
     *                                  - Ключ массива некорректен (пустой или содержит недопустимые символы).
     *                                    Пример сообщения:
     *                                        Некорректный ключ массива | Значение: [ключ]
     *                                  - Значение массива не является булевым значением (`true` или `false`).
     *                                    Пример сообщения:
     *                                        Некорректное значение массива | Значение: [значение]
     *
     * @note    Этот метод является точкой входа для добавления условий вывода фрагментов шаблона. Все проверки и
     *          обработка выполняются в защищённом методе _add_if_ar_internal().
     *
     * @warning Метод чувствителен к параметру `$path_array`. Убедитесь, что он передан в правильном формате (строка
     *          или `false`). Также убедитесь, что массив данных содержит только допустимые ключи и булевы значения.
     *          Некорректные данные могут привести к выбросу исключения.
     *
     * Пример использования:
     * @code
     * // Вызов метода из клиентского кода
     * $object = new \PhotoRigma\Classes\Template('https://example.com', '/var/www/example', 'default');
     * $data = [
     *     'SHOW_HEADER' => true,
     *     'SHOW_FOOTER' => false
     * ];
     * $object->add_if_ar($data);
     * $object->add_if_ar($data, 'Массив1[0]->Массив1.0[0]');
     * @endcode
     * @see     PhotoRigma::Classes::Template::_add_if_ar_internal()
     *          Защищённый метод, реализующий основную логику добавления условий вывода фрагментов шаблона.
     */
    public function add_if_ar(array $array_data, string|false $path_array = false): void
    {
        $this->_add_if_ar_internal($array_data, $path_array);
    }

    /**
     * @brief   Метод добавляет массив данных об условиях вывода фрагментов шаблона, с возможностью рекурсивного
     *          размещения.
     *
     * @details Этот метод выполняет следующие шаги:
     *          1. Проверяет, что массив данных не пуст. Если массив пуст, выбрасывается исключение.
     *          2. Проверяет формат пути (`$path_array`), если он указан. Путь должен быть строкой или `false`.
     *          3. Для каждого элемента массива проверяет корректность ключа (только латинские буквы, цифры и
     *             подчеркивания) и значения (булево значение).
     *          4. Добавляет каждую пару ключ-значение в шаблон с помощью метода `add_if()`.
     *          Этот метод является защищенным и предназначен для использования внутри класса или его наследников.
     *          Основная логика вызывается через публичный метод-редирект `add_if_ar()`.
     *
     * @callergraph
     * @callgraph
     *
     * @param array        $array_data Массив условий. Ключи должны содержать только латинские буквы, цифры и
     *                                 подчеркивания. Значения должны быть булевыми (`true` или `false`).
     *                                 Пример: ["SHOW_HEADER" => true, "SHOW_FOOTER" => false].
     *                                 Ограничения: массив не может быть пустым.
     * @param string|false $path_array Путь для рекурсивного размещения условий. Должен быть строкой (например,
     *                                 "Массив1[0]->Массив1.0[0]") или `false` (по умолчанию).
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                  - Массив данных пуст.
     *                                    Пример сообщения:
     *                                        Массив данных пуст | Ожидался массив в аргументе $array_data
     *                                  - Путь (`$path_array`) имеет некорректный формат (не строка и не `false`).
     *                                    Пример сообщения:
     *                                        Некорректный формат пути | Ожидается строка или FALSE
     *                                  - Ключ массива некорректен (пустой или содержит недопустимые символы).
     *                                    Пример сообщения:
     *                                        Некорректный ключ массива | Значение: [ключ]
     *                                  - Значение массива не является булевым значением (`true` или `false`).
     *                                    Пример сообщения:
     *                                        Некорректное значение массива | Значение: [значение]
     *
     * @warning Метод особенно чувствителен к параметру `$path_array`. Убедитесь, что он передается в правильном
     *          формате (строка или `false`). Также убедитесь, что массив данных содержит только допустимые ключи и
     *          булевы значения. Некорректные данные могут привести к выбросу исключения.
     *
     * Пример использования метода _add_if_ar_internal():
     * @code
     * // Добавление условий без указания пути
     * $this->_add_if_ar_internal([
     *     'SHOW_HEADER' => true,
     *     'SHOW_FOOTER' => false
     * ]);
     *
     * // Добавление условий с указанием пути
     * $this->_add_if_ar_internal(
     *     [
     *         'SHOW_HEADER' => true,
     *         'SHOW_FOOTER' => false
     *     ],
     *     'Массив1[0]->Массив1.0[0]'
     * );
     * @endcode
     * @see     PhotoRigma::Classes::Template::add_if()
     *          Метод, используемый для добавления отдельных условий.
     * @see     PhotoRigma::Classes::Template::add_if_ar()
     *          Метод, для публичного доступа к методу _add_if_ar_internal().
     */
    protected function _add_if_ar_internal(array $array_data, string|false $path_array = false): void
    {
        // Проверка на пустой массив
        if (empty($array_data)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Массив данных пуст | Ожидался массив в аргументе \$array_data"
            );
        }

        // Проверка формата пути
        if ($path_array !== false && !is_string($path_array)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректный формат пути | Ожидается строка или FALSE"
            );
        }

        // Обработка массива данных
        foreach ($array_data as $key => $value) {
            if (!is_string($key) || !preg_match('/^\w+$/', $key)) {
                throw new InvalidArgumentException(
                    __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректный ключ массива | Значение: $key"
                );
            }
            if (!is_bool($value)) {
                throw new InvalidArgumentException(
                    __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректное значение массива | Значение: $value"
                );
            }
            $this->add_if($key, $value, $path_array);
        }
    }

    /**
     * @brief   Добавляет условие для вывода фрагментов шаблона через вызов внутреннего метода.
     *
     * @details Этот публичный метод является обёрткой для защищённого метода _add_if_internal().
     *          Он добавляет данные об условиях вывода фрагментов шаблона, с возможностью рекурсивного размещения.
     *          Метод проверяет корректность входных данных и добавляет условие в массив `block_if` или объекты в
     *          зависимости от пути. Предназначен для прямого использования извне.
     *
     * @param string       $name       Название условия:
     *                                 - Должно содержать только латинские буквы, цифры и подчеркивания.
     *                                 - Пример: "SHOW_HEADER".
     *                                 Ограничения: не может быть пустым или содержать недопустимые символы.
     * @param bool         $value      Значение условия:
     *                                 - Должно быть булевым значением (`true` или `false`).
     *                                 - Пример: true.
     * @param string|false $path_array Путь для рекурсивного размещения условия:
     *                                 - Должен быть строкой (например, "Массив1[0]->Массив1.0[0]") или `false` (по
     *                                 умолчанию).
     *                                 - Убедитесь, что путь передан в правильном формате.
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                  - Имя условия некорректно (пустое или содержит недопустимые символы).
     *                                    Пример сообщения:
     *                                        Некорректное имя условия | Значение: [имя]
     *                                  - Путь (`$path_array`) имеет некорректный формат (не строка и не `false`).
     *                                    Пример сообщения:
     *                                        Некорректный формат пути | Ожидается строка или FALSE
     *                                  - Формат `next_path` некорректен (не строка и не `false`).
     *                                    Пример сообщения:
     *                                        Некорректный формат next_path | Ожидается строка или FALSE
     * @throws RuntimeException Выбрасывается, если результат метода `test_is_object()` некорректен.
     *                                  Пример сообщения:
     *                                      Некорректный результат test_is_object | Передавался путь: [путь]
     *
     * @note    Этот метод является точкой входа для добавления условий вывода фрагментов шаблона. Все проверки и
     *          обработка выполняются в защищённом методе _add_if_internal().
     *
     * @warning Метод чувствителен к параметру `$path_array`. Убедитесь, что он передан в правильном формате (строка
     *          или `false`). Также убедитесь, что имя условия содержит только допустимые символы. Некорректные данные
     *          могут привести к выбросу исключения.
     *
     * Пример использования:
     * @code
     * // Вызов метода из клиентского кода
     * $object = new \PhotoRigma\Classes\Template('https://example.com', '/var/www/example', 'default');
     * $object->add_if('SHOW_HEADER', true);
     * $object->add_if('SHOW_FOOTER', false, 'Массив1[0]->Массив1.0[0]');
     * @endcode
     * @see     PhotoRigma::Classes::Template::_add_if_internal()
     *          Защищённый метод, реализующий основную логику добавления условий вывода фрагментов шаблона.
     */
    public function add_if(string $name, bool $value, string|false $path_array = false): void
    {
        $this->_add_if_internal($name, $value, $path_array);
    }

    /**
     * @brief   Метод добавляет данные об условиях вывода фрагментов шаблона, с возможностью рекурсивного размещения.
     *
     * @details Этот метод выполняет следующие шаги:
     *          1. Проверяет корректность имени условия (только латинские буквы, цифры и подчеркивания). Если имя
     *          некорректно, выбрасывается исключение.
     *          2. Проверяет формат пути (`$path_array`), если он указан. Путь должен быть строкой или `false`.
     *          3. Если путь не указан, добавляет условие в массив `block_if`. Если путь указан, рекурсивно добавляет
     *          условие в объекты с использованием метода `test_is_object()`. Этот метод является защищенным и
     *          предназначен для использования внутри класса или его наследников. Основная логика вызывается через
     *          публичный метод-редирект `add_if()`.
     *
     * @callergraph
     * @callgraph
     *
     * @param string       $name       Название условия. Должно содержать только латинские буквы, цифры и
     *                                 подчеркивания.
     *                                 Пример: "SHOW_HEADER".
     *                                 Ограничения: не может быть пустым или содержать недопустимые символы.
     * @param bool         $value      Значение условия. Должно быть булевым значением (`true` или `false`).
     *                                 Пример: true.
     * @param string|false $path_array Путь для рекурсивного размещения условия. Должен быть строкой (например,
     *                                 "Массив1[0]->Массив1.0[0]") или `false` (по умолчанию).
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                  - Имя условия некорректно (пустое или содержит недопустимые символы).
     *                                    Пример сообщения:
     *                                        Некорректное имя условия | Значение: [имя]
     *                                  - Путь (`$path_array`) имеет некорректный формат (не строка и не `false`).
     *                                    Пример сообщения:
     *                                        Некорректный формат пути | Ожидается строка или FALSE
     *                                  - Формат `next_path` некорректен (не строка и не `false`).
     *                                    Пример сообщения:
     *                                        Некорректный формат next_path | Ожидается строка или FALSE
     * @throws RuntimeException Выбрасывается, если результат метода `test_is_object()` некорректен.
     *                                  Пример сообщения:
     *                                      Некорректный результат test_is_object | Передавался путь: [путь]
     *
     * @warning Метод особенно чувствителен к параметру `$path_array`. Убедитесь, что он передается в правильном
     *          формате
     *          (строка или `false`). Также убедитесь, что имя условия содержит только допустимые символы. Некорректные
     *          данные могут привести к выбросу исключения.
     *
     * Пример использования метода _add_if_internal():
     * @code
     * // Добавление условия без указания пути
     * $this->_add_if_internal('SHOW_HEADER', true);
     *
     * // Добавление условия с указанием пути
     * $this->_add_if_internal(
     *     'SHOW_FOOTER',
     *     false,
     *     'Массив1[0]->Массив1.0[0]'
     * );
     * @endcode
     * @see     PhotoRigma::Classes::Template::$block_if
     *          Свойство, содержащее массив условий.
     * @see     PhotoRigma::Classes::Template::$block_object
     *          Свойство, содержащее объекты для рекурсивного размещения условий.
     * @see     PhotoRigma::Classes::Template::test_is_object()
     *          Метод, используемый для разбора пути.
     * @see     PhotoRigma::Classes::Template::add_if()
     *          Метод, для публичного доступа к методу _add_if_internal().
     */
    protected function _add_if_internal(string $name, bool $value, string|false $path_array = false): void
    {
        // Проверка корректности имени условия
        if (empty($name) || !preg_match('/^\w+$/', $name)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректное имя условия | Значение: $name"
            );
        }

        // Проверка формата пути
        if ($path_array !== false && !is_string($path_array)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректный формат пути | Ожидается строка или FALSE"
            );
        }

        // Если путь не указан, добавляем условие в массив block_if
        if (!$path_array) {
            $this->block_if['IF_' . strtoupper($name)] = $value;
        } else {
            // Разбираем путь и проверяем результат
            $parsed_path = $this->test_is_object($path_array);
            if (!isset($parsed_path['current'], $parsed_path['index'])) {
                throw new RuntimeException(
                    __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректный результат test_is_object | Передавался путь: $path_array"
                );
            }

            // Проверка формата next_path
            if ($parsed_path['next_path'] !== false && !is_string($parsed_path['next_path'])) {
                throw new InvalidArgumentException(
                    __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректный формат next_path | Ожидается строка или FALSE"
                );
            }

            // Рекурсивно добавляем условие
            $this->block_object[$parsed_path['current']][$parsed_path['index']]->add_if(
                $name,
                $value,
                $parsed_path['next_path']
            );
        }
    }

    /**
     * @brief   Метод проверяет путь, разбирает его на составные части и создает новый объект-массив при необходимости.
     *
     * @details Этот метод выполняет следующие шаги:
     *          1. Проверяет корректность входного пути (`$path_array`):
     *             - Преобразует путь в верхний регистр.
     *             - Проверяет формат имени объекта (только заглавные буквы и символ подчеркивания).
     *             - Проверяет формат индекса (целое число в квадратных скобках).
     *          2. Разбирает путь на составные части:
     *             - Извлекает имя объекта, индекс и остаток пути.
     *          3. Создает новый объект в массиве `block_object`, если он не существует.
     *          4. Возвращает массив с текущим именем объекта, индексом и остатком пути.
     *          Метод является приватным и предназначен только для использования внутри класса.
     *
     * @callergraph
     * @callgraph
     *
     * @param string $path_array Путь, по которому рекурсивно необходимо создать объект-массив.
     *                           Должен быть строкой в формате: `ИМЯ_ОБЪЕКТА[ИНДЕКС]->ИМЯ_ОБЪЕКТА.ИНДЕКС[ИНДЕКС]`.
     *                           - Имя объекта: только заглавные буквы и символ подчеркивания.
     *                           - Индекс: целое число в квадратных скобках.
     *                           Обязательный параметр.
     *                           Пример: 'BLOCK_ARRAY[0]->BLOCK_ARRAY.0[1]'.
     *
     * @return array Массив с ключами:
     *               - `'current'`: имя объекта (строка).
     *               - `'index'`: порядковый номер в массиве (целое число).
     *               - `'next_path'`: остаток пути (строка или `false`, если путь полностью разобран).
     *
     * @throws InvalidArgumentException Выбрасывается, если путь некорректен:
     *                                  - Имя объекта содержит недопустимые символы.
     *                                    Пример сообщения:
     *                                        Ошибка в пути объекта | Путь: [$path_array]
     *                                  - Индекс не является целым числом.
     *                                    Пример сообщения:
     *                                        Некорректный индекс в пути | Путь: [$path_array]
     *                                  - Путь имеет недопустимый формат.
     *
     * @note    Метод создает новый объект в массиве `block_object`, если он не существует.
     *          Новый объект создается с использованием конструктора класса `Template`.
     *
     * @warning Убедитесь, что входной путь соответствует требованиям:
     *          - Имя объекта должно содержать только заглавные буквы и символ подчеркивания.
     *          - Индекс должен быть целым числом в квадратных скобках.
     *          Некорректный путь вызовет исключение.
     *
     * Пример вызова метода внутри класса:
     * @code
     * $result = $this->test_is_object('BLOCK_ARRAY[0]->BLOCK_ARRAY.0[1]');
     * if ($result['next_path'] === false) {
     *     echo "Путь полностью разобран.";
     * }
     * @endcode
     * @see     PhotoRigma::Classes::Template
     *         Класс, используемый для создания новых объектов.
     * @see     PhotoRigma::Classes::Template::$block_object
     *         Свойство, содержащее массив объектов.
     */
    private function test_is_object(string $path_array): array
    {
        // Разбор пути
        $path_parts = explode('->', $path_array);
        $first_part = strtoupper($path_parts[0]);
        $first_part_details = explode('[', $first_part);
        // Проверка корректности первого элемента
        if (empty($first_part_details[1]) || !preg_match(
            '/^[A-Z_]+$/',
            $first_part_details[0]
        )) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Ошибка в пути объекта | Путь: $path_array"
            );
        }
        // Проверка индекса
        $index = str_replace(']', '', $first_part_details[1]);
        if (!preg_match('/^\d+$/', $index)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректный индекс в пути | Путь: $path_array"
            );
        }
        // Создание объекта, если он не существует
        if (!isset($this->block_object[$first_part_details[0]][$index]) || !is_object(
            $this->block_object[$first_part_details[0]][$index]
        )) {
            $this->block_object[$first_part_details[0]][$index] = new Template(
                $this->site_url,
                $this->site_dir,
                $this->theme
            );
        }
        // Формирование результата
        return [
            'current'   => $first_part_details[0],
            'index'     => $index,
            'next_path' => count($path_parts) > 1 ? implode('->', array_slice($path_parts, 1)) : false,
        ];
    }

    /**
     * @brief   Добавляет массив данных о выборе блока для вывода фрагментов шаблона через вызов внутреннего метода.
     *
     * @details Этот публичный метод является обёрткой для защищённого метода _add_case_ar_internal().
     *          Он добавляет массив данных о выборе блока для вывода фрагментов шаблона, с возможностью рекурсивного
     *          размещения. Метод проверяет корректность входных данных и использует метод `add_case()` для добавления
     *          каждой пары ключ-значение. Предназначен для прямого использования извне.
     *
     * @param array        $array_data Массив данных о выборе блока:
     *                                 - Ключи и значения должны содержать только латинские буквы, цифры и
     *                                 подчеркивания.
     *                                 - Пример: ["BLOCK_TYPE" => "HEADER", "BLOCK_STYLE" => "COMPACT"].
     *                                 Ограничения: массив не может быть пустым.
     * @param string|false $path_array Путь для рекурсивного размещения условия:
     *                                 - Должен быть строкой (например, "Массив1[0]->Массив1.0[0]") или `false` (по
     *                                 умолчанию).
     *                                 - Убедитесь, что путь передан в правильном формате.
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                  - Массив данных пуст.
     *                                    Пример сообщения:
     *                                        Массив данных пуст | Ожидался массив в аргументе $array_data
     *                                  - Путь (`$path_array`) имеет некорректный формат (не строка и не `false`).
     *                                    Пример сообщения:
     *                                        Некорректный формат пути | Ожидается строка или FALSE
     *                                  - Ключ массива некорректен (пустой или содержит недопустимые символы).
     *                                    Пример сообщения:
     *                                        Некорректный ключ массива | Значение: [ключ]
     *                                  - Значение массива некорректно (пустое или содержит недопустимые символы).
     *                                    Пример сообщения:
     *                                        Некорректное значение массива | Значение: [значение]
     *
     * @note    Этот метод является точкой входа для добавления данных о выборе блока. Все проверки и обработка
     *          выполняются в защищённом методе _add_case_ar_internal().
     *
     * @warning Метод чувствителен к параметру `$path_array`. Убедитесь, что он передан в правильном формате (строка
     *          или `false`). Также убедитесь, что массив данных содержит только допустимые ключи и значения.
     *          Некорректные данные могут привести к выбросу исключения.
     *
     * Пример использования:
     * @code
     * // Вызов метода из клиентского кода
     * $object = new \PhotoRigma\Classes\Template('https://example.com', '/var/www/example', 'default');
     * $data = [
     *     'BLOCK_TYPE' => 'HEADER',
     *     'BLOCK_STYLE' => 'COMPACT'
     * ];
     * $object->add_case_ar($data);
     * $object->add_case_ar($data, 'Массив1[0]->Массив1.0[0]');
     * @endcode
     * @see     PhotoRigma::Classes::Template::_add_case_ar_internal()
     *          Защищённый метод, реализующий основную логику добавления данных о выборе блока.
     */
    public function add_case_ar(array $array_data, string|bool $path_array = false): void
    {
        $this->_add_case_ar_internal($array_data, $path_array);
    }

    /**
     * @brief   Метод добавляет массив данных о выборе блока для вывода фрагментов шаблона, с возможностью рекурсивного
     *          размещения.
     *
     * @details Этот метод выполняет следующие шаги:
     *          1. Проверяет, что массив данных не пуст. Если массив пуст, выбрасывается исключение.
     *          2. Проверяет формат пути (`$path_array`), если он указан. Путь должен быть строкой или `false`.
     *          3. Для каждого элемента массива проверяет корректность ключа и значения (только латинские буквы, цифры
     *             и подчеркивания). Если ключ или значение некорректны, выбрасывается исключение.
     *          4. Добавляет каждую пару ключ-значение в шаблон с помощью метода `add_case()`.
     *          Этот метод является защищенным и предназначен для использования внутри класса или его наследников.
     *          Основная логика вызывается через публичный метод-редирект `add_case_ar()`.
     *
     * @callergraph
     * @callgraph
     *
     * @param array        $array_data Массив данных о выборе блока для вывода фрагментов шаблона. Ключи и значения
     *                                 должны содержать только латинские буквы, цифры и подчеркивания.
     *                                 Пример: ["BLOCK_TYPE" => "HEADER", "BLOCK_STYLE" => "COMPACT"].
     *                                 Ограничения: массив не может быть пустым.
     * @param string|false $path_array Путь для рекурсивного размещения условия. Должен быть строкой (например,
     *                                 "Массив1[0]->Массив1.0[0]") или `false` (по умолчанию).
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                  - Массив данных пуст.
     *                                    Пример сообщения:
     *                                        Массив данных пуст | Ожидался массив в аргументе $array_data
     *                                  - Путь (`$path_array`) имеет некорректный формат (не строка и не `false`).
     *                                    Пример сообщения:
     *                                        Некорректный формат пути | Ожидается строка или FALSE
     *                                  - Ключ массива некорректен (пустой или содержит недопустимые символы).
     *                                    Пример сообщения:
     *                                        Некорректный ключ массива | Значение: [ключ]
     *                                  - Значение массива некорректно (пустое или содержит недопустимые символы).
     *                                    Пример сообщения:
     *                                        Некорректное значение массива | Значение: [значение]
     *
     * @warning Метод особенно чувствителен к параметру `$path_array`. Убедитесь, что он передается в правильном формате
     *          (строка или `false`). Также убедитесь, что массив данных содержит только допустимые ключи и значения.
     *          Некорректные данные могут привести к выбросу исключения.
     *
     * Пример использования метода _add_case_ar_internal():
     * @code
     * // Добавление данных без указания пути
     * $this->_add_case_ar_internal([
     *     'BLOCK_TYPE' => 'HEADER',
     *     'BLOCK_STYLE' => 'COMPACT'
     * ]);
     *
     * // Добавление данных с указанием пути
     * $this->_add_case_ar_internal(
     *     [
     *         'BLOCK_TYPE' => 'HEADER',
     *         'BLOCK_STYLE' => 'COMPACT'
     *     ],
     *     'Массив1[0]->Массив1.0[0]'
     * );
     * @endcode
     * @see     PhotoRigma::Classes::Template::add_case()
     *          Метод, используемый для добавления отдельных условий выбора блока.
     * @see     PhotoRigma::Classes::Template::add_case_ar()
     *          Метод, предоставляющий публичный доступ к методу _add_case_ar_internal().
     */
    protected function _add_case_ar_internal(array $array_data, string|bool $path_array = false): void
    {
        // Проверка на пустой массив
        if (empty($array_data)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Массив данных пуст | Ожидался массив в аргументе \$array_data"
            );
        }

        // Проверка формата пути
        if ($path_array !== false && !is_string($path_array)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректный формат пути | Ожидается строка или FALSE"
            );
        }

        // Обработка массива данных
        foreach ($array_data as $key => $value) {
            if (!is_string($key) || !preg_match('/^\w+$/', $key)) {
                throw new InvalidArgumentException(
                    __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректный ключ массива | Значение: $key"
                );
            }
            if (!is_string($value) || !preg_match('/^\w+$/', $value)) {
                throw new InvalidArgumentException(
                    __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректное значение массива | Значение: $value"
                );
            }
            $this->add_case($key, $value, $path_array);
        }
    }

    /**
     * @brief   Добавляет данные о выборе блока для вывода фрагментов шаблона через вызов внутреннего метода.
     *
     * @details Этот публичный метод является обёрткой для защищённого метода _add_case_internal().
     *          Он добавляет данные о выборе блока для вывода фрагментов шаблона, с возможностью рекурсивного
     *          размещения. Метод проверяет корректность входных данных и добавляет условие в массив `block_case` или
     *          объекты в зависимости от пути. Предназначен для прямого использования извне.
     *
     * @param string       $name       Название условия:
     *                                 - Должно содержать только латинские буквы, цифры и подчеркивания.
     *                                 - Пример: "BLOCK_TYPE".
     *                                 Ограничения: не может быть пустым или содержать недопустимые символы.
     * @param string       $value      Значение условия:
     *                                 - Должно содержать только латинские буквы, цифры и подчеркивания.
     *                                 - Пример: "HEADER".
     *                                 Ограничения: не может быть пустым или содержать недопустимые символы.
     * @param string|false $path_array Путь для рекурсивного размещения условия:
     *                                 - Должен быть строкой (например, "Массив1[0]->Массив1.0[0]") или `false` (по
     *                                 умолчанию).
     *                                 - Убедитесь, что путь передан в правильном формате.
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                  - Имя условия некорректно (пустое или содержит недопустимые символы).
     *                                    Пример сообщения:
     *                                        Некорректное имя условия | Значение: [имя]
     *                                  - Значение условия некорректно (пустое или содержит недопустимые символы).
     *                                    Пример сообщения:
     *                                        Некорректное значение условия | Значение: [значение]
     *                                  - Путь (`$path_array`) имеет некорректный формат (не строка и не `false`).
     *                                    Пример сообщения:
     *                                        Некорректный формат пути | Ожидается строка или FALSE
     *                                  - Формат `next_path` некорректен (не строка и не `false`).
     *                                    Пример сообщения:
     *                                        Некорректный формат next_path | Ожидается строка или FALSE
     * @throws RuntimeException Выбрасывается, если результат метода `test_is_object()` некорректен.
     *                                  Пример сообщения:
     *                                      Некорректный результат test_is_object | Передавался путь: [путь]
     *
     * @note    Этот метод является точкой входа для добавления данных о выборе блока. Все проверки и обработка
     *          выполняются в защищённом методе _add_case_internal().
     *
     * @warning Метод чувствителен к параметру `$path_array`. Убедитесь, что он передан в правильном формате (строка
     *          или `false`). Также убедитесь, что имя и значение условия содержат только допустимые символы.
     *          Некорректные данные могут привести к выбросу исключения.
     *
     * Пример использования:
     * @code
     * // Вызов метода из клиентского кода
     * $object = new \PhotoRigma\Classes\Template('https://example.com', '/var/www/example', 'default');
     * $object->add_case('BLOCK_TYPE', 'HEADER');
     * $object->add_case('BLOCK_TYPE', 'FOOTER', 'Массив1[0]->Массив1.0[0]');
     * @endcode
     * @see     PhotoRigma::Classes::Template::_add_case_internal()
     *          Защищённый метод, реализующий основную логику добавления данных о выборе блока.
     */
    public function add_case(string $name, string $value, string|false $path_array = false): void
    {
        $this->_add_case_internal($name, $value, $path_array);
    }

    /**
     * @brief   Метод добавляет данные о выборе блока для вывода фрагментов шаблона, с возможностью рекурсивного
     *          размещения.
     *
     * @details Этот метод выполняет следующие шаги:
     *          1. Проверяет корректность имени условия (только латинские буквы, цифры и подчеркивания). Если имя
     *          некорректно, выбрасывается исключение.
     *          2. Проверяет корректность значения условия (только латинские буквы, цифры и подчеркивания). Если
     *          значение некорректно, выбрасывается исключение.
     *          3. Проверяет формат пути (`$path_array`), если он указан. Путь должен быть строкой или `false`.
     *          4. Если путь не указан, добавляет условие в массив `block_case`. Если путь указан, рекурсивно добавляет
     *          условие в объекты с использованием метода `test_is_object()`. Этот метод является защищенным и
     *          предназначен для использования внутри класса или его наследников. Основная логика вызывается через
     *          публичный метод-редирект `add_case()`.
     *
     * @callergraph
     * @callgraph
     *
     * @param string       $name       Название условия. Должно содержать только латинские буквы, цифры и
     *                                 подчеркивания.
     *                                 Пример: "BLOCK_TYPE".
     *                                 Ограничения: не может быть пустым или содержать недопустимые символы.
     * @param string       $value      Значение условия. Должно содержать только латинские буквы, цифры и
     *                                 подчеркивания.
     *                                 Пример: "HEADER".
     *                                 Ограничения: не может быть пустым или содержать недопустимые символы.
     * @param string|false $path_array Путь для рекурсивного размещения условия. Должен быть строкой (например,
     *                                 "Массив1[0]->Массив1.0[0]") или `false` (по умолчанию).
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                  - Имя условия некорректно (пустое или содержит недопустимые символы).
     *                                    Пример сообщения:
     *                                        Некорректное имя условия | Значение: [имя]
     *                                  - Значение условия некорректно (пустое или содержит недопустимые символы).
     *                                    Пример сообщения:
     *                                        Некорректное значение условия | Значение: [значение]
     *                                  - Путь (`$path_array`) имеет некорректный формат (не строка и не `false`).
     *                                    Пример сообщения:
     *                                        Некорректный формат пути | Ожидается строка или FALSE
     *                                  - Формат `next_path` некорректен (не строка и не `false`).
     *                                    Пример сообщения:
     *                                        Некорректный формат next_path | Ожидается строка или FALSE
     * @throws RuntimeException Выбрасывается, если результат метода `test_is_object()` некорректен.
     *                                  Пример сообщения:
     *                                      Некорректный результат test_is_object | Передавался путь: [путь]
     *
     * @warning Метод особенно чувствителен к параметру `$path_array`. Убедитесь, что он передается в правильном
     *          формате
     *          (строка или `false`). Также убедитесь, что имя и значение условия содержат только допустимые символы.
     *          Некорректные данные могут привести к выбросу исключения.
     *
     * Пример использования метода _add_case_internal():
     * @code
     * // Добавление условия без указания пути
     * $this->_add_case_internal('BLOCK_TYPE', 'HEADER');
     *
     * // Добавление условия с указанием пути
     * $this->_add_case_internal(
     *     'BLOCK_TYPE',
     *     'FOOTER',
     *     'Массив1[0]->Массив1.0[0]'
     * );
     * @endcode
     * @see     PhotoRigma::Classes::Template::$block_case
     *          Свойство, содержащее массив данных о выборе блока.
     * @see     PhotoRigma::Classes::Template::$block_object
     *          Свойство, содержащее объекты для рекурсивного размещения условий.
     * @see     PhotoRigma::Classes::Template::test_is_object()
     *          Метод, используемый для разбора пути.
     * @see     PhotoRigma::Classes::Template::add_case()
     *          Метод, предоставляющий публичный доступ к методу _add_case_internal().
     */
    protected function _add_case_internal(string $name, string $value, string|false $path_array = false): void
    {
        // Проверка корректности имени условия
        if (empty($name) || !preg_match('/^\w+$/', $name)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректное имя условия | Значение: $name"
            );
        }

        // Проверка корректности значения условия
        if (empty($value) || !preg_match('/^\w+$/', $value)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректное значение условия | Значение: $value"
            );
        }

        // Проверка формата пути
        if ($path_array !== false && !is_string($path_array)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректный формат пути | Ожидается строка или FALSE"
            );
        }

        // Если путь не указан, добавляем условие в массив block_case
        if (!$path_array) {
            $this->block_case['SELECT_' . strtoupper($name)] = strtoupper($value);
        } else {
            // Разбираем путь и проверяем результат
            $parsed_path = $this->test_is_object($path_array);
            if (!isset($parsed_path['current'], $parsed_path['index'])) {
                throw new RuntimeException(
                    __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректный результат test_is_object | Передавался путь: $path_array"
                );
            }

            // Проверка формата next_path
            if ($parsed_path['next_path'] !== false && !is_string($parsed_path['next_path'])) {
                throw new InvalidArgumentException(
                    __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректный формат next_path | Ожидается строка или FALSE"
                );
            }

            // Рекурсивно добавляем условие
            $this->block_object[$parsed_path['current']][$parsed_path['index']]->add_case(
                $name,
                $value,
                $parsed_path['next_path']
            );
        }
    }

    /**
     * @brief   Формирует заголовок HTML-страницы с меню, метаданными и блоками контента через вызов внутреннего
     *          метода.
     *
     * @details Этот публичный метод является обёрткой для защищённого метода _page_header_internal().
     *          Он формирует заголовок HTML-страницы, включая меню, метаданные и блоки контента, на основе переданных
     *          параметров. Метод проверяет корректность входных данных, генерирует данные для меню и фотографий, и
     *          добавляет контент в начало страницы. Предназначен для прямого использования извне.
     *
     * @param string $title      Дополнительное название страницы для тега `<title>`:
     *                           - Может быть пустым. Если пустой, используется значение из конфигурации.
     *                           - Пример: "Главная страница".
     * @param string $action     Текущее активное действие (пункт меню):
     *                           - Должно содержать только латинские буквы, цифры и подчеркивания.
     *                           - Пример: "home".
     *                           Ограничения: не может быть пустым или содержать недопустимые символы.
     * @param string $csrf_token CSRF-токен для защиты от межсайтовой подделки запросов:
     *                           - Пример: "abc123xyz".
     *                           Ограничения: параметр автоматически типизируется как строка благодаря строгой
     *                           типизации.
     *
     * @return void Метод не возвращает значений, но напрямую изменяет содержимое HTML-страницы.
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                  - Параметр `$action` некорректен (пустой или содержит недопустимые символы).
     *                                    Пример сообщения:
     *                                        Некорректный параметр $action | Значение: [значение]
     *                                  - Параметр `$csrf_token` некорректен (пустой или содержит недопустимые
     *                                  символы).
     *                                    Пример сообщения:
     *                                        Некорректный параметр $csrf_token | Значение: [значение]
     * @throws RuntimeException Выбрасывается, если возникают ошибки при обработке шаблонов или данных.
     *                                  Пример сообщения:
     *                                        Ошибка при обработке шаблона | Файл: header.html
     * @throws Exception Выбрасывается методом `create_photo()` в случае ошибок.
     *                                  Пример сообщения:
     *                                        Ошибка при генерации данных фотографий
     *
     * @note    Метод использует шаблон `header.html` для формирования заголовка. Убедитесь, что шаблон существует и
     *          доступен. Также используются следующие константы:
     *          - `LOCALHOST_SERVER`: Указывает, является ли сервер локальным. Если `true`, JS и CSS загружаются
     *          локально, чтобы избежать проблем с доступом в интернет. По умолчанию: `false`.
     *          - `SHORT_MENU`: Константа для формирования краткого меню из базы данных. Значение: `0`.
     *          - `LONG_MENU`: Константа для формирования полного меню из базы данных. Значение: `1`.
     *
     * @warning Входные параметры должны быть корректными. Особое внимание уделите параметру `$action`, так как его
     *          некорректность может привести к неправильной генерации шаблона. Невалидные данные могут привести к
     *          исключениям или ошибкам в работе метода.
     *
     * Пример использования:
     * @code
     * // Вызов метода из клиентского кода
     * $object = new \PhotoRigma\Classes\Template('https://example.com', '/var/www/example', 'default');
     * $object->page_header('Главная страница', 'home', 'abc123xyz');
     * @endcode
     * @see     PhotoRigma::Classes::Template::_page_header_internal()
     *          Защищённый метод, реализующий основную логику формирования заголовка HTML-страницы.
     */
    public function page_header(string $title, string $action, string $csrf_token): void
    {
        $this->_page_header_internal($title, $action, $csrf_token);
    }

    /**
     * @brief   Метод формирует заголовок HTML-страницы с меню, метаданными и блоками контента.
     *
     * @details Этот метод выполняет следующие шаги:
     *          1. Проверяет корректность параметра `$action`. Он должен содержать только латинские буквы, цифры и
     *             подчеркивания. Если параметр некорректен, выбрасывается исключение.
     *          2. Генерирует данные для меню и фотографий с помощью методов `create_menu()` и `create_photo()`.
     *          3. Создает экземпляр шаблона заголовка (`header.html`) и заполняет его строковыми данными, условиями и
     *             выбором блоков.
     *          4. Обрабатывает короткое и длинное меню, а также блоки с последними фотографиями:
     *             - Для короткого меню добавляет ссылки и проверяет наличие URL.
     *             - Для длинного меню добавляет название блока, ссылки и проверяет наличие URL.
     *             - Для блоков с последними фотографиями добавляет данные о фотографии, категории и пользователе.
     *          5. Устанавливает файл шаблона и создает контент, который добавляется в начало текущего содержимого
     *          страницы. Этот метод является защищенным и предназначен для использования внутри класса или его
     *          наследников. Основная логика вызывается через публичный метод-редирект `page_header()`.
     *
     * @callergraph
     * @callgraph
     *
     * @param string $title      Дополнительное название страницы для тега `<title>`. Может быть пустым.
     *                           Пример: "Главная страница".
     *                           Если пустой, используется значение из конфигурации.
     * @param string $action     Текущее активное действие (пункт меню). Должно содержать только латинские буквы, цифры
     *                           и подчеркивания.
     *                           Пример: "home".
     *                           Ограничения: не может быть пустым или содержать недопустимые символы.
     * @param string $csrf_token CSRF-токен для защиты от межсайтовой подделки запросов.
     *                           Пример: "abc123xyz".
     *                           Ограничения: параметр автоматически типизируется как строка благодаря строгой
     *                           типизации.
     *
     * @return void Метод не возвращает значений, но напрямую изменяет содержимое HTML-страницы.
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                  - Параметр `$action` некорректен (пустой или содержит недопустимые символы).
     *                                    Пример сообщения:
     *                                        Некорректный параметр $action | Значение: [значение]
     * @throws RuntimeException Выбрасывается, если возникают ошибки при обработке шаблонов или данных.
     *                                  Пример сообщения:
     *                                        Ошибка при обработке шаблона | Файл: header.html
     * @throws Exception Выбрасывается методом `create_photo()` в случае ошибок.
     *                                  Пример сообщения:
     *                                        Ошибка при генерации данных фотографий
     *
     * @note    Метод использует шаблон `header.html` для формирования заголовка. Убедитесь, что шаблон существует и
     *          доступен.
     *          Также используются следующие константы:
     *          - `LOCALHOST_SERVER`: Указывает, является ли сервер локальным. Если `true`, JS и CSS загружаются
     *          локально, чтобы избежать проблем с доступом в интернет. По умолчанию: `false`.
     *          - `SHORT_MENU`: Константа для формирования краткого меню из базы данных. Значение: `0`.
     *          - `LONG_MENU`: Константа для формирования полного меню из базы данных. Значение: `1`.
     *          Эти константы позволяют гибко настраивать поведение метода в зависимости от требований системы.
     *
     * @warning Входные параметры должны быть корректными. Невалидные данные могут привести к исключениям или ошибкам в
     *          работе метода. Особое внимание уделите параметру `$action`, так как его некорректность может привести к
     *          неправильной генерации шаблона.
     *
     * Пример использования метода _page_header_internal():
     * @code
     * // Формирование заголовка страницы
     * $this->_page_header_internal('Главная страница', 'home', 'abc123xyz');
     * @endcode
     * @see     PhotoRigma::Classes::Template::$content
     *          Свойство, содержащее текущее содержимое страницы.
     * @see     PhotoRigma::Classes::Template::add_if()
     *          Метод, используемый для добавления условий вывода фрагментов шаблона.
     * @see     PhotoRigma::Classes::Template::add_case()
     *          Метод, используемый для выбора блоков для вывода фрагментов шаблона.
     * @see     PhotoRigma::Classes::Template::create_template()
     *          Метод, используемый для создания контента из шаблона.
     * @see     PhotoRigma::Classes::Work::create_menu()
     *          Метод, используемый для генерации данных меню.
     * @see     PhotoRigma::Classes::Work::create_photo()
     *          Метод, используемый для генерации данных фотографий.
     * @see     Work::clean_field()
     *          Функция, используемая для очистки данных.
     * @see     PhotoRigma::Classes::Template::page_header()
     *          Метод, предоставляющий публичный доступ к методу _page_header_internal().
     */
    protected function _page_header_internal(string $title, string $action, string $csrf_token): void
    {
        // Проверка параметра $action
        if (!empty($action) && !preg_match('/^\w+$/', $action)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректный параметр \$action | Значение: $action"
            );
        }

        // Генерация данных для меню и фотографий
        $short_menu = $this->work->create_menu($action, SHORT_MENU);
        $long_menu = $this->work->create_menu($action, LONG_MENU);
        $top_photo = $this->work->create_photo();
        $last_photo = $this->work->create_photo('last');

        // Создание экземпляра шаблона заголовка
        $header_template = new Template($this->site_url, $this->site_dir, $this->theme);

        // Добавление условия, что скрипты и CSS требуется использовать локальные.
        $header_template->add_if('LOCALHOST_SERVER', LOCALHOST_SERVER);

        // Добавление строковых данных в шаблон
        $header_template->add_string_ar([
            'TITLE'             => empty($title) ? $this->work->config['title_name'] : Work::clean_field(
                $this->work->config['title_name']
            ) . ' - ' . Work::clean_field($title),
            'INSERT_HEADER'     => $this->ins_header,
            'META_DESRIPTION'   => Work::clean_field($this->work->config['meta_description']),
            'META_KEYWORDS'     => Work::clean_field($this->work->config['meta_keywords']),
            'GALLERY_WIDHT'     => $this->work->config['gal_width'],
            'SITE_NAME'         => Work::clean_field($this->work->config['title_name']),
            'SITE_DESCRIPTION'  => Work::clean_field($this->work->config['title_description']),
            'U_SEARCH'          => $this->work->config['site_url'] . '?action=search',
            'L_SEARCH'          => $this->work->lang['main']['search'],
            'CSRF_TOKEN'        => $csrf_token,
            'LEFT_PANEL_WIDHT'  => $this->work->config['left_panel'],
            'RIGHT_PANEL_WIDHT' => $this->work->config['right_panel'],
        ]);

        // Обработка короткого меню
        $header_template->add_if('SHORT_MENU', false);
        if ($short_menu) {
            $header_template->add_if('SHORT_MENU', true);
            foreach ($short_menu as $id => $value) {
                $header_template->add_string_ar([
                    'U_SHORT_MENU' => $value['url'] ?? '',
                    'L_SHORT_MENU' => $value['name'],
                ], 'SHORT_MENU[' . $id . ']');
                $header_template->add_if('SHORT_MENU_URL', !empty($value['url']), 'SHORT_MENU[' . $id . ']');
            }
        }

        // Обработка длинного меню
        $header_template->add_case('LEFT_BLOCK', 'MENU', 'LEFT_PANEL[0]');
        $header_template->add_if('LONG_MENU', false, 'LEFT_PANEL[0]');
        if ($long_menu) {
            $header_template->add_if('LONG_MENU', true, 'LEFT_PANEL[0]');
            $header_template->add_string(
                'LONG_MENU_NAME_BLOCK',
                $this->work->lang['menu']['name_block'],
                'LEFT_PANEL[0]'
            );
            foreach ($long_menu as $id => $value) {
                $header_template->add_string_ar([
                    'U_LONG_MENU' => $value['url'] ?? '',
                    'L_LONG_MENU' => $value['name'],
                ], 'LEFT_PANEL[0]->LONG_MENU[' . $id . ']');
                $header_template->add_if(
                    'LONG_MENU_URL',
                    !empty($value['url']),
                    'LEFT_PANEL[0]->LONG_MENU[' . $id . ']'
                );
            }
        }

        // Обработка блока с последними фотографиями
        $header_template->add_case('LEFT_BLOCK', 'TOP_LAST_PHOTO', 'LEFT_PANEL[1]');
        $header_template->add_string_ar([
            'NAME_BLOCK'             => $top_photo['name_block'],
            'PHOTO_WIDTH'            => (string)$top_photo['width'],
            'PHOTO_HEIGHT'           => (string)$top_photo['height'],
            'MAX_FOTO_HEIGHT'        => (string)($this->work->config['temp_photo_h'] + 10),
            'D_NAME_PHOTO'           => $top_photo['name'],
            'D_DESCRIPTION_PHOTO'    => $top_photo['description'],
            'D_NAME_CATEGORY'        => $top_photo['category_name'],
            'D_DESCRIPTION_CATEGORY' => $top_photo['category_description'],
            'PHOTO_RATE'             => $top_photo['rate'],
            'L_USER_ADD'             => $this->work->lang['main']['user_add'],
            'U_PROFILE_USER_ADD'     => $top_photo['url_user'],
            'D_REAL_NAME_USER_ADD'   => $top_photo['real_name'],
            'U_PHOTO'                => $top_photo['url'],
            'U_THUMBNAIL_PHOTO'      => $top_photo['thumbnail_url'],
            'U_CATEGORY'             => $top_photo['category_url'],
        ], 'LEFT_PANEL[1]');
        $header_template->add_if('USER_EXISTS', !empty($top_photo['url_user']), 'LEFT_PANEL[1]');

        // Обработка блока с последними фотографиями (второй блок)
        $header_template->add_case('LEFT_BLOCK', 'TOP_LAST_PHOTO', 'LEFT_PANEL[2]');
        $header_template->add_string_ar([
            'NAME_BLOCK'             => $last_photo['name_block'],
            'PHOTO_WIDTH'            => (string)$last_photo['width'],
            'PHOTO_HEIGHT'           => (string)$last_photo['height'],
            'MAX_FOTO_HEIGHT'        => (string)($this->work->config['temp_photo_h'] + 10),
            'D_NAME_PHOTO'           => $last_photo['name'],
            'D_DESCRIPTION_PHOTO'    => $last_photo['description'],
            'D_NAME_CATEGORY'        => $last_photo['category_name'],
            'D_DESCRIPTION_CATEGORY' => $last_photo['category_description'],
            'PHOTO_RATE'             => $last_photo['rate'],
            'L_USER_ADD'             => $this->work->lang['main']['user_add'],
            'U_PROFILE_USER_ADD'     => $last_photo['url_user'],
            'D_REAL_NAME_USER_ADD'   => $last_photo['real_name'],
            'U_PHOTO'                => $last_photo['url'],
            'U_THUMBNAIL_PHOTO'      => $last_photo['thumbnail_url'],
            'U_CATEGORY'             => $last_photo['category_url'],
        ], 'LEFT_PANEL[2]');
        $header_template->add_if('USER_EXISTS', !empty($last_photo['url_user']), 'LEFT_PANEL[2]');

        // Установка файла шаблона и создание контента
        $header_template->template_file = $this->themes_path . 'header.html';
        $header_template->create_template();
        $this->content = $header_template->content . $this->content;
        unset($header_template);
    }

    /**
     * @brief   Добавляет массив строковых данных для замены в шаблоне через вызов внутреннего метода.
     *
     * @details Этот публичный метод является обёрткой для защищённого метода _add_string_ar_internal().
     *          Он добавляет массив строковых данных для замены в шаблоне, с возможностью рекурсивного размещения.
     *          Метод проверяет корректность входных данных и использует метод `add_string()` для добавления каждой
     *          пары ключ-значение. Предназначен для прямого использования извне.
     *
     * @param array        $array_data Массив данных:
     *                                 - Ключи должны содержать только латинские буквы, цифры и подчеркивания.
     *                                 - Значения должны быть строками.
     *                                 - Пример: ["TITLE" => "Welcome to the Site", "HEADER_TITLE" => "Main Page"].
     *                                 Ограничения: массив не может быть пустым.
     * @param string|false $path_array Путь для рекурсивного размещения переменных:
     *                                 - Должен быть строкой (например, "Массив1[0]->Массив1.0[0]") или `false` (по
     *                                 умолчанию).
     *                                 - Убедитесь, что путь передан в правильном формате.
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                  - Массив данных пуст.
     *                                    Пример сообщения:
     *                                        Массив данных пуст | Ожидался массив в аргументе $array_data
     *                                  - Путь (`$path_array`) имеет некорректный формат (не строка и не `false`).
     *                                    Пример сообщения:
     *                                        Некорректный формат пути | Ожидается строка или FALSE
     *                                  - Ключ массива некорректен (пустой или содержит недопустимые символы).
     *                                    Пример сообщения:
     *                                        Некорректный ключ массива | Значение: [ключ]
     *                                  - Значение массива не является строкой.
     *                                    Пример сообщения:
     *                                        Некорректное значение массива | Значение: [ключ] = [значение]
     *
     * @note    Этот метод является точкой входа для добавления строковых данных. Все проверки и обработка выполняются
     *          в
     *          защищённом методе _add_string_ar_internal().
     *
     * @warning Метод чувствителен к параметру `$path_array`. Убедитесь, что он передан в правильном формате (строка
     *          или `false`). Также убедитесь, что массив данных содержит только допустимые ключи и строковые значения.
     *          Некорректные данные могут привести к выбросу исключения.
     *
     * Пример использования:
     * @code
     * // Вызов метода из клиентского кода
     * $object = new \PhotoRigma\Classes\Template('https://example.com', '/var/www/example', 'default');
     * $data = [
     *     'TITLE' => 'Welcome to the Site',
     *     'HEADER_TITLE' => 'Main Page'
     * ];
     * $object->add_string_ar($data);
     * $object->add_string_ar($data, 'Массив1[0]->Массив1.0[0]');
     * @endcode
     * @see     PhotoRigma::Classes::Template::_add_string_ar_internal()
     *          Защищённый метод, реализующий основную логику добавления строковых данных для замены в шаблоне.
     */
    public function add_string_ar(array $array_data, string|false $path_array = false): void
    {
        $this->_add_string_ar_internal($array_data, $path_array);
    }

    /**
     * @brief   Метод добавляет массив строковых данных для замены в шаблоне, с возможностью рекурсивного размещения.
     *
     * @details Этот метод выполняет следующие шаги:
     *          1. Проверяет, что массив данных не пуст. Если массив пуст, выбрасывается исключение.
     *          2. Проверяет формат пути (`$path_array`), если он указан. Путь должен быть строкой или `false`.
     *          3. Для каждого элемента массива проверяет корректность ключа (только латинские буквы, цифры и
     *             подчеркивания) и значения (строка). Если ключ или значение некорректны, выбрасывается исключение.
     *          4. Добавляет каждую пару ключ-значение в шаблон с помощью метода `add_string()`.
     *          Этот метод является защищенным и предназначен для использования внутри класса или его наследников.
     *          Основная логика вызывается через публичный метод-редирект `add_string_ar()`.
     *
     * @callergraph
     * @callgraph
     *
     * @param array        $array_data Массив данных. Ключи должны содержать только латинские буквы, цифры и
     *                                 подчеркивания. Значения должны быть строками.
     *                                 Пример: ["TITLE" => "Welcome to the Site", "HEADER_TITLE" => "Main Page"].
     *                                 Ограничения: массив не может быть пустым.
     * @param string|false $path_array Путь для рекурсивного размещения переменных. Должен быть строкой (например,
     *                                 "Массив1[0]->Массив1.0[0]") или `false` (по умолчанию).
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                  - Массив данных пуст.
     *                                    Пример сообщения:
     *                                        Массив данных пуст | Ожидался массив в аргументе $array_data
     *                                  - Путь (`$path_array`) имеет некорректный формат (не строка и не `false`).
     *                                    Пример сообщения:
     *                                        Некорректный формат пути | Ожидается строка или FALSE
     *                                  - Ключ массива некорректен (пустой или содержит недопустимые символы).
     *                                    Пример сообщения:
     *                                        Некорректный ключ массива | Значение: [ключ]
     *                                  - Значение массива не является строкой.
     *                                    Пример сообщения:
     *                                        Некорректное значение массива | Значение: [ключ] = [значение]
     *
     * @warning Метод особенно чувствителен к параметру `$path_array`. Убедитесь, что он передается в правильном формате
     *          (строка или `false`). Также убедитесь, что массив данных содержит только допустимые ключи и строковые
     *          значения. Некорректные данные могут привести к выбросу исключения.
     *
     * Пример использования метода _add_string_ar_internal():
     * @code
     * // Добавление данных без указания пути
     * $this->_add_string_ar_internal([
     *     'TITLE' => 'Welcome to the Site',
     *     'HEADER_TITLE' => 'Main Page'
     * ]);
     *
     * // Добавление данных с указанием пути
     * $this->_add_string_ar_internal(
     *     [
     *         'TITLE' => 'Welcome to the Site',
     *         'HEADER_TITLE' => 'Main Page'
     *     ],
     *     'Массив1[0]->Массив1.0[0]'
     * );
     * @endcode
     * @see     PhotoRigma::Classes::Template::add_string()
     *          Метод, используемый для добавления отдельных строковых переменных.
     * @see     PhotoRigma::Classes::Template::add_string_ar()
     *          Метод, предоставляющий публичный доступ к методу _add_string_ar_internal().
     */
    protected function _add_string_ar_internal(array $array_data, string|false $path_array = false): void
    {
        // Проверка на пустой массив
        if (empty($array_data)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Массив данных пуст | Ожидался массив в аргументе \$array_data"
            );
        }

        // Проверка формата пути
        if ($path_array !== false && !is_string($path_array)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректный формат пути | Ожидается строка или FALSE"
            );
        }

        // Обработка массива данных
        foreach ($array_data as $key => $value) {
            if (!is_string($key) || !preg_match('/^\w+$/', $key)) {
                throw new InvalidArgumentException(
                    __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректный ключ массива | Значение: $key"
                );
            }
            if (!is_string($value)) {
                throw new InvalidArgumentException(
                    __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректное значение массива | Значение: $key = $value"
                );
            }
            $this->add_string($key, $value, $path_array);
        }
    }

    /**
     * @brief   Добавляет строковую переменную для замены в шаблоне через вызов внутреннего метода.
     *
     * @details Этот публичный метод является обёрткой для защищённого метода _add_string_internal().
     *          Он добавляет строковую переменную для замены в шаблоне, с возможностью рекурсивного размещения.
     *          Метод проверяет корректность входных данных и добавляет переменную в массив `block_string` или объекты
     *          в зависимости от пути. Предназначен для прямого использования извне.
     *
     * @param string       $name       Название переменной:
     *                                 - Должно содержать только латинские буквы, цифры и подчеркивания.
     *                                 - Пример: "TITLE".
     *                                 Ограничения: не может быть пустым или содержать недопустимые символы.
     * @param string       $value      Значение переменной:
     *                                 - Должно быть строкой.
     *                                 - Пример: "Welcome to the Site".
     *                                 Ограничения: не может быть пустым.
     * @param string|false $path_array Путь для рекурсивного размещения переменной:
     *                                 - Должен быть строкой (например, "header.block") или `false` (по умолчанию).
     *                                 - Убедитесь, что путь передан в правильном формате.
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                  - Имя переменной некорректно (пустое или содержит недопустимые символы).
     *                                    Пример сообщения:
     *                                        Некорректное имя переменной | Значение: [имя]
     *                                  - Значение переменной не является строкой.
     *                                    Пример сообщения:
     *                                        Некорректное значение переменной | Значение: [имя] = [значение]
     *                                  - Путь (`$path_array`) имеет некорректный формат (не строка и не `false`).
     *                                    Пример сообщения:
     *                                        Некорректный формат пути | Ожидается строка или FALSE
     * @throws RuntimeException Выбрасывается, если результат метода `test_is_object()` некорректен.
     *                                  Пример сообщения:
     *                                      Некорректный результат test_is_object | Передавался путь: [путь]
     *
     * @note    Этот метод является точкой входа для добавления строковых переменных. Все проверки и обработка
     *          выполняются в защищённом методе _add_string_internal().
     *
     * @warning Метод чувствителен к параметру `$path_array`. Убедитесь, что он передан в правильном формате (строка
     *          или `false`). Также убедитесь, что имя переменной и её значение содержат допустимые символы.
     *          Некорректные данные могут привести к выбросу исключения.
     *
     * Пример использования:
     * @code
     * // Вызов метода из клиентского кода
     * $object = new \PhotoRigma\Classes\Template('https://example.com', '/var/www/example', 'default');
     * $object->add_string('TITLE', 'Welcome to the Site');
     * $object->add_string('HEADER_TITLE', 'Main Page', 'header.block');
     * @endcode
     * @see     PhotoRigma::Classes::Template::_add_string_internal()
     *          Защищённый метод, реализующий основную логику добавления строковых переменных для замены в шаблоне.
     */
    public function add_string(string $name, string $value, string|false $path_array = false): void
    {
        $this->_add_string_internal($name, $value, $path_array);
    }

    /**
     * @brief   Метод добавляет строковую переменную для замены в шаблоне, с возможностью рекурсивного размещения.
     *
     * @details Этот метод выполняет следующие шаги:
     *          1. Проверяет корректность имени переменной (только латинские буквы, цифры и подчеркивания). Если имя
     *             некорректно, выбрасывается исключение.
     *          2. Проверяет, что значение является строкой. Если значение некорректно, выбрасывается исключение.
     *          3. Если указан путь (`$path_array`), проверяет его формат (строка или `false`) и разбирает с помощью
     *             метода `test_is_object()`. Если результат разбора некорректен, выбрасывается исключение.
     *          4. Если путь не указан, добавляет переменную в массив `block_string`. Если путь указан, рекурсивно
     *             добавляет переменную в объекты.
     *          Этот метод является защищенным и предназначен для использования внутри класса или его наследников.
     *          Основная логика вызывается через публичный метод-редирект `add_string()`.
     *
     * @callergraph
     * @callgraph
     *
     * @param string       $name       Название переменной. Должно содержать только латинские буквы, цифры и
     *                                 подчеркивания. Пример: "TITLE". Ограничения: не может быть пустым или содержать
     *                                 недопустимые символы.
     * @param string       $value      Значение переменной. Должно быть строкой.
     *                                 Пример: "Welcome to the Site".
     *                                 Ограничения: не может быть пустым.
     * @param string|false $path_array Путь для рекурсивного размещения переменной. Должен быть строкой (например,
     *                                 "header.block") или `false` (по умолчанию).
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                  - Имя переменной некорректно (пустое или содержит недопустимые символы).
     *                                    Пример сообщения:
     *                                        Некорректное имя переменной | Значение: [имя]
     *                                  - Значение переменной не является строкой.
     *                                    Пример сообщения:
     *                                        Некорректное значение переменной | Значение: [имя] = [значение]
     *                                  - Путь (`$path_array`) имеет некорректный формат (не строка и не `false`).
     *                                    Пример сообщения:
     *                                        Некорректный формат пути | Ожидается строка или FALSE
     * @throws RuntimeException Выбрасывается, если результат метода `test_is_object()` некорректен.
     *                                  Пример сообщения:
     *                                      Некорректный результат test_is_object | Передавался путь: [путь]
     *
     * @warning Метод особенно чувствителен к параметру `$path_array`. Убедитесь, что он передается в правильном
     *          формате
     *          (строка или `false`). Также убедитесь, что имя переменной и её значение содержат допустимые символы.
     *          Некорректные данные могут привести к выбросу исключения.
     *
     * Пример использования метода _add_string_internal():
     * @code
     * // Добавление переменной без указания пути
     * $this->_add_string_internal('TITLE', 'Welcome to the Site');
     *
     * // Добавление переменной с указанием пути
     * $this->_add_string_internal(
     *     'HEADER_TITLE',
     *     'Main Page',
     *     'header.block'
     * );
     * @endcode
     * @see     PhotoRigma::Classes::Template::$block_string
     *          Свойство, содержащее массив строковых переменных.
     * @see     PhotoRigma::Classes::Template::$block_object
     *          Свойство, содержащее объекты для рекурсивного размещения переменных.
     * @see     PhotoRigma::Classes::Template::test_is_object()
     *          Метод, используемый для разбора пути.
     * @see     PhotoRigma::Classes::Template::add_string()
     *          Метод, предоставляющий публичный доступ к методу _add_string_internal().
     */
    protected function _add_string_internal(string $name, string $value, string|false $path_array = false): void
    {
        // Проверка корректности имени переменной
        if (empty($name) || !preg_match('/^\w+$/', $name)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректное имя переменной | Значение: $name"
            );
        }

        // Проверка формата пути
        if ($path_array !== false && !is_string($path_array)) {
            throw new InvalidArgumentException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректный формат пути | Ожидается строка или FALSE"
            );
        }

        // Если путь не указан, добавляем переменную в массив block_string
        if (!$path_array) {
            $this->block_string[strtoupper($name)] = $value;
        } else {
            // Разбираем путь и проверяем результат
            $parsed_path = $this->test_is_object($path_array);
            if (!isset($parsed_path['current'], $parsed_path['index'])) {
                throw new RuntimeException(
                    __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректный результат test_is_object | Передавался путь: $path_array"
                );
            }

            // Рекурсивно добавляем переменную
            $this->block_object[$parsed_path['current']][$parsed_path['index']]->add_string(
                $name,
                $value,
                $parsed_path['next_path']
            );
        }
    }

    /**
     * @brief   Создает и обрабатывает шаблон через вызов внутреннего метода.
     *
     * @details Этот публичный метод является обёрткой для защищённого метода _create_template_internal().
     *          Он выполняет чтение файла шаблона, парсинг его содержимого и замену плейсхолдеров `{SITE_URL}` и
     *          `{THEME_URL}` на реальные значения. Предназначен для прямого использования извне.
     *
     * @throws RuntimeException Выбрасывается, если:
     *                          - Произошла ошибка при чтении файла шаблона.
     *                            Пример сообщения:
     *                                Ошибка при чтении файла шаблона | Путь: [путь]
     *                          - Файл шаблона пуст или содержит только пробелы.
     *                            Пример сообщения:
     *                                Файл шаблона пуст или содержит только пробелы | Путь: [путь]
     *
     * @note    Этот метод является точкой входа для создания и обработки шаблона. Все проверки и обработка выполняются
     *          в защищённом методе _create_template_internal().
     *
     * @warning Метод чувствителен к корректности пути к файлу шаблона (`$template_file`) и его содержимому. Убедитесь,
     *          что файл существует, доступен для чтения и содержит допустимые данные.
     *
     * Пример использования:
     * @code
     * // Вызов метода из клиентского кода
     * $object = new \PhotoRigma\Classes\Template('https://example.com', '/var/www/example', 'default');
     * $object->create_template();
     * @endcode
     * @see     PhotoRigma::Classes::Template::_create_template_internal()
     *          Защищённый метод, реализующий основную логику создания и обработки шаблона.
     */
    public function create_template(): void
    {
        $this->_create_template_internal();
    }

    /**
     * @brief   Метод создает и обрабатывает шаблон, включая чтение файла, парсинг и замену плейсхолдеров.
     *
     * @details Этот метод выполняет следующие шаги:
     *          1. Читает содержимое файла шаблона с помощью функции `file_get_contents()`.
     *          2. Проверяет, что файл не пустой и содержит данные (кроме пробелов). Если файл пуст или содержит только
     *             пробелы, выбрасывается исключение.
     *          3. Заменяет плейсхолдеры `{SITE_URL}` и `{THEME_URL}` на реальные значения с использованием функции
     *             `Work::clean_field()`.
     *          4. Выполняет парсинг шаблона с помощью метода `pars_template()`.
     *          Этот метод является защищенным и предназначен для использования внутри класса или его наследников.
     *          Основная логика вызывается через публичный метод-редирект `create_template()`.
     *
     * @callergraph
     * @callgraph
     *
     * @throws RuntimeException Выбрасывается, если:
     *                                  - Произошла ошибка при чтении файла шаблона.
     *                                    Пример сообщения:
     *                                        Ошибка при чтении файла шаблона | Путь: [путь]
     *                                  - Файл шаблона пуст или содержит только пробелы.
     *                                    Пример сообщения:
     *                                        Файл шаблона пуст или содержит только пробелы | Путь: [путь]
     *
     * @warning Метод чувствителен к корректности пути к файлу шаблона (`$template_file`) и его содержимому. Убедитесь,
     *          что файл существует, доступен для чтения и содержит допустимые данные.
     *
     * Пример использования метода _create_template_internal():
     * @code
     * // Создание и обработка шаблона
     * $this->_create_template_internal();
     * @endcode
     * @see     PhotoRigma::Classes::Template::pars_template()
     *          Метод, используемый для парсинга шаблона.
     * @see     PhotoRigma::Classes::Work::clean_field()
     *          Внешняя функция, используемая для очистки данных.
     * @see     PhotoRigma::Classes::Template::$template_file
     *          Свойство, содержащее путь к файлу шаблона.
     * @see     PhotoRigma::Classes::Template::$content
     *          Свойство, содержащее содержимое шаблона после обработки.
     * @see     PhotoRigma::Classes::Template::create_template()
     *          Метод, предоставляющий публичный доступ к методу _create_template_internal().
     */
    protected function _create_template_internal(): void
    {
        $this->content = file_get_contents($this->template_file);

        // Проверяем, что файл не пустой и содержит данные || trim($this->content) === ''
        if (!$this->content) {
            throw new RuntimeException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Файл шаблона пуст или содержит только пробелы | Путь: $this->template_file"
            );
        }

        // Заменяем плейсхолдеры на реальные значения с использованием Work::clean_field
        $this->content = str_replace('{SITE_URL}', Work::clean_field($this->site_url), $this->content);
        $this->content = str_replace('{THEME_URL}', Work::clean_field($this->themes_url), $this->content);

        // Парсим шаблон
        $this->pars_template();
    }

    /**
     * @brief   Метод обрабатывает шаблон для подготовки его к выводу: рекурсивно обрабатывает объектные блоки, условия
     *          вывода, выбор блоков, заменяет строковые переменные, модифицирует URL и нормализует переносы строк.
     *
     * @details Этот метод выполняет следующие шаги:
     *          1. Проверяет корректность содержимого шаблона (`$this->content`):
     *             - Содержимое должно быть непустой строкой.
     *             - Если содержимое некорректно, выбрасывается исключение.
     *          2. Рекурсивно обрабатывает объектные блоки (`$this->block_object`) в цикле с помощью метода
     *          `template_object()`.
     *          3. Обрабатывает условия вывода (`$this->block_if`) в цикле с помощью метода `template_if()`.
     *          4. Обрабатывает выбор блоков (`$this->block_case`) в цикле с помощью метода `template_case()`.
     *          5. Заменяет строковые переменные (`$this->block_string`) в содержимом шаблона с помощью `str_replace`.
     *          6. Модифицирует URL в содержимом с помощью метода `url_mod_rewrite()`.
     *          7. Нормализует переносы строк в содержимом с помощью регулярного выражения `/\\R+/`.
     *          Метод является приватным и предназначен только для использования внутри класса.
     *
     * @callergraph
     * @callgraph
     *
     * @throws RuntimeException Выбрасывается, если содержимое шаблона некорректно (не является непустой строкой).
     *                                  Пример сообщения:
     *                                      Некорректное содержимое шаблона | Значение должно быть непустой строкой
     *
     * @note    Метод выполняет комплексную обработку шаблона, включая рекурсивную обработку блоков, замену переменных,
     *          модификацию URL и нормализацию переносов строк.
     *
     * @warning Убедитесь, что содержимое шаблона (`$this->content`) является непустой строкой перед вызовом метода.
     *          Некорректное содержимое вызовет исключение.
     *
     * Пример вызова метода внутри класса:
     * @code
     * $this->pars_template();
     * @endcode
     * @see     PhotoRigma::Classes::Template::$block_if
     *         Свойство, содержащее массив условий.
     * @see     PhotoRigma::Classes::Template::$block_case
     *         Свойство, содержащее массив выбора блоков.
     * @see     PhotoRigma::Classes::Template::$block_string
     *         Свойство, содержащее массив строковых переменных.
     * @see     PhotoRigma::Classes::Template::$block_object
     *         Свойство, содержащее массив объектных блоков.
     * @see     PhotoRigma::Classes::Template::template_object()
     *         Метод, используемый для обработки объектных блоков.
     * @see     PhotoRigma::Classes::Template::template_if()
     *         Метод, используемый для обработки условий.
     * @see     PhotoRigma::Classes::Template::template_case()
     *         Метод, используемый для обработки выбора блоков.
     * @see     PhotoRigma::Classes::Template::url_mod_rewrite()
     *         Метод, используемый для модификации URL.
     */
    private function pars_template(): void
    {
        // Проверка, что $this->content является строкой и не пустая
        if (empty($this->content)) {
            throw new RuntimeException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректное содержимое шаблона | Значение должно быть непустой строкой"
            );
        }
        // Обработка блоков объектов
        foreach ($this->block_object as $key => $val) {
            $this->template_object($key, $val);
        }
        // Обработка условий
        foreach ($this->block_if as $key => $val) {
            $this->template_if($key, $val);
        }
        // Обработка выбора блоков
        foreach ($this->block_case as $key => $val) {
            $this->template_case($key, $val);
        }
        // Замена строковых переменных
        foreach ($this->block_string as $key => $val) {
            $this->content = str_replace('{' . $key . '}', $val, $this->content);
        }
        // Модификация URL
        $this->content = $this->url_mod_rewrite($this->content);
        // Нормализация переносов строк
        $this->content = preg_replace('/\R+/', PHP_EOL, $this->content);
    }

    /**
     * @brief   Метод выполняет рекурсивную обработку блока массивов-объектов, подготавливая их содержимое для вывода
     *          между тегами `<!-- ARRAY_НАЗВАНИЕ_BEGIN -->` и `<!-- ARRAY_НАЗВАНИЕ_END -->`.
     *
     * @details Этот метод выполняет следующие шаги:
     *          1. Проверяет корректность содержимого шаблона (`$this->content`):
     *             - Содержимое должно быть непустой строкой.
     *             - Если содержимое некорректно, выбрасывается исключение.
     *          2. Формирует ключи для поиска блоков в шаблоне: `<!-- ARRAY_НАЗВАНИЕ_BEGIN -->` и `<!--
     *             ARRAY_НАЗВАНИЕ_END -->`.
     *          3. Использует регулярное выражение с флагом `/s` (single-line mode) для поиска всех блоков, заключенных
     *             между этими тегами.
     *          4. Для каждого элемента массива `$index` проверяет, что он является объектом и имеет метод
     *             `pars_template()`.
     *          5. Рекурсивно обрабатывает содержимое каждого объекта с помощью метода `pars_template()`:
     *             - Содержимое между тегами (`$matches[1]`) передается каждому объекту.
     *             - Результаты объединяются и заменяют найденные блоки в шаблоне.
     *          6. Если остались незакрытые или несоответствующие теги, выбрасывается исключение.
     *          Метод является приватным и предназначен только для использования внутри класса.
     *
     * @callergraph
     * @callgraph
     *
     * @param string $key   Ключ-название фрагмента заменяемого блока.
     *                      Должен быть строкой, соответствующей имени блока в шаблоне (например, `НАЗВАНИЕ` для тегов
     *                      `<!-- ARRAY_НАЗВАНИЕ_BEGIN -->`).
     *                      Пример: 'EXAMPLE_BLOCK'.
     * @param array  $index Индекс-блок элементов для рекурсивной замены.
     *                      Должен быть массивом объектов, каждый из которых имеет метод `pars_template()`.
     *                      Пример: [$object1, $object2].
     *
     * @throws RuntimeException Выбрасывается, если:
     *                                  - Содержимое шаблона некорректно (не является непустой строкой).
     *                                    Пример сообщения:
     *                                        Некорректное содержимое шаблона | Значение должно быть непустой строкой
     *                                  - Объекты в индексе имеют неверный формат (не являются объектами или не имеют
     *                                  метода
     *                                    `pars_template()`).
     *                                    Пример сообщения:
     *                                        Некорректный объект в индексе | ID: [$id]
     *                                  - Остались незакрытые или несоответствующие теги после обработки.
     *                                    Пример сообщения:
     *                                        Ошибка обработки блока объектов | Незакрытые или несоответствующие теги
     *                                        для ключа: [$key]
     *
     * @note    Метод выполняет рекурсивную обработку блоков, заменяя содержимое между тегами на результаты обработки
     *          каждого объекта.
     *
     * @warning Убедитесь, что:
     *          - Содержимое шаблона (`$this->content`) является непустой строкой.
     *          - Все элементы массива `$index` являются объектами и имеют метод `pars_template()`.
     *          - Теги `<!-- ARRAY_НАЗВАНИЕ_BEGIN -->` и `<!-- ARRAY_НАЗВАНИЕ_END -->` правильно закрыты.
     *          Несоблюдение этих условий вызовет исключение.
     *
     * Пример вызова метода внутри класса:
     * @code
     * $this->template_object('EXAMPLE_BLOCK', $this->block_object['EXAMPLE_BLOCK']);
     * @endcode
     * @see     PhotoRigma::Classes::Template::pars_template()
     *         Метод, используемый для рекурсивной обработки объектов.
     * @see     PhotoRigma::Classes::Template::$content
     *         Свойство, содержащее содержимое шаблона.
     */
    private function template_object(string $key, array $index): void
    {
        // Проверка, что $this->content является строкой и не пустая
        if (empty($this->content)) {
            throw new RuntimeException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректное содержимое шаблона | Значение должно быть непустой строкой"
            );
        }
        // Формирование ключей для поиска
        $begin_tag = '<!-- ARRAY_' . $key . '_BEGIN -->';
        $end_tag = '<!-- ARRAY_' . $key . '_END -->';
        // Регулярное выражение для поиска всех блоков
        $pattern = '/' . preg_quote($begin_tag, '/') . '(.*?)' . preg_quote($end_tag, '/') . '/s';
        // Поиск всех блоков
        $this->content = preg_replace_callback($pattern, static function ($matches) use ($index) {
            $block_content = '';
            $temp_content = $matches[1];
            // Проверка, что $index содержит только объекты с методом pars_template
            foreach ($index as $id => $value) {
                if (!is_object($value) || !method_exists($value, 'pars_template')) {
                    throw new RuntimeException(
                        __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректный объект в индексе | ID: $id"
                    );
                }
                // Обработка содержимого для каждого объекта
                $value->content = $temp_content;
                $value->pars_template();
                $block_content .= $value->content;
            }
            return $block_content;
        }, $this->content);
        // Если остались незакрытые теги, выбрасываем исключение
        if (str_contains($this->content, $begin_tag) || str_contains($this->content, $end_tag)) {
            throw new RuntimeException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Ошибка обработки блока объектов | Незакрытые или несоответствующие теги для ключа: $key"
            );
        }
    }

    /**
     * @brief   Метод обрабатывает блоки условий вывода фрагментов шаблона, выбирая содержимое до `_ELSE` или после
     *          него
     *          в зависимости от значения условия.
     *
     * @details Этот метод выполняет следующие шаги:
     *          1. Проверяет корректность содержимого шаблона (`$this->content`):
     *             - Содержимое должно быть непустой строкой.
     *             - Если содержимое некорректно, выбрасывается исключение.
     *          2. Формирует ключи для поиска блоков в шаблоне: `<!-- IF_НАЗВАНИЕ_BEGIN -->`, `<!-- IF_НАЗВАНИЕ_ELSE
     *          -->` и `<!-- IF_НАЗВАНИЕ_END -->`.
     *          3. Использует регулярное выражение с флагом `/s` (single-line mode) для поиска всех блоков, заключенных
     *             между этими тегами.
     *          4. Разделяет содержимое блока на две части:
     *             - `$matches[1]` — содержимое до `_ELSE` или `_END`.
     *             - `$matches[3]` — содержимое после `_ELSE` (если есть).
     *          5. Выбирает содержимое в зависимости от значения `$val`:
     *             - Если `$val` равно `true`, используется содержимое до `_ELSE` или `_END`.
     *             - Если `$val` равно `false`, используется содержимое после `_ELSE` (если есть).
     *          6. Заменяет найденные блоки в шаблоне на выбранное содержимое, удаляя лишние пробелы с помощью
     *          `trim()`.
     *          7. Если остались незакрытые или несоответствующие теги, выбрасывается исключение.
     *          Метод является приватным и предназначен только для использования внутри класса.
     *
     * @callergraph
     * @callgraph
     *
     * @param string $key Ключ-название условия.
     *                    Должен быть строкой, соответствующей имени условия в шаблоне (например, `IF_EXAMPLE`).
     *                    Пример: 'IF_EXAMPLE'.
     * @param bool   $val Значение условия.
     *                    Определяет, какая часть блока будет использована:
     *                    - `true` — содержимое до `_ELSE` или `_END`.
     *                    - `false` — содержимое после `_ELSE` (если есть).
     *                    Пример: `true`.
     *
     * @throws RuntimeException Выбрасывается, если:
     *                                  - Содержимое шаблона некорректно (не является непустой строкой).
     *                                    Пример сообщения:
     *                                        Некорректное содержимое шаблона | Значение должно быть непустой строкой
     *                                  - Остались незакрытые или несоответствующие теги после обработки.
     *                                    Пример сообщения:
     *                                        Ошибка обработки блока условий | Незакрытые или несоответствующие теги
     *                                        для ключа: [$key]
     *
     * @note    Метод выполняет выбор содержимого между тегами в зависимости от значения условия `$val`.
     *          Лишние пробелы в содержимом удаляются с помощью `trim()`.
     *
     * @warning Убедитесь, что:
     *          - Содержимое шаблона (`$this->content`) является непустой строкой.
     *          - Теги `<!-- IF_НАЗВАНИЕ_BEGIN -->`, `<!-- IF_НАЗВАНИЕ_ELSE -->` и `<!-- IF_НАЗВАНИЕ_END -->` правильно
     *          закрыты. Несоблюдение этих условий вызовет исключение.
     *
     * Пример вызова метода внутри класса:
     * @code
     * $this->template_if('IF_EXAMPLE', true);
     * @endcode
     * @see     PhotoRigma::Classes::Template::$content
     *         Свойство, содержащее содержимое шаблона.
     */
    private function template_if(string $key, bool $val): void
    {
        // Проверка, что $this->content является строкой и не пустая
        if (empty($this->content)) {
            throw new RuntimeException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректное содержимое шаблона | Значение должно быть непустой строкой"
            );
        }
        // Формирование ключей для поиска
        $begin_tag = '<!-- ' . $key . '_BEGIN -->';
        $else_tag = '<!-- ' . $key . '_ELSE -->';
        $end_tag = '<!-- ' . $key . '_END -->';
        // Регулярное выражение для поиска всех блоков
        $pattern = '/' . preg_quote($begin_tag, '/') . '(.*?)' . '(' . preg_quote(
            $else_tag,
            '/'
        ) . '(.*?))?' . preg_quote($end_tag, '/') . '/s';
        // Поиск всех блоков
        $this->content = preg_replace_callback($pattern, static function ($matches) use ($val) {
            // $matches[1] — содержимое до ELSE или END
            // $matches[3] — содержимое после ELSE (если есть)
            $true_content = trim($matches[1]);
            $false_content = isset($matches[3]) ? trim($matches[3]) : '';
            // Выбор содержимого в зависимости от значения $val
            return $val ? $true_content : $false_content;
        }, $this->content);
        // Если остались незакрытые теги, выбрасываем исключение
        if (str_contains($this->content, $begin_tag) || str_contains($this->content, $end_tag)) {
            throw new RuntimeException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Ошибка обработки блока условий | Незакрытые или несоответствующие теги для ключа: $key"
            );
        }
    }

    /**
     * @brief   Метод обрабатывает блок выбора фрагмента шаблона, выбирая один из блоков `CASE_ЗНАЧЕНИЕ` или
     *          `CASE_DEFAULT` в зависимости от значения условия.
     *
     * @details Этот метод выполняет следующие шаги:
     *          1. Проверяет корректность содержимого шаблона (`$this->content`):
     *             - Содержимое должно быть непустой строкой.
     *             - Если содержимое некорректно, выбрасывается исключение.
     *          2. Формирует ключи для поиска блоков в шаблоне: `<!-- SELECT_НАЗВАНИЕ_BEGIN -->` и `<!--
     *             SELECT_НАЗВАНИЕ_END -->`.
     *          3. Использует регулярное выражение с флагом `/s` (single-line mode) для поиска всех блоков, заключенных
     *             между этими тегами.
     *          4. Проверяет, что внутри блока нет вложенных блоков (вложенные блоки не допускаются).
     *          5. Ищет блоки `<!-- CASE_ЗНАЧЕНИЕ -->` и `<!-- BREAK_ЗНАЧЕНИЕ -->`, соответствующие значению `$val`.
     *             - Для поиска всех блоков `CASE_ЗНАЧЕНИЕ` используется `preg_match_all`.
     *          6. Если блок с указанным значением не найден, используется блок `<!-- CASE_DEFAULT -->` (если он
     *             существует). Для его поиска используется `preg_match`.
     *          7. Заменяет найденный блок на его содержимое.
     *          8. Если остались незакрытые или несоответствующие теги, выбрасывается исключение.
     *          Метод является приватным и предназначен только для использования внутри класса.
     *
     * @callergraph
     * @callgraph
     *
     * @param string $key Ключ-название условия.
     *                    Должен быть строкой, соответствующей имени условия в шаблоне (например, `SELECT_EXAMPLE`).
     *                    Пример: 'SELECT_EXAMPLE'.
     * @param string $val Значение условия.
     *                    Определяет, какой блок `CASE_ЗНАЧЕНИЕ` будет выбран для вывода. Если блок не найден,
     *                    используется `CASE_DEFAULT`.
     *                    Пример: 'VALUE1'.
     *
     * @throws RuntimeException Выбрасывается, если:
     *                                  - Содержимое шаблона некорректно (не является непустой строкой).
     *                                    Пример сообщения:
     *                                        Некорректное содержимое шаблона | Значение должно быть непустой строкой
     *                                  - Обнаружены вложенные блоки внутри `SELECT_НАЗВАНИЕ`.
     *                                    Пример сообщения:
     *                                        Ошибка обработки блока выбора | Вложенные блоки не допускаются для ключа:
     *                                        [$key], значение: [$val]
     *                                  - Остались незакрытые или несоответствующие теги после обработки.
     *                                    Пример сообщения:
     *                                        Ошибка обработки блока выбора | Незакрытые или несоответствующие теги для
     *                                        ключа: [$key], значение: [$val]
     *
     * @note    Метод выполняет выбор одного из блоков `CASE_ЗНАЧЕНИЕ` или `CASE_DEFAULT` в зависимости от значения
     *          `$val`. Если блок `CASE_ЗНАЧЕНИЕ` не найден, используется блок `CASE_DEFAULT` (если он существует).
     *
     * @warning Убедитесь, что:
     *          - Содержимое шаблона (`$this->content`) является непустой строкой.
     *          - Внутри блока `SELECT_НАЗВАНИЕ` нет вложенных блоков.
     *          - Теги `<!-- SELECT_НАЗВАНИЕ_BEGIN -->` и `<!-- SELECT_НАЗВАНИЕ_END -->` правильно закрыты.
     *          Несоблюдение этих условий вызовет исключение.
     *
     * Пример вызова метода внутри класса:
     * @code
     * $this->template_case('SELECT_EXAMPLE', 'VALUE1');
     * @endcode
     * @see     PhotoRigma::Classes::Template::$content
     *         Свойство, содержащее содержимое шаблона.
     */
    private function template_case(string $key, string $val): void
    {
        // Проверка, что $this->content является строкой и не пустая
        if (empty($this->content)) {
            throw new RuntimeException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Некорректное содержимое шаблона | Значение должно быть непустой строкой"
            );
        }

        // Формирование ключей для поиска
        $begin_tag = '<!-- ' . $key . '_BEGIN -->';
        $end_tag = '<!-- ' . $key . '_END -->';

        // Регулярное выражение для поиска всех блоков
        $pattern = '/' . preg_quote($begin_tag, '/') . '(.*?)' . preg_quote($end_tag, '/') . '/s';

        // Поиск всех блоков
        $this->content = preg_replace_callback($pattern, static function ($matches) use ($key, $val) {
            $block_content = $matches[1]; // Содержимое между BEGIN и END

            // Проверка на вложенность блоков SELECT_LEFT_BLOCK
            if (str_contains($block_content, '<!-- ' . $key . '_BEGIN -->') || str_contains(
                $block_content,
                '<!-- ' . $key . '_END -->'
            )) {
                throw new RuntimeException(
                    __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Ошибка обработки блока выбора | Вложенные блоки не допускаются для ключа: $key, значение: $val"
                );
            }

            // Регулярное выражение для поиска всех CASE и их содержимого
            $case_pattern = '/<!-- CASE_(.*?) -->\s*(.*?)\s*<!-- BREAK_\1 -->/s';
            preg_match_all($case_pattern, $block_content, $case_matches, PREG_SET_ORDER);

            // Добавляем DEFAULT, если он есть
            $default_pattern = '/<!-- CASE_DEFAULT -->\s*(.*?)\s*<!-- BREAK_DEFAULT -->/s';
            preg_match($default_pattern, $block_content, $default_match);

            // Поиск нужного CASE
            $result = '';
            foreach ($case_matches as $match) {
                if ($match[1] === $val) {
                    $result = $match[2]; // Содержимое найденного CASE
                    break;
                }
            }

            // Если CASE не найден, используем DEFAULT
            if (empty($result) && isset($default_match[1])) {
                $result = $default_match[1];
            }

            return $result;
        }, $this->content);

        // Если остались незакрытые теги, выбрасываем исключение
        if (str_contains($this->content, $begin_tag) || str_contains($this->content, $end_tag)) {
            throw new RuntimeException(
                __FILE__ . ":" . __LINE__ . " (" . (__METHOD__ ?: __FUNCTION__ ?: 'global') . ") | Ошибка обработки блока выбора | Незакрытые или несоответствующие теги для ключа: $key, значение: $val"
            );
        }
    }

    /**
     * @brief   Метод преобразует URL в "красивый" вид (например, `?action=profile&id=123` → `profile/id_123.html`) с
     *          использованием правил `mod_rewrite`, если они включены.
     *
     * @details Этот метод выполняет следующие шаги:
     *          1. Проверяет, включен ли режим `mod_rewrite` (свойство `$this->mod_rewrite`).
     *             - Если режим выключен, содержимое возвращается без изменений.
     *          2. Определяет формат окончания ссылки (`$end`), который может быть закрытием в кавычки или одинарные
     *             кавычки.
     *          3. Определяет шаблоны для замены URL на основе параметров запроса:
     *             - Шаблоны (`$patterns`) и замены (`$replacements`) работают в паре.
     *             - Например, `?action=profile&id=123` заменяется на `profile/id_123.html`.
     *          4. Выполняет замену URL в переданном содержимом (`$content`) с использованием регулярных выражений.
     *          5. Возвращает обработанное содержимое.
     *          Метод является приватным и предназначен только для использования внутри класса.
     *
     * @callergraph
     *
     * @param string $content Содержимое для обработки.
     *                        Должно быть строкой, содержащей HTML или текст с URL.
     *                        Пример: '<a href="?action=profile&id=123">Profile</a>'.
     *
     * @return string Обработанное содержимое с преобразованными URL.
     *                Пример: '<a href="profile/id_123.html">Profile</a>'.
     *
     * @note    Метод использует регулярные выражения для преобразования URL в "красивый" вид.
     *          Преобразование выполняется только при включенном режиме `mod_rewrite`.
     *
     * @warning Убедитесь, что:
     *          - Содержимое (`$content`) является строкой.
     *          - Правила `mod_rewrite` корректно настроены, если режим включен.
     *          Несоблюдение этих условий может привести к некорректной обработке URL.
     *
     * Пример вызова метода внутри класса:
     * @code
     * $processed_content = $this->url_mod_rewrite('<a href="?action=profile&id=123">Profile</a>');
     * echo $processed_content; // Результат: <a href="profile/id_123.html">Profile</a>
     * @endcode
     * @see     PhotoRigma::Classes::Template::$mod_rewrite
     *         Свойство, определяющее, включен ли режим `mod_rewrite`.
     */
    private function url_mod_rewrite(string $content): string
    {
        // Проверка, включен ли mod_rewrite
        if ($this->mod_rewrite) {
            // Определение окончания ссылки в зависимости от флага $txt
            $end = '("|\')';

            // Шаблоны для замены URL
            $patterns = [
                // Пример: ?action=profile&id=123 -> profile/id_123.html
                '/\?action=([A-Za-z0-9]+)(\&|\&)id=([0-9]+)' . $end . '/',

                // Пример: ?action=resend&login=user&email=user@example.com&resend=true -> resend/login=user/email=user@example.com/resend.html
                '/\?action=([A-Za-z0-9]+)(\&|\&)login=([^"?]+)(\&|\&)email=([^"?]+)(\&|\&)resend=true' . $end . '/',

                // Пример: ?action=activate&login=user&email=user@example.com&activated_code=abc123 -> activate/login=user/email=user@example.com/activated_code_abc123.html
                '/\?action=([A-Za-z0-9]+)(\&|\&)login=([^"?]+)(\&|\&)email=([^"?]+)(\&|\&)activated_code=([A-Za-z0-9]+)' . $end . '/',

                // Пример: ?action=reset&login=user&email=user@example.com -> reset/login=user/email=user@example.com/
                '/\?action=([A-Za-z0-9]+)(\&|\&)login=([^"?]+)(\&|\&)email=([^"?]+)' . $end . '/',

                // Пример: ?action=home -> home/
                '/\?action=([A-Za-z0-9]+)' . $end . '/',
            ];

            // Замены для шаблонов
            $replacements = [
                '\\1/id_\\3.html\\4',
                // profile/id_123.html
                '\\1/login=\\3/email=\\5/resend.html\\7',
                // resend/login=user/email=user@example.com/resend.html
                '\\1/login=\\3/email=\\5/activated_code_\\6.html\\7',
                // activate/login=user/email=user@example.com/activated_code_abc123.html
                '\\1/login=\\3/email=\\5/\\6',
                // reset/login=user/email=user@example.com/
                '\\1/\\2',
                // home/
            ];

            // Выполнение замены
            $content = preg_replace($patterns, $replacements, $content);
        }

        return $content;
    }

    /**
     * @brief   Формирует подвал HTML-страницы через вызов внутреннего метода.
     *
     * @details Этот публичный метод является обёрткой для защищённого метода _page_footer_internal().
     *          Он формирует подвал HTML-страницы, включая копирайт, статистику, информацию о пользователе и случайную
     *          фотографию. Метод проверяет корректность входных данных, генерирует необходимые данные и добавляет
     *          контент в конец страницы. Предназначен для прямого использования извне.
     *
     * @param int    $login_id   Идентификатор пользователя, авторизованного на сайте:
     *                           - Должен быть целым числом >= 0. Значение `0` используется для неавторизованных
     *                           пользователей.
     *                           - Пример: 123.
     * @param string $csrf_token CSRF-токен для защиты от межсайтовой подделки запросов:
     *                           - Пример: "abc123xyz".
     *                           Ограничения: параметр автоматически типизируется как строка благодаря строгой
     *                           типизации.
     *
     * @return void Метод не возвращает значений, но напрямую изменяет содержимое HTML-страницы.
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                  - Параметр `$login_id` некорректен (отрицательное число).
     *                                    Пример сообщения:
     *                                        Некорректный параметр \$login_id | Значение: [значение]
     *                                  - Параметр `$csrf_token` пустой.
     *                                    Пример сообщения:
     *                                        Некорректный параметр \$csrf_token | Значение: [значение]
     * @throws RuntimeException Выбрасывается, если возникают ошибки при обработке шаблонов или данных.
     * @throws Random\RandomException Выбрасывается методом `template_user()` в случае ошибок.
     * @throws Exception Выбрасывается методом `create_photo()` в случае ошибок.
     *
     * @note    Метод использует шаблон `footer.html` для формирования подвала. Убедитесь, что шаблон существует и
     *          доступен.
     *
     * @warning Входные параметры должны быть корректными. Особое внимание уделите параметру `$csrf_token`, так как его
     *          отсутствие или некорректность могут привести к уязвимостям безопасности. Невалидные данные могут
     *          привести к исключениям или ошибкам в работе метода.
     *
     * Пример использования:
     * @code
     * // Вызов метода из клиентского кода
     * $object = new \PhotoRigma\Classes\Template('https://example.com', '/var/www/example', 'default');
     * $object->page_footer(123, 'abc123xyz');
     * @endcode
     * @see     PhotoRigma::Classes::Template::_page_footer_internal()
     *          Защищённый метод, реализующий основную логику формирования подвала HTML-страницы.
     */
    public function page_footer(int $login_id, string $csrf_token): void
    {
        $this->_page_footer_internal($login_id, $csrf_token);
    }

    /**
     * @brief   Метод формирует подвал HTML-страницы с выводом копирайта, статистики, информации о пользователе и
     *          случайной фотографии.
     *
     * @details Этот метод выполняет следующие шаги:
     *          1. Генерирует данные для подвала, включая информацию о пользователе, статистику, лучших пользователей и
     *             случайную фотографию с помощью методов `template_user()`, `template_stat()`, `template_best_user()`
     *             и
     *             `create_photo()`.
     *          2. Создает экземпляр шаблона подвала (`footer.html`) и заполняет его строковыми данными, условиями и
     *             выбором блоков.
     *          3. Обрабатывает блоки для правой панели:
     *             - Информация о пользователе (включая CSRF-токен).
     *             - Статистика.
     *             - Лучшие пользователи.
     *             - Случайная фотография.
     *          4. Устанавливает файл шаблона и создает контент, который добавляется в конец текущего содержимого
     *          страницы. Этот метод является защищенным и предназначен для использования внутри класса или его
     *          наследников. Основная логика вызывается через публичный метод-редирект `page_footer()`.
     *
     * @callergraph
     * @callgraph
     *
     * @param int    $login_id   Идентификатор пользователя, авторизованного на сайте.
     *                           Пример: 123.
     *                           Ограничения: должно быть целым числом >= 0. Значение `0` используется для
     *                           неавторизованных пользователей.
     * @param string $csrf_token CSRF-токен для защиты от межсайтовой подделки запросов.
     *                           Пример: "abc123xyz".
     *                           Ограничения: параметр автоматически типизируется как строка благодаря строгой
     *                           типизации.
     *
     * @return void Метод не возвращает значений, но напрямую изменяет содержимое HTML-страницы.
     *
     * @throws InvalidArgumentException Выбрасывается, если:
     *                                  - Параметр `$login_id` некорректен (отрицательное число).
     *                                    Пример сообщения:
     *                                        Некорректный параметр \$login_id | Значение: [значение]
     *                                  - Параметр `$csrf_token` пустой.
     *                                    Пример сообщения:
     *                                        Некорректный параметр \$csrf_token | Значение: [значение]
     * @throws RuntimeException Выбрасывается, если возникают ошибки при обработке шаблонов или данных.
     * @throws Random\RandomException Выбрасывается методом `template_user()` в случае ошибок.
     * @throws Exception Выбрасывается методом `create_photo()` в случае ошибок.
     *
     * @note    Метод использует шаблон `footer.html` для формирования подвала. Убедитесь, что шаблон существует и
     *          доступен.
     * @warning Входные параметры должны быть корректными. Невалидные данные могут привести к исключениям или ошибкам в
     *          работе метода. Особое внимание уделите параметру `$csrf_token`, так как его отсутствие или
     *          некорректность могут привести к уязвимостям безопасности.
     *
     * Пример использования метода _page_footer_internal():
     * @code
     * // Формирование подвала страницы
     * $this->_page_footer_internal(123, 'abc123xyz');
     * @endcode
     * @see     PhotoRigma::Classes::Template::$content
     *          Свойство, содержащее текущее содержимое страницы.
     * @see     PhotoRigma::Classes::Template::add_if()
     *          Метод, используемый для добавления условий вывода фрагментов шаблона.
     * @see     PhotoRigma::Classes::Template::add_case()
     *          Метод, используемый для выбора блоков для вывода фрагментов шаблона.
     * @see     PhotoRigma::Classes::Template::create_template()
     *          Метод, используемый для создания контента из шаблона.
     * @see     PhotoRigma::Classes::Work::template_user()
     *          Метод, используемый для генерации данных о пользователе.
     * @see     PhotoRigma::Classes::Work::template_stat()
     *          Метод, используемый для генерации статистики.
     * @see     PhotoRigma::Classes::Work::template_best_user()
     *          Метод, используемый для генерации данных о лучших пользователях.
     * @see     PhotoRigma::Classes::Work::create_photo()
     *          Метод, используемый для генерации данных случайной фотографии.
     * @see     Work::clean_field()
     *          Функция, используемая для очистки данных.
     * @see     PhotoRigma::Classes::Template::page_footer()
     *          Метод, предоставляющий публичный доступ к методу _page_footer_internal().
     */
    protected function _page_footer_internal(int $login_id, string $csrf_token): void
    {
        // Генерация данных для подвала
        $user = $this->work->template_user();
        $stat = $this->work->template_stat();
        $best_user = $this->work->template_best_user($this->work->config['best_user']);
        $rand_photo = $this->work->create_photo('rand');

        // Создание экземпляра шаблона подвала
        $footer_template = new Template($this->site_url, $this->site_dir, $this->theme);

        // Добавление строковых данных в шаблон
        $footer_template->add_string_ar([
            'COPYRIGHT_YEAR' => Work::clean_field($this->work->config['copyright_year']),
            'COPYRIGHT_URL'  => Work::clean_field($this->work->config['copyright_url']),
            'COPYRIGHT_TEXT' => Work::clean_field($this->work->config['copyright_text']),
        ]);

        // Обработка блока информации о пользователе
        $footer_template->add_case('RIGHT_BLOCK', 'USER_INFO', 'RIGHT_PANEL[0]');
        $footer_template->add_string_ar($user, 'RIGHT_PANEL[0]');
        $footer_template->add_string('CSRF_TOKEN', $csrf_token, 'RIGHT_PANEL[0]');
        $footer_template->add_if('USER_NOT_LOGIN', ($login_id === 0), 'RIGHT_PANEL[0]');

        // Обработка блока статистики
        $footer_template->add_case('RIGHT_BLOCK', 'STATISTIC', 'RIGHT_PANEL[1]');
        $footer_template->add_string_ar($stat, 'RIGHT_PANEL[1]');

        // Обработка блока лучших пользователей
        $footer_template->add_case('RIGHT_BLOCK', 'BEST_USER', 'RIGHT_PANEL[2]');
        $footer_template->add_string_ar($best_user[0], 'RIGHT_PANEL[2]');
        unset($best_user[0]);
        foreach ($best_user as $key => $val) {
            $footer_template->add_string_ar([
                'U_BEST_USER_PROFILE' => $val['user_url'],
                'D_USER_NAME'         => $val['user_name'],
                'D_USER_PHOTO'        => (string)$val['user_photo'],
            ], 'RIGHT_PANEL[2]->BEST_USER[' . $key . ']');
            $footer_template->add_if('USER_EXIST', !empty($val['user_url']), 'RIGHT_PANEL[2]->BEST_USER[' . $key . ']');
        }

        // Обработка блока случайной фотографии
        $footer_template->add_case('RIGHT_BLOCK', 'RANDOM_PHOTO', 'RIGHT_PANEL[3]');
        $footer_template->add_string_ar([
            'NAME_BLOCK'             => $rand_photo['name_block'],
            'PHOTO_WIDTH'            => (string)$rand_photo['width'],
            'PHOTO_HEIGHT'           => (string)$rand_photo['height'],
            'MAX_FOTO_HEIGHT'        => (string)($this->work->config['temp_photo_h'] + 10),
            'D_NAME_PHOTO'           => $rand_photo['name'],
            'D_DESCRIPTION_PHOTO'    => $rand_photo['description'],
            'D_NAME_CATEGORY'        => $rand_photo['category_name'],
            'D_DESCRIPTION_CATEGORY' => $rand_photo['category_description'],
            'PHOTO_RATE'             => $rand_photo['rate'],
            'L_USER_ADD'             => $this->work->lang['main']['user_add'],
            'U_PROFILE_USER_ADD'     => $rand_photo['url_user'],
            'D_REAL_NAME_USER_ADD'   => $rand_photo['real_name'],
            'U_PHOTO'                => $rand_photo['url'],
            'U_THUMBNAIL_PHOTO'      => $rand_photo['thumbnail_url'],
            'U_CATEGORY'             => $rand_photo['category_url'],
        ], 'RIGHT_PANEL[3]');
        $footer_template->add_if('USER_EXISTS', !empty($rand_photo['url_user']), 'RIGHT_PANEL[3]');

        // Установка файла шаблона и создание контента
        $footer_template->template_file = $this->themes_path . 'footer.html';
        $footer_template->create_template();
        $this->content .= $footer_template->content;
        unset($footer_template);
    }
}
