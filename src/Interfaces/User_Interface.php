<?php

/**
 * Интерфейс для управления пользователями, включая регистрацию, аутентификацию, управление профилем и хранение
 * текущих настроек пользователя.
 *
 * Этот файл содержит интерфейс `User_Interface`, который определяет методы для работы с пользователями:
 * - Управление данными текущего пользователя (добавление, обновление, удаление).
 * - Работа с группами пользователей (добавление, обновление, удаление).
 * - Генерация CSRF-токенов для защиты форм.
 * - Обработка прав доступа пользователей и групп.
 * - Проверка данных для входа в систему.
 * Все ошибки, возникающие при работе с пользователями, обрабатываются через исключения.
 *
 * @author    Dark Dayver
 * @version   0.5.0
 * @since     2025-05-29
 * @namespace PhotoRigma\\Interfaces
 * @package   PhotoRigma
 *
 * @section   UserInterface_Main_Functions Основные функции
 *            - Установка объекта, реализующего интерфейс `Work_Interface` (`set_work`).
 *            - Управление свойствами пользователя и сессии (`set_property_key`, `unset_property_key`).
 *            - Генерация CSRF-токена для защиты от межсайтовой подделки запросов (`csrf_token`).
 *            - Преобразование прав пользователя в строку JSON и обратно (`encode_user_rights`,
 *              `process_user_rights`).
 *            - Добавление нового пользователя в базу данных (`add_new_user`).
 *            - Обновление данных пользователя, включая пароль, email, имя и аватар (`update_user_data`).
 *            - Обновление прав пользователя или группы через Админку (`update_user_rights`).
 *            - Удаление пользователя из системы (`delete_user`).
 *            - Добавление новой группы в систему (`add_new_group`).
 *            - Обновление данных группы (`update_group_data`).
 *            - Удаление группы из системы (`delete_group`).
 *            - Проверка данных пользователя для входа в систему (`login_user`).
 *
 * @note      Этот файл является частью системы PhotoRigma и играет ключевую роль в организации работы приложения.
 *            Реализация интерфейса гарантирует единообразие работы с пользователями и их данными.
 *
 * @copyright Copyright (c) 2008-2025 Dark Dayver. Все права защищены.
 * @license   MIT License {@link https://opensource.org/licenses/MIT}
 *            Разрешается использовать, копировать, изменять, объединять, публиковать, распространять,
 *            сублицензировать и/или продавать копии программного обеспечения, а также разрешать лицам, которым
 *            предоставляется данное программное обеспечение, делать это при соблюдении следующих условий:
 *            - Уведомление об авторских правах и условия лицензии должны быть включены во все копии или значимые
 *              части программного обеспечения.
 */

namespace PhotoRigma\Interfaces;

use Exception;
use InvalidArgumentException;
use JsonException;
use PDOException;
use Random;
use RuntimeException;

// Предотвращение прямого вызова файла
if (!defined('IN_GALLERY') || IN_GALLERY !== true) {
    /** @noinspection ForgottenDebugOutputInspection */
    error_log(
        date('H:i:s') . ' [ERROR] | ' . (filter_input(
            INPUT_SERVER,
            'REMOTE_ADDR',
            FILTER_VALIDATE_IP
        ) ?: 'UNKNOWN_IP') . ' | ' . __FILE__ . ' | Попытка прямого вызова файла'
    );
    die('HACK!');
}

/**
 * Интерфейс для работы с пользователями и группами.
 *
 * Этот интерфейс определяет контракт для классов, реализующих методы добавления, обновления и удаления пользователей
 * и групп. Он должен обеспечивать:
 * - Работу с данными пользователя (логин, пароль, email, имя)
 * - Поддержку мягкого и окончательного удаления
 * - Генерацию CSRF-токенов
 * - Обработку прав доступа
 * - Совместимость с различными СУБД
 * - Логирование ошибок
 * - Защиту от некорректных действий администраторов
 * - Формирование данных для шаблонов
 * Реализация обязана работать корректно как через cron, так и из веб-интерфейса.
 *
 * Методы интерфейса:
 * - Установка объекта Work (`set_work`)
 * - Управление свойствами (`set_property_key`, `unset_property_key`)
 * - Генерация CSRF-токена (`csrf_token`)
 * - Кодирование/декодирование прав (`encode_user_rights`, `process_user_rights`)
 * - Добавление пользователя (`add_new_user`)
 * - Обновление данных пользователя (`update_user_data`)
 * - Обновление прав пользователя (`update_user_rights`)
 * - Удаление пользователя (`delete_user`)
 * - Принудительное обезличивание и удаление (`hard_delete_user`)
 * - Запуск фоновой задачи удаления (`cron_user_delete`)
 * - Добавление группы (`add_new_group`)
 * - Обновление группы (`update_group_data`)
 * - Удаление группы (`delete_group`)
 * - Вход пользователя (`login_user`)
 *
 * @note    Используются константы с именами таблиц базы данных.
 *
 * @warning Реализация зависит от глобального массива $_SESSION. Некорректная работа с ним может привести
 *          к ошибкам при работе с пользователями и группами.
 */
interface User_Interface
{
    /**
     * Устанавливает объект, реализующий интерфейс Work_Interface.
     *
     * Этот метод является частью контракта интерфейса и должен быть реализован в классе.
     * Он выполняет следующие действия:
     * 1. Присваивает объект для дальнейшего использования.
     * 2. Если в сессии отсутствует тема (`theme`), она инициализируется значением из конфигурации объекта,
     *    реализующего интерфейс `Work_Interface`.
     *
     * @param Work_Interface $work Объект, реализующий интерфейс `Work_Interface`:
     *                             - Должен быть экземпляром класса, реализующего интерфейс `Work_Interface`.
     *
     * @return void Метод ничего не возвращает.
     *
     * @note    Метод проверяет тип переданного объекта.
     *          Объект используется для дальнейшего взаимодействия в текущем классе.
     *
     * @warning Некорректный объект (не реализует интерфейс `Work_Interface`) вызывает исключение.
     *
     * @uses \PhotoRigma\Interfaces\Work_Interface Интерфейс, которому должен соответствовать объект.
     */
    public function set_work(Work_Interface $work): void;

    /**
     * Устанавливает значение свойства в массивах данных пользователя или сессии.
     *
     * Этот метод является частью контракта интерфейса и должен быть реализован в классе.
     * Он выполняет следующие действия:
     * 1. Проверяет, какой массив нужно изменить, на основе параметра `$name`.
     * 2. Устанавливает значение по указанному ключу в выбранном массиве.
     * 3. Если передано недопустимое имя свойства (не 'user' и не 'session'), выбрасывается исключение.
     *
     * @param string          $name  Имя свойства:
     *                               - Допустимые значения: 'user' (для массива данных пользователя) или 'session'
     *                                 (для массива данных сессии).
     *                               Пример: "user".
     * @param string          $key   Ключ, по которому будет установлено значение:
     *                               - Должен быть строкой.
     *                               Пример: "username".
     * @param string|int|bool $value Значение, которое будет установлено:
     *                               - Может быть строкой, целым числом или булевым значением.
     *                               Пример: "admin" (строка), 123 (целое число), true (булево значение).
     *
     * @return void Метод ничего не возвращает.
     *
     * @throws InvalidArgumentException Выбрасывается, если параметр `$name` содержит недопустимое значение.
     *
     * @note    Метод изменяет массивы данных пользователя или сессии напрямую.
     *          Перед установкой значения проверяется корректность имени свойства.
     *
     * @warning Недопустимое значение параметра `$name` приведет к выбросу исключения.
     *          Убедитесь, что передаете только допустимые значения ('user' или 'session').
     */
    public function set_property_key(string $name, string $key, string|int|bool $value): void;

    /**
     * Удаляет ключ из указанного свойства объекта (user или session).
     *
     * Этот метод является частью контракта интерфейса и должен быть реализован в классе.
     * Он выполняет следующие действия:
     * 1. Проверяет, какой массив изменять, на основе параметра `$name`.
     * 2. Если ключ существует в выбранном массиве, он удаляется.
     * 3. Если указанный массив недопустим (не 'user' и не 'session'), выбрасывается исключение.
     *
     * @param string $name Имя свойства, из которого удаляется ключ:
     *                     - Допустимые значения: 'user' (для массива данных пользователя) или 'session'
     *                       (для массива данных сессии).
     *                     Пример: "user".
     * @param string $key  Ключ, который нужно удалить:
     *                     - Должен быть строкой.
     *                     Пример: "email".
     *                     Ограничения: если ключ отсутствует в массиве, метод завершается без ошибок.
     *
     * @return void Метод ничего не возвращает.
     *
     * @throws InvalidArgumentException Выбрасывается, если указано недопустимое значение для параметра `$name`.
     *
     * @note    Метод изменяет только массивы данных пользователя ('user') или сессии ('session').
     *          Если ключ отсутствует в массиве, метод завершается без ошибок.
     *
     * @warning Не используйте этот метод для удаления ключей из других свойств.
     *          Передавайте только допустимые значения для параметра `$name`.
     */
    public function unset_property_key(string $name, string $key): void;

    /**
     * Генерирует или возвращает CSRF-токен для защиты от межсайтовой подделки запросов.
     *
     * Этот метод является частью контракта интерфейса и должен быть реализован в классе.
     * Он выполняет следующие действия:
     * 1. Проверяет, существует ли CSRF-токен в сессии.
     * 2. Если токен отсутствует, генерирует новый токен длиной 64 символа.
     * 3. Сохраняет сгенерированный токен в сессии.
     * 4. Возвращает текущий CSRF-токен (либо существующий, либо вновь сгенерированный).
     *
     * @return string CSRF-токен длиной 64 символа.
     *
     * @throws Random\RandomException Выбрасывается, если возникает ошибка при генерации случайных байтов.
     *
     * @note    Токен хранится в сессии и используется для защиты форм от CSRF-атак.
     *
     * @warning Не используйте этот метод для генерации токенов, если сессия недоступна или не инициализирована.
     */
    public function csrf_token(): string;

    /**
     * Преобразует массив прав пользователя в строку JSON.
     *
     * Этот метод является частью контракта интерфейса и должен быть реализован в классе.
     * Он выполняет следующие действия:
     * 1. Проверяет, существует ли входной массив. Если массив отсутствует или пуст, возвращается пустая строка.
     * 2. Проверяет, что входное значение является массивом. Если тип данных некорректен, выбрасывается исключение.
     * 3. Кодирует массив в строку JSON с использованием флагов:
     *    - `JSON_THROW_ON_ERROR`: Генерирует исключение при ошибках кодирования.
     *    - `JSON_UNESCAPED_UNICODE`: Сохраняет Unicode-символы без экранирования.
     *    - `JSON_UNESCAPED_SLASHES`: Не экранирует слеши (`/`).
     * 4. Возвращает строку JSON, готовую для сохранения в поле `user_rights`.
     *
     * @param array $rights Массив прав пользователя:
     *                      - Может быть ассоциативным массивом, пустым значением или `null`.
     *                      Пример: ['edit' => true, 'delete' => false].
     *                      Ограничения: значение должно быть массивом.
     *
     * @return string Строка JSON, представляющая права пользователя:
     *                - Если массив отсутствует или содержит некорректные данные, возвращается пустая строка.
     *                Пример: '{"edit":true,"delete":false}'.
     *
     * @throws InvalidArgumentException Выбрасывается, если входное значение не является массивом.
     * @throws JsonException            Выбрасывается, если возникает ошибка при кодировании массива в JSON.
     *
     * @note    Метод возвращает пустую строку, если массив прав отсутствует или содержит некорректные данные.
     *          Если кодирование JSON завершается успешно, возвращается строка JSON.
     *
     * @warning Входные данные должны быть корректным массивом. Некорректные данные могут привести к выбросу
     *          исключения.
     */
    public function encode_user_rights(array $rights): string;

    /**
     * Обрабатывает поле `user_rights`, преобразуя его из строки JSON в массив прав.
     *
     * Этот метод является частью контракта интерфейса и должен быть реализован в классе.
     * Он выполняет следующие действия:
     * 1. Проверяет, существует ли поле `user_rights`. Если поле отсутствует или пустое, возвращается пустой массив.
     * 2. Проверяет, что поле является строкой. Если тип данных некорректен, выбрасывается исключение.
     * 3. Декодирует строку JSON в ассоциативный массив с использованием флагов:
     *    - `JSON_THROW_ON_ERROR`: Генерирует исключение при ошибках декодирования.
     * 4. Возвращает массив прав, готовый для использования.
     *
     * @param string $user_rights Значение поля `user_rights`:
     *                            - Может быть строкой JSON, пустым значением или `null`.
     *                            Пример: '{"edit": 1, "delete": 0}'.
     *                            Ограничения: значение должно быть строкой, содержащей валидный JSON.
     *
     * @return array Ассоциативный массив прав пользователя:
     *               - Если поле `user_rights` отсутствует или содержит некорректные данные, возвращается пустой
     *                 массив.
     *               Пример: ['edit' => 1, 'delete' => 0].
     *
     * @throws InvalidArgumentException Выбрасывается, если поле `user_rights` не является строкой.
     * @throws JsonException            Выбрасывается, если поле `user_rights` содержит невалидный JSON.
     *
     * @note    Метод возвращает пустой массив, если поле `user_rights` отсутствует или содержит некорректные данные.
     *          Если декодирование JSON завершается успешно, возвращается ассоциативный массив прав.
     *
     * @warning Поле `user_rights` должно содержать валидный JSON. Невалидные данные могут привести к выбросу
     *          исключения.
     */
    public function process_user_rights(string $user_rights): array;

    /**
     * Добавляет нового пользователя в базу данных, выполняя валидацию входных данных.
     *
     * Этот метод является частью контракта интерфейса и должен быть реализован в классе.
     * Он выполняет следующие действия:
     * 1. Проверяет корректность входных данных:
     *    - Логин проверяется на соответствие регулярному выражению.
     *    - Пароль проверяется на пустоту и совпадение с повторным паролем.
     *    - Email проверяется на соответствие регулярному выражению.
     *    - Реальное имя проверяется на соответствие регулярному выражению.
     *    - CAPTCHA проверяется на числовое значение и совпадение с хешем из сессии.
     *    Если данные некорректны, ошибки сохраняются в сессии.
     * 2. Проверяет уникальность логина, email и реального имени в базе данных.
     * 3. Если возникли ошибки, метод завершает выполнение и возвращает `0`.
     * 4. При успешной валидации добавляет нового пользователя в базу данных, назначая ему группу по умолчанию.
     *    - Пароль хэшируется с использованием `password_hash()`.
     * 5. Возвращает ID нового пользователя или `0` в случае ошибки.
     *
     * @param array $post_data Массив данных из формы ($_POST), содержащий новые значения для полей пользователя:
     *                         - string $login: Логин пользователя (должен соответствовать регулярному выражению).
     *                         - string $password: Пароль пользователя (не должен быть пустым).
     *                         - string $re_password: Повтор пароля (должен совпадать с $password).
     *                         - string $email: Email пользователя (должен соответствовать регулярному выражению).
     *                         - string $real_name: Реальное имя пользователя (должно соответствовать регулярному
     *                           выражению).
     *                         - string $captcha: Значение CAPTCHA (должно быть числом).
     *                         Все поля обязательны для заполнения.
     *
     * @return int ID нового пользователя, если регистрация успешна, или `0` в случае ошибки.
     *
     * @throws RuntimeException Выбрасывается, если группа по умолчанию не найдена в базе данных.
     * @throws PDOException     Выбрасывается, если возникает ошибка при работе с базой данных.
     * @throws Exception        Выбрасывается, если возникает ошибка при проверке входных данных.
     *
     * @note    Используется CAPTCHA для защиты от автоматической регистрации.
     *          Константы, используемые в методе:
     *          - Регулярное выражение для проверки логина.
     *          - Регулярное выражение для проверки email.
     *          - Регулярное выражение для проверки реального имени.
     *          Эти константы позволяют гибко настраивать поведение метода.
     *
     * @warning Метод зависит от корректной конфигурации базы данных и таблицы групп. Убедитесь, что все необходимые
     *          константы и таблицы настроены правильно. Невалидные данные могут привести к ошибкам.
     */
    public function add_new_user(array $post_data): int;

    /**
     * Обновляет данные существующего пользователя, включая пароль, email, имя и аватар.
     *
     * Этот метод является частью контракта интерфейса и должен быть реализован в классе.
     * Он выполняет следующие действия:
     * 1. Проверяет существование пользователя с указанным `$user_id` в базе данных. Если пользователь не найден,
     *    выбрасывается исключение.
     * 2. Валидирует и обновляет пароль:
     *    - Проверяет текущий пароль через `password_verify()`.
     *    - Если новый пароль передан и совпадает с повторным вводом, обновляет его через `password_hash()`.
     * 3. Проверяет уникальность email и имени пользователя в базе данных.
     * 4. Обрабатывает загрузку нового аватара:
     *    - Если файл проходит валидацию, загружает новый аватар.
     *    - Удаляет старый аватар, если он отличается от нового и не является аватаром по умолчанию.
     * 5. Проверяет и обновляет язык (`language`) и тему (`theme`) сайта, если они переданы.
     * 6. Формирует SQL-запрос для обновления данных пользователя в таблице пользователей.
     * 7. Возвращает количество затронутых строк в базе данных после выполнения обновления.
     *
     * @param int   $user_id    Идентификатор пользователя, данные которого необходимо обновить:
     *                          - Должен быть положительным целым числом и существовать в базе данных.
     *                          Пример: 1.
     *                          Ограничения: ID должен быть больше 0.
     * @param array $post_data  Массив данных из формы ($_POST), содержащий новые значения для полей пользователя:
     *                          - string $password: Текущий пароль пользователя (обязательно для изменения пароля).
     *                          - string $edit_password: Новый пароль пользователя (необязательно).
     *                          - string $re_password: Повторный ввод нового пароля (должен совпадать с
     *                            `edit_password`).
     *                          - string $email: Новый email пользователя (должен соответствовать регулярному
     *                            выражению).
     *                          - string $real_name: Новое имя пользователя (должно быть строкой).
     *                          Все поля проходят валидацию перед использованием.
     * @param array $files_data Массив данных загруженного файла ($_FILES), содержащий информацию об аватаре:
     *                          - 'file_avatar' (array): Информация о загруженном файле (необязательно).
     *                          Если файл не передан или не проходит валидацию, аватар остаётся без изменений.
     * @param int   $max_size   Максимальный размер файла для аватара в байтах:
     *                          - Должен быть положительным целым числом.
     *                          Пример: 5 * 1024 * 1024 (5 MB).
     *                          Ограничения: значение должно быть больше 0.
     *
     * @return int Количество затронутых строк в базе данных после выполнения обновления:
     *             - Возвращается `0`, если данные не изменились или запрос завершился ошибкой.
     *
     * @throws RuntimeException Выбрасывается, если пользователь с указанным `$user_id` не найден в базе данных.
     * @throws Exception        Выбрасывается, если возникает ошибка при проверке входных данных или обработке аватара.
     *
     * @note    Для обработки аватаров используется метод загрузки файлов. Старый аватар удаляется, если новый успешно
     *          загружен и отличается от старого. Константы, используемые в методе:
     *          - Регулярное выражение для проверки email.
     *          Эти константы позволяют гибко настраивать поведение метода.
     *
     * @warning Не используйте этот метод для массового обновления данных. Он предназначен только для работы с одним
     *          пользователем за раз.
     */
    public function update_user_data(int $user_id, array $post_data, array $files_data, int $max_size): int;

    /**
     * Обновляет права пользователя или группу через Админку.
     *
     * Этот метод является частью контракта интерфейса и должен быть реализован в классе.
     * Он выполняет следующие действия:
     * 1. Проверяет, изменилась ли группа пользователя в `$post_data`. Если группа изменилась:
     *    - Получает данные новой группы из базы данных.
     *    - Обновляет ID группы пользователя и связанные права доступа.
     *    - Декодирует обновленные права доступа пользователя в массив.
     * 2. Если группа не изменилась:
     *    - Проверяет, отличаются ли текущие права пользователя от переданных в `$post_data`.
     *    - Нормализует значения прав доступа (true/false).
     *    - Кодирует обновленные права доступа в JSON-строку.
     *    - Обновляет права доступа пользователя в базе данных.
     * 3. Возвращает обновленные данные пользователя, включая все поля прав доступа и ID группы.
     *
     * @param int   $user_id   Идентификатор пользователя:
     *                         - Должен быть положительным целым числом.
     *                         Пример: 123.
     *                         Ограничения: ID должен быть больше 0.
     * @param array $user_data Данные пользователя:
     *                         - Должен содержать ключ `group_id` (ID текущей группы пользователя).
     *                         - Также должен содержать все поля прав доступа.
     *                         Пример: ['group_id' => 2, 'edit' => true, 'delete' => false].
     * @param array $post_data Данные, полученные из POST-запроса:
     *                         - Должен содержать ключ `group` (ID новой группы пользователя).
     *                         - Также должен содержать все поля прав доступа.
     *                         Пример: ['group' => 3, 'edit' => 'on', 'delete' => false].
     *
     * @return array Возвращает массив данных пользователя:
     *               - `group_id`: ID группы пользователя.
     *               - Все поля прав доступа.
     *               Пример: ['group_id' => 3, 'edit' => true, 'delete' => false].
     *
     * @throws RuntimeException Выбрасывается, если:
     *                          - Не удалось получить данные группы из базы данных.
     *                          - Произошла ошибка при обновлении данных пользователя в базе данных.
     * @throws JsonException    Выбрасывается, если возникает ошибка при кодировании или декодировании JSON.
     * @throws Exception        Выбрасывается, если возникает ошибка при проверке входных данных.
     *
     * @note    Метод использует нормализацию значений прав доступа (true/false) и их последующее кодирование в
     *          JSON-строку. Константы, используемые в методе:
     *          - Регулярное выражение для проверки email.
     *          Эти константы позволяют гибко настраивать поведение метода.
     *
     * @warning Убедитесь, что входные данные корректны. Невалидные данные могут привести к исключениям.
     */
    public function update_user_rights(int $user_id, array $user_data, array $post_data): array;

    /**
     * Публичный метод для мягкого или окончательного удаления пользователя.
     *
     * Метод является частью контракта и определяет следующие обязательства:
     * - Должен поддерживать мягкое удаление (помечаем `deleted_at`)
     * - Должен поддерживать окончательное удаление (удаляем запись)
     * - Должен учитывать права доступа при окончательном удалении
     * - Должен запрещать самоудаление администратором
     * - Должен предотвращать удаление последнего активного админа
     * - Должен логировать действия
     * - Должен возвращать FALSE при нарушении ограничений
     *
     * @param int      $user_id   Идентификатор пользователя, которого нужно удалить.
     *                            Должен быть положительным целым числом (`> 0`).
     *                            Пример: 123.
     *                            Ограничения: ID должен быть больше 0.
     * @param bool     $permanent [optional] Указывает, какое удаление выполнить:
     *                            - `FALSE` (по умолчанию): мягкое удаление
     *                            - `TRUE`: окончательное удаление
     *
     * @return bool `TRUE`, если удаление прошло успешно, `FALSE` в случае ошибки:
     *              - Пользователь не найден
     *              - Нарушены ограничения безопасности (самоудаление админа, последний админ)
     *              - Не удалось выполнить SQL-запрос
     *
     * @throws Exception Выбрасывается, если произошла ошибка на уровне СУБД (например, ошибка запроса).
     *                   Это позволяет внешнему коду обрабатывать такие ошибки отдельно.
     *
     * @note    Реализация должна обеспечивать чистый вывод данных и совместимость с различными СУБД.
     *
     * @warning Нарушение контракта может привести к некорректной работе системы удаления.
     *          Убедитесь, что реализация соответствует заданному поведению.
     */
    public function delete_user(int $user_id, bool $permanent = false): bool;

    /**
     * Публичный метод для окончательного обезличивания и удаления пользователя.
     *
     * Метод является частью контракта интерфейса и определяет требования к реализации.
     * Он должен обеспечивать:
     * - Удаление личного контента перед окончательным удалением аккаунта
     * - Обезличивание данных пользователя
     * - Проверку истечения срока мягкого удаления
     * - Логирование всех действий
     * - Предотвращение удаления последнего администратора
     * - Защиту от самоудаления администратора
     * - Поддержку принудительного удаления из админки (через параметр $force)
     * - Совместимость с вызовом как через cron, так и через админ-панель
     *
     * @param int  $user_id ID пользователя, которого нужно окончательно удалить.
     *                       Должен быть положительным целым числом (`> 0`).
     *                       Пример: 123.
     * @param bool $force   [optional] Режим принудительного удаления:
     *                      - FALSE (по умолчанию): удаление через cron после истечения срока восстановления.
     *                      - TRUE: принудительное удаление из админки — требует подтверждения прав администратора.
     *
     * @return bool TRUE при успехе, FALSE при ошибке или невозможности удаления.
     *
     * @throws Exception При ошибках выполнения SQL-запросов.
     *
     * @note    Реализация обязана возвращать FALSE при попытке удалить последнего админа или при нарушении условий.
     *
     * @warning Нарушение контракта может привести к некорректной работе системы удаления.
     *          Убедитесь, что реализация соответствует заданному поведению.
     */
    public function hard_delete_user(int $user_id, bool $force = false): bool;

    /**
     * Публичный метод для запуска фоновой задачи окончательного удаления пользователей.
     *
     * Этот метод является частью контракта интерфейса и должен быть реализован в классе.
     * Он предназначен для выполнения фонового процесса обезличивания пользователей, у которых истёк срок
     * восстановления после мягкого удаления.
     *
     * Реализация должна обеспечивать:
     * - Защиту от запуска через веб-интерфейс
     * - Логирование всех этапов выполнения
     * - Совместимость с различными СУБД
     * - Корректную работу в режиме CLI (через cron)
     *
     * @return void Метод не возвращает значения.
     *
     * @throws Exception Может выбрасываться при ошибках логирования или выполнении SQL-запросов.
     *
     * @warning Убедитесь, что метод запускается только через cron.php. Нарушение условий может привести к исключениям.
     */
    public function cron_user_delete(): void;

    /**
     * Добавляет новую группу в систему через Админку.
     *
     * Метод является частью контракта и должен быть реализован в классе.
     * Он обязан:
     * - Принимать данные группы, включая имя и права доступа
     * - Проверять корректность входных данных
     * - Создавать запись о группе в базе данных
     * - Возвращать ID созданной группы
     * Реализация должна поддерживать вызов как из веб-интерфейса, так и фоновых задач.
     *
     * @param array $group_data Данные новой группы:
     *                          - `name_group`: Имя группы (валидируется через REG_NAME)
     *                          - Права доступа: все поля из доступных.
     *                          Пример: ['name_group' => 'Moderators', 'read' => true, 'write' => false]
     *
     * @return int ID новой группы при успешном добавлении.
     *
     * @throws InvalidArgumentException Выбрасывается, если данные группы не прошли проверку.
     * @throws JsonException            Выбрасывается, если не удалось кодировать права в JSON.
     * @throws Exception                При внутренних ошибках выполнения.
     *
     * @note    Формат `$group_data` определяется контрактом — реализация обязана его обработать.
     *
     * @warning Нарушение формата `$group_data` может привести к ошибкам валидации или SQL-запросам.
     */
    public function add_new_group(array $group_data): int;

    /**
     * Обновляет данные группы в системе через Админку.
     *
     * Этот метод является частью контракта интерфейса и должен быть реализован в классе.
     * Он выполняет следующие действия:
     * 1. Проверяет и обновляет название группы, если оно изменилось в `$post_data`.
     *    - Очищает новое название для безопасности.
     *    - Обновляет поле `name` в таблице групп через SQL-запрос.
     * 2. Обновляет права доступа группы:
     *    - Проверяет каждое поле прав доступа.
     *    - Нормализует значения прав доступа (true/false).
     *    - Кодирует обновленные права доступа в JSON-строку.
     * 3. Обновляет поле `user_rights` в таблице групп через SQL-запрос.
     * 4. Возвращает обновленные данные группы, включая название и все поля прав доступа.
     *
     * @param array $group_data Данные группы:
     *                          - Должен содержать ключи:
     *                          - `name`: Текущее название группы.
     *                          - `user_rights`: JSON-строка с текущими правами группы.
     *                          Может также содержать поля прав доступа.
     *                          Пример:
     *                          [
     *                              'name' => 'Moderators',
     *                              'user_rights' => '{"edit": true, "delete": false}',
     *                          ].
     * @param array $post_data  Данные, полученные из POST-запроса:
     *                          - Должен содержать ключ:
     *                          - `id_group`: ID группы.
     *                          Может также содержать ключ:
     *                          - `name_group`: Новое название группы.
     *                          И поля прав доступа.
     *                          Пример:
     *                          [
     *                              'id_group' => 2,
     *                              'name_group' => 'Editors',
     *                              'edit' => 'on',
     *                              'delete' => false,
     *                          ].
     *
     * @return array Возвращает массив данных группы:
     *               - `name`: Название группы.
     *               - Все поля прав доступа.
     *               Пример:
     *               [
     *                   'name' => 'Editors',
     *                   'edit' => true,
     *                   'delete' => false,
     *               ].
     *
     * @throws RuntimeException Выбрасывается, если произошла ошибка при обновлении данных в базе данных.
     * @throws JsonException    Выбрасывается, если возникает ошибка при кодировании или декодировании JSON.
     * @throws Exception        Выбрасывается, если возникает ошибка при проверке входных данных.
     *
     * @note    Метод использует нормализацию значений прав доступа (true/false) и их последующее кодирование в
     *          JSON-строку. Константы, используемые в методе:
     *          - Регулярное выражение для проверки названия группы.
     *          Эти константы позволяют гибко настраивать поведение метода.
     *
     * @warning Убедитесь, что входные данные корректны. Невалидные данные могут привести к исключениям.
     */
    public function update_group_data(array $group_data, array $post_data): array;

    /**
     * Удаляет группу из системы через Админку.
     *
     * Метод является частью контракта и должен быть реализован в классе.
     * Он обязан:
     * - Принимать ID группы как параметр
     * - Проверять, можно ли удалить эту группу (например, не защищена ли она)
     * - Переводить всех пользователей этой группы на группу по умолчанию
     * - Удалять запись группы из базы данных
     * - Возвращать логическое значение результата операции
     * Реализация должна поддерживать вызов как из веб-интерфейса, так и фоновых задач.
     *
     * @param int $group_id ID группы, которую нужно удалить.
     *                      Должен быть положительным целым числом (`> 0`).
     *                      Пример: 123.
     *
     * @return bool `TRUE`, если группа успешно удалена.
     *              `FALSE`, если удаление невозможно (группа защищена или ошибка БД).
     *
     * @throws Exception При внутренних ошибках выполнения.
     *
     * @note    Реализация обязана обеспечить:
     *          - Чистый вывод данных
     *          - Защиту от инъекций
     *          - Совместимость с различными СУБД
     *
     * @warning Нарушение контракта может привести к некорректной работе системы прав и групп.
     *          Убедитесь, что реализация соответствует заданным требованиям.
     */
    public function delete_group(int $group_id): bool;

    /**
     * Проверяет данные пользователя для входа в систему с "мягким" обновлением паролей на новый формат хранения.
     *
     * Метод выполняет следующие действия:
     * - Проверяет корректность входных данных (логин и пароль) с использованием `Work::check_input()`.
     * - Ищет пользователя в базе данных по логину.
     * - Проверяет статус удаления пользователя:
     *   - Если установлен флаг `permanently_deleted`, доступ запрещён.
     *   - Если установлена дата `deleted_at` и срок восстановления истёк, доступ запрещён.
     *   - Если срок восстановления не истёк, аккаунт восстанавливается (обнуляется `deleted_at`).
     * - Проверяет пароль через `password_verify()` и, при необходимости, через `md5`.
     * - Если пароль хранится в старом формате (md5), он обновляется до формата `password_hash()`.
     * - Возвращает ID пользователя или 0 в случае ошибки.
     *
     * @param array  $post         Массив данных из формы ($_POST), содержащий ключи:
     *                             - string $login: Логин пользователя (должен соответствовать регулярному выражению
     *                               REG_LOGIN).
     *                             - string $password: Пароль пользователя (не должен быть пустым).
     * @param string $redirect_url URL для перенаправления пользователя в случае возникновения ошибок.
     *                             Ограничения: должен быть валидным URL.
     *
     * @return int ID пользователя, если авторизация успешна, или 0 в случае ошибки.
     *
     * @note    Поддерживается совместимость со старым форматом хранения паролей (md5). При обнаружении старого формата
     *          пароль автоматически обновляется до формата `password_hash()`. Также поддерживается восстановление
     *          временно удалённых аккаунтов, если срок восстановления ещё не истёк.
     *
     * @warning Метод зависит от корректной конфигурации базы данных. Убедитесь, что таблица пользователей и поля
     *          (`id`, `login`, `password`, `deleted_at`, `permanently_deleted`) настроены правильно.
     *          Невалидные данные могут привести к исключениям.
     */
    public function login_user(array $post, string $redirect_url): int;

    /**
     * Проверяет, истёк ли срок восстановления мягкого удаления.
     *
     * Метод является частью контракта интерфейса и определяет обязательное поведение:
     * - Должен принимать дату мягкого удаления из внешнего источника
     * - Должен возвращать информацию о:
     *   a) Дате удаления
     *   b) Сроке истечения
     *   c) Факте истечения (`expired`)
     * - Должен корректно обрабатывать NULL `$deleted_at`
     * - Должен обеспечивать совместимость с публичными и фоновыми задачами
     *
     * @param string|null $deleted_at Дата и время мягкого удаления (формат MySQL DATETIME).
     *                                Может быть NULL, если пользователь не удален.
     *
     * @return array Ассоциативный массив с данными о сроке:
     *               - 'restore_date'   => ?DateTime Дата мягкого удаления
     *               - 'restore_expiry' => ?DateTime Дата истечения срока восстановления
     *               - 'expired'        => bool Указывает, истёк ли срок
     *
     * @throws Exception При внутренних ошибках выполнения.
     *
     * @note    Реализация должна быть совместима с вызовом из публичного кода и фоновых задач.
     *
     * @warning Некорректная реализация может привести к неверной оценке срока восстановления.
     */
    public function is_soft_delete_expired(?string $deleted_at): array;
}
